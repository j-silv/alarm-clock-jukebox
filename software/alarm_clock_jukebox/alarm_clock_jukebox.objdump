
alarm_clock_jukebox.elf:     file format elf32-littlenios2
alarm_clock_jukebox.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00040244

Program Header:
    LOAD off    0x00001000 vaddr 0x00040000 paddr 0x00040000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00040020 paddr 0x00040020 align 2**12
         filesz 0x00007564 memsz 0x00007564 flags r-x
    LOAD off    0x00008584 vaddr 0x00047584 paddr 0x00047920 align 2**12
         filesz 0x0000039c memsz 0x0000039c flags rw-
    LOAD off    0x00008cbc vaddr 0x00047cbc paddr 0x00047cbc align 2**12
         filesz 0x00000000 memsz 0x00000138 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00040000  00040000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  00040020  00040020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000583c  00040244  00040244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00001b04  00045a80  00045a80  00006a80  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000039c  00047584  00047920  00008584  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000138  00047cbc  00047cbc  00008cbc  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  00047df4  00047df4  00008920  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00008920  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000790  00000000  00000000  00008948  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0000955c  00000000  00000000  000090d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00003629  00000000  00000000  00012634  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000408a  00000000  00000000  00015c5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001458  00000000  00000000  00019ce8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00002481  00000000  00000000  0001b140  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000297e  00000000  00000000  0001d5c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000020  00000000  00000000  0001ff40  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000005a0  00000000  00000000  0001ff60  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00022932  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000a  00000000  00000000  00022935  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0002293f  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00022940  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  00022941  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  00022945  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  00022949  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   0000000b  00000000  00000000  0002294d  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    0000000b  00000000  00000000  00022958  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   0000000b  00000000  00000000  00022963  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000b  00000000  00000000  0002296e  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000061  00000000  00000000  00022979  2**0
                  CONTENTS, READONLY
 29 .jdi          0000599a  00000000  00000000  000229da  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     000856a0  00000000  00000000  00028374  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00040000 l    d  .entry	00000000 .entry
00040020 l    d  .exceptions	00000000 .exceptions
00040244 l    d  .text	00000000 .text
00045a80 l    d  .rodata	00000000 .rodata
00047584 l    d  .rwdata	00000000 .rwdata
00047cbc l    d  .bss	00000000 .bss
00047df4 l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../alarm_clock_jukebox_bsp//obj/HAL/src/crt0.o
0004027c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 altera_avalon_pwm_routines.c
00000000 l    df *ABS*	00000000 display.c
00000000 l    df *ABS*	00000000 interrupt.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 pwm.c
00000000 l    df *ABS*	00000000 rtttl.c
00000000 l    df *ABS*	00000000 switches.c
00047cd0 l     O .bss	00000006 mode.1651
00000000 l    df *ABS*	00000000 time_keeper.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 subsf3.c
00000000 l    df *ABS*	00000000 fixsfsi.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00043fb0 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
0004762c l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
0004490c l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00044a64 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00044b98 l     F .text	00000034 alt_dev_reg
0004770c l     O .rwdata	0000002c jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_close.c
00044e7c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00044fa8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00044fd4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00045184 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
000452c4 l     F .text	0000003c alt_get_errno
00045300 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00047cf0 g     O .bss	00000004 alt_instruction_exception_handler
00041698 g     F .text	000000e4 writePWM
00040824 g     F .text	00000048 timerPWMRegisterISR
000414f0 g     F .text	000000c8 timerPWMISR
000449f8 g     F .text	0000006c alt_main
00043f00 g     F .text	00000080 _puts_r
00041a60 g     F .text	00000020 getSongIndex
00047cf4 g     O .bss	00000100 alt_irq
00047920 g       *ABS*	00000000 __flash_rwdata_start
000409b4 g     F .text	0000028c writeLEDPiano
00043eb4 g     F .text	0000004c printf
00042898 g     F .text	00000084 getClockTime
00042ab0 g     F .text	000000b0 upClockHour
00047ccc g     O .bss	00000004 p
00043cb4 g     F .text	00000070 .hidden __fixsfsi
0004075c g     F .text	00000048 buttonsRegisterISR
00041614 g     F .text	00000038 downVolume
0004557c g     F .text	00000024 altera_nios2_gen2_irq_init
00040000 g     F .entry	0000001c __reset
00040020 g       *ABS*	00000000 __flash_exceptions_start
00047cdc g     O .bss	00000004 errno
00047ce8 g     O .bss	00000004 alt_argv
0004f8e0 g       *ABS*	00000000 _gp
000437d0 g     F .text	000004e4 .hidden __subsf3
000478f9 g     O .rwdata	00000001 time_format
00040938 g     F .text	00000030 alarmLEDon
00047760 g     O .rwdata	00000180 alt_fd_list
000455a0 g     F .text	00000090 alt_find_dev
00045248 g     F .text	0000007c alt_io_redirect
00043f80 g     F .text	00000014 puts
000450e8 g     F .text	0000009c alt_exception_cause_generated_bad_addr
00044cfc g     F .text	000000ec altera_avalon_jtag_uart_read
00043e78 g     F .text	0000003c _printf_r
0004325c g     F .text	00000064 .hidden __udivsi3
000457dc g     F .text	00000090 alt_icache_flush
000478e0 g     O .rwdata	00000001 volume
00047584 g     O .rwdata	00000078 song
00040714 g     F .text	00000048 switchesRegisterISR
00047918 g     O .rwdata	00000004 alt_max_fd
000478f0 g     O .rwdata	00000006 unused_switches
00043058 g     F .text	000000ac downAlarmHour
00041930 g     F .text	00000044 check_return_code
00042c2c g     F .text	000000c8 downClockMinute
000478fc g     O .rwdata	00000004 _global_impure_ptr
00042dd4 g     F .text	00000084 getAlarmTime
00041b08 g     F .text	0000008c note2freq
00047df4 g       *ABS*	00000000 __bss_end
0004481c g     F .text	000000f0 alt_iic_isr_register
00040ec8 g     F .text	0000023c switchesISR
000447d0 g     F .text	0000004c alt_ic_irq_enabled
00047cd6 g     O .bss	00000003 alarm
0004164c g     F .text	0000004c stopPWM
00047ce0 g     O .bss	00000004 alt_irq_active
000400fc g     F .exceptions	000000d4 alt_irq_handler
00047738 g     O .rwdata	00000028 alt_dev_null
00044f88 g     F .text	00000020 alt_dcache_flush_all
00040d04 g     F .text	000001c4 timerSecondISR
00047920 g       *ABS*	00000000 __ram_rwdata_end
00042e58 g     F .text	000000a8 upAlarmMinute
00040000 g       *ABS*	00000000 __alt_mem_onchip_memory
00047910 g     O .rwdata	00000008 alt_dev_list
00044aa0 g     F .text	000000f8 write
00042cf4 g     F .text	000000ac downClockHour
00043318 g     F .text	000000bc .hidden __gtsf2
00047584 g       *ABS*	00000000 __ram_rodata_end
000408d8 g     F .text	00000030 timerPWMDisableInterrupt
00045a80 g     O .rodata	0000000b COM_ANODE_SEG_TABLE
0004291c g     F .text	000000cc upClockSecond
000432c0 g     F .text	00000058 .hidden __umodsi3
00040908 g     F .text	00000030 alarmLEDoff
00040968 g     F .text	0000004c alarmLEDtoggle
00047df4 g       *ABS*	00000000 end
00047cbc g     O .bss	00000006 mode
000401d0 g     F .exceptions	00000074 alt_instruction_exception_entry
00042fb0 g     F .text	000000a8 downAlarmMinute
00068000 g       *ABS*	00000000 __alt_stack_pointer
00043e14 g     F .text	00000064 .hidden __clzsi2
00044de8 g     F .text	00000094 altera_avalon_jtag_uart_write
0004401c g     F .text	00000524 ___vfprintf_internal_r
000458bc g     F .text	00000190 __call_exitprocs
00041a80 g     F .text	00000044 upSong
00040244 g     F .text	0000003c _start
00040280 g     F .text	00000064 altera_avalon_pwm_init
00044c04 g     F .text	00000038 alt_sys_init
000478e4 g     O .rwdata	00000004 defdur
00042780 g     F .text	0000009c checkInvalidMode
00047584 g       *ABS*	00000000 __ram_rwdata_start
00045a80 g       *ABS*	00000000 __ram_rodata_start
000478f6 g     O .rwdata	00000003 reset_clock_value
000407a4 g     F .text	00000040 switchesEnableInterrupt
000415d8 g     F .text	0000003c upVolume
00044c3c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00045738 g     F .text	000000a4 alt_get_fd
0004588c g     F .text	00000030 memcmp
00047df4 g       *ABS*	00000000 __alt_stack_base
00041e4c g     F .text	000006b8 nextSongNote
00041974 g     F .text	000000ec print_error
0004281c g     F .text	00000044 isPowerOfTwoOrZero
00045630 g     F .text	00000108 alt_find_file
00045010 g     F .text	000000a4 alt_dev_llist_insert
00042860 g     F .text	00000038 resetClockTime
00041b94 g     F .text	000002b8 initializeSong
000478ec g     O .rwdata	00000004 bpm
000402e4 g     F .text	00000054 altera_avalon_pwm_enable
0004455c g     F .text	000000b8 __sfvwrite_small_dev
00047cbc g       *ABS*	00000000 __bss_start
00040c70 g     F .text	00000094 main
000475fc g     O .rwdata	00000030 notefreq
00047cec g     O .bss	00000004 alt_envp
00044c9c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0004086c g     F .text	0000006c timerPWMEnableInterrupt
000403e0 g     F .text	00000080 resetDisplay
0004791c g     O .rwdata	00000004 alt_errno
00043164 g     F .text	00000084 .hidden __divsi3
000433d4 g     F .text	000003fc .hidden __mulsf3
00042b60 g     F .text	000000cc downClockSecond
00045a80 g       *ABS*	00000000 __flash_rodata_start
00040388 g     F .text	00000058 altera_avalon_pwm_change_duty_cycle
00044bcc g     F .text	00000038 alt_irq_init
00045518 g     F .text	00000064 alt_release_fd
0004744a g     O .rodata	00000100 .hidden __clz_tab
00043318 g     F .text	000000bc .hidden __gesf2
00047cc4 g     O .bss	00000001 song_index
00044614 g     F .text	00000058 _write_r
000429e8 g     F .text	000000c8 upClockMinute
00047900 g     O .rwdata	00000004 _impure_ptr
00047ce4 g     O .bss	00000004 alt_argc
00040020 g       .exceptions	00000000 alt_irq_entry
000406e4 g     F .text	00000030 timerSecondEnableInterrupt
00047908 g     O .rwdata	00000008 alt_fs_list
00042504 g     F .text	0000027c determineMode
00040338 g     F .text	00000050 altera_avalon_pwm_disable
00040020 g       *ABS*	00000000 __ram_exceptions_start
0004466c g     F .text	00000050 alt_ic_isr_register
00047920 g       *ABS*	00000000 _edata
00047df4 g       *ABS*	00000000 _end
00040244 g       *ABS*	00000000 __ram_exceptions_end
000407e4 g     F .text	00000040 buttonsEnableInterrupt
00044744 g     F .text	0000008c alt_ic_irq_disable
0004586c g     F .text	00000020 exit
00043d24 g     F .text	000000f0 .hidden __floatunsisf
00040c40 g     F .text	00000030 LEDPianoOff
000431e8 g     F .text	00000074 .hidden __modsi3
00068000 g       *ABS*	00000000 __alt_data_end
00040020 g     F .exceptions	00000000 alt_exception
0004069c g     F .text	00000048 timerSecondRegisterISR
00042f00 g     F .text	000000b0 upAlarmHour
00043104 g     F .text	00000060 .hidden __fixunssfsi
00045a4c g     F .text	00000034 _exit
00041ac4 g     F .text	00000044 downSong
00043f94 g     F .text	0000001c strlen
000453c4 g     F .text	00000154 open
00047cd9 g     O .bss	00000003 clock
000473ea g     O .rodata	00000060 mode_lookup_table
000450b4 g     F .text	00000034 alt_icache_flush_all
00041104 g     F .text	000003ec buttonsISR
00047904 g     O .rwdata	00000004 alt_priority_mask
00045af4 g     O .rodata	00000034 duty_cycle_lookup_table
000446bc g     F .text	00000088 alt_ic_irq_enable
00044540 g     F .text	0000001c __vfprintf_internal
00044eb8 g     F .text	000000d0 close
00041804 g     F .text	0000012c testPWM
000478e8 g     O .rwdata	00000004 defscale
000415b8 g     F .text	00000020 getVolume
00047cc8 g     O .bss	00000004 silence
00042da0 g     F .text	00000034 resetAlarmTime
00044974 g     F .text	00000084 alt_load
00040460 g     F .text	0000023c updateDisplay
0004177c g     F .text	00000088 default500HzSquareWave



Disassembly of section .entry:

00040000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   40000:	00820014 	movui	r2,2048
#endif

0:
    initi r2
   40004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   40008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   4000c:	00bffd16 	blt	zero,r2,40004 <__alt_data_end+0xfffd8004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   40010:	00400134 	movhi	at,4
    ori r1, r1, %lo(_start)
   40014:	08409114 	ori	at,at,580
    jmp r1
   40018:	0800683a 	jmp	at
   4001c:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>

Disassembly of section .exceptions:

00040020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   40020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   40024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   40028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   4002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   40030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   40034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   40038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   4003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   40040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   40044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   40048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   4004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   40050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   40054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   40058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   4005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   40060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   40064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   40068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   4006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   40070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   40074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   40078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   4007c:	10000326 	beq	r2,zero,4008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   40080:	20000226 	beq	r4,zero,4008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   40084:	00400fc0 	call	400fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   40088:	00000706 	br	400a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   4008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   40090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
   40094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
   40098:	00401d00 	call	401d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
   4009c:	1000021e 	bne	r2,zero,400a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
   400a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   400a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   400a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   400ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   400b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   400b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   400b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   400bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   400c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   400c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   400c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   400cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   400d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   400d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   400d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   400dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   400e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   400e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   400e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   400ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   400f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   400f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   400f8:	ef80083a 	eret

000400fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   400fc:	defff904 	addi	sp,sp,-28
   40100:	dfc00615 	stw	ra,24(sp)
   40104:	df000515 	stw	fp,20(sp)
   40108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   4010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   40110:	0005313a 	rdctl	r2,ipending
   40114:	e0bffe15 	stw	r2,-8(fp)

  return active;
   40118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   4011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
   40120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   40124:	00800044 	movi	r2,1
   40128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   4012c:	e0fffb17 	ldw	r3,-20(fp)
   40130:	e0bffc17 	ldw	r2,-16(fp)
   40134:	1884703a 	and	r2,r3,r2
   40138:	10001426 	beq	r2,zero,4018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   4013c:	00800134 	movhi	r2,4
   40140:	109f3d04 	addi	r2,r2,31988
   40144:	e0fffd17 	ldw	r3,-12(fp)
   40148:	180690fa 	slli	r3,r3,3
   4014c:	10c5883a 	add	r2,r2,r3
   40150:	10c00017 	ldw	r3,0(r2)
   40154:	00800134 	movhi	r2,4
   40158:	109f3d04 	addi	r2,r2,31988
   4015c:	e13ffd17 	ldw	r4,-12(fp)
   40160:	200890fa 	slli	r4,r4,3
   40164:	1105883a 	add	r2,r2,r4
   40168:	10800104 	addi	r2,r2,4
   4016c:	10800017 	ldw	r2,0(r2)
   40170:	1009883a 	mov	r4,r2
   40174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
   40178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   4017c:	0005313a 	rdctl	r2,ipending
   40180:	e0bfff15 	stw	r2,-4(fp)

  return active;
   40184:	e0bfff17 	ldw	r2,-4(fp)
   40188:	00000706 	br	401a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
   4018c:	e0bffc17 	ldw	r2,-16(fp)
   40190:	1085883a 	add	r2,r2,r2
   40194:	e0bffc15 	stw	r2,-16(fp)
      i++;
   40198:	e0bffd17 	ldw	r2,-12(fp)
   4019c:	10800044 	addi	r2,r2,1
   401a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   401a4:	003fe106 	br	4012c <__alt_data_end+0xfffd812c>

    active = alt_irq_pending ();
   401a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
   401ac:	e0bffb17 	ldw	r2,-20(fp)
   401b0:	103fdb1e 	bne	r2,zero,40120 <__alt_data_end+0xfffd8120>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   401b4:	0001883a 	nop
}
   401b8:	0001883a 	nop
   401bc:	e037883a 	mov	sp,fp
   401c0:	dfc00117 	ldw	ra,4(sp)
   401c4:	df000017 	ldw	fp,0(sp)
   401c8:	dec00204 	addi	sp,sp,8
   401cc:	f800283a 	ret

000401d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
   401d0:	defffb04 	addi	sp,sp,-20
   401d4:	dfc00415 	stw	ra,16(sp)
   401d8:	df000315 	stw	fp,12(sp)
   401dc:	df000304 	addi	fp,sp,12
   401e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
   401e4:	000531fa 	rdctl	r2,exception
   401e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
   401ec:	e0bffd17 	ldw	r2,-12(fp)
   401f0:	10801f0c 	andi	r2,r2,124
   401f4:	1004d0ba 	srli	r2,r2,2
   401f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
   401fc:	0005333a 	rdctl	r2,badaddr
   40200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   40204:	d0a10417 	ldw	r2,-31728(gp)
   40208:	10000726 	beq	r2,zero,40228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   4020c:	d0a10417 	ldw	r2,-31728(gp)
   40210:	e0fffd17 	ldw	r3,-12(fp)
   40214:	e1bffe17 	ldw	r6,-8(fp)
   40218:	e17fff17 	ldw	r5,-4(fp)
   4021c:	1809883a 	mov	r4,r3
   40220:	103ee83a 	callr	r2
   40224:	00000206 	br	40230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   40228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
   4022c:	0005883a 	mov	r2,zero
}
   40230:	e037883a 	mov	sp,fp
   40234:	dfc00117 	ldw	ra,4(sp)
   40238:	df000017 	ldw	fp,0(sp)
   4023c:	dec00204 	addi	sp,sp,8
   40240:	f800283a 	ret

Disassembly of section .text:

00040244 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   40244:	06c001b4 	movhi	sp,6
    ori sp, sp, %lo(__alt_stack_pointer)
   40248:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
   4024c:	06800134 	movhi	gp,4
    ori gp, gp, %lo(_gp)
   40250:	d6be3814 	ori	gp,gp,63712
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   40254:	00800134 	movhi	r2,4
    ori r2, r2, %lo(__bss_start)
   40258:	109f2f14 	ori	r2,r2,31932

    movhi r3, %hi(__bss_end)
   4025c:	00c00134 	movhi	r3,4
    ori r3, r3, %lo(__bss_end)
   40260:	18df7d14 	ori	r3,r3,32244

    beq r2, r3, 1f
   40264:	10c00326 	beq	r2,r3,40274 <_start+0x30>

0:
    stw zero, (r2)
   40268:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   4026c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   40270:	10fffd36 	bltu	r2,r3,40268 <__alt_data_end+0xfffd8268>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   40274:	00449740 	call	44974 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   40278:	00449f80 	call	449f8 <alt_main>

0004027c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   4027c:	003fff06 	br	4027c <__alt_data_end+0xfffd827c>

00040280 <altera_avalon_pwm_init>:

#include "altera_avalon_pwm_routines.h"


int altera_avalon_pwm_init(unsigned int address, unsigned int clock_divider, unsigned int duty_cycle)
{
   40280:	defffc04 	addi	sp,sp,-16
   40284:	df000315 	stw	fp,12(sp)
   40288:	df000304 	addi	fp,sp,12
   4028c:	e13ffd15 	stw	r4,-12(fp)
   40290:	e17ffe15 	stw	r5,-8(fp)
   40294:	e1bfff15 	stw	r6,-4(fp)
	if(duty_cycle > clock_divider)  //duty cycle reg must be less than or equal to clock divider
   40298:	e0bfff17 	ldw	r2,-4(fp)
   4029c:	e0fffe17 	ldw	r3,-8(fp)
   402a0:	1880022e 	bgeu	r3,r2,402ac <altera_avalon_pwm_init+0x2c>
	{
		return ALTERA_AVALON_PWM_DUTY_CYCLE_GREATER_THAN_CLOCK_CYCLE_ERROR;
   402a4:	00bfffc4 	movi	r2,-1
   402a8:	00000a06 	br	402d4 <altera_avalon_pwm_init+0x54>
	}
	else
	{
		IOWR_ALTERA_AVALON_PWM_CLOCK_DIVIDER(address, clock_divider - 1);
   402ac:	e0bffd17 	ldw	r2,-12(fp)
   402b0:	e0fffe17 	ldw	r3,-8(fp)
   402b4:	18ffffc4 	addi	r3,r3,-1
   402b8:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_PWM_DUTY_CYCLE(address, duty_cycle);
   402bc:	e0bffd17 	ldw	r2,-12(fp)
   402c0:	10800104 	addi	r2,r2,4
   402c4:	1007883a 	mov	r3,r2
   402c8:	e0bfff17 	ldw	r2,-4(fp)
   402cc:	18800035 	stwio	r2,0(r3)
	}
	 return ALTERA_AVALON_PWM_OK;
   402d0:	0005883a 	mov	r2,zero
}
   402d4:	e037883a 	mov	sp,fp
   402d8:	df000017 	ldw	fp,0(sp)
   402dc:	dec00104 	addi	sp,sp,4
   402e0:	f800283a 	ret

000402e4 <altera_avalon_pwm_enable>:

int altera_avalon_pwm_enable(unsigned int address)
{
   402e4:	defffe04 	addi	sp,sp,-8
   402e8:	df000115 	stw	fp,4(sp)
   402ec:	df000104 	addi	fp,sp,4
   402f0:	e13fff15 	stw	r4,-4(fp)
  IOWR_ALTERA_AVALON_PWM_ENABLE(address, ALTERA_AVALON_PWM_ENABLE_MSK);
   402f4:	e0bfff17 	ldw	r2,-4(fp)
   402f8:	10800204 	addi	r2,r2,8
   402fc:	1007883a 	mov	r3,r2
   40300:	00800044 	movi	r2,1
   40304:	18800035 	stwio	r2,0(r3)
  
  if(IORD_ALTERA_AVALON_PWM_ENABLE(address) != ALTERA_AVALON_PWM_ENABLED) //Confirm PWM is enabled
   40308:	e0bfff17 	ldw	r2,-4(fp)
   4030c:	10800204 	addi	r2,r2,8
   40310:	10800037 	ldwio	r2,0(r2)
   40314:	10800060 	cmpeqi	r2,r2,1
   40318:	1000021e 	bne	r2,zero,40324 <altera_avalon_pwm_enable+0x40>
  {
  	return ALTERA_AVALON_PWM_ENABLED_CONFIRMATION_ERROR;
   4031c:	00bfff84 	movi	r2,-2
   40320:	00000106 	br	40328 <altera_avalon_pwm_enable+0x44>
  }
  return ALTERA_AVALON_PWM_OK;
   40324:	0005883a 	mov	r2,zero
}
   40328:	e037883a 	mov	sp,fp
   4032c:	df000017 	ldw	fp,0(sp)
   40330:	dec00104 	addi	sp,sp,4
   40334:	f800283a 	ret

00040338 <altera_avalon_pwm_disable>:

int altera_avalon_pwm_disable(unsigned int address)
{
   40338:	defffe04 	addi	sp,sp,-8
   4033c:	df000115 	stw	fp,4(sp)
   40340:	df000104 	addi	fp,sp,4
   40344:	e13fff15 	stw	r4,-4(fp)
  IOWR_ALTERA_AVALON_PWM_ENABLE(address, ~ALTERA_AVALON_PWM_ENABLE_MSK);
   40348:	e0bfff17 	ldw	r2,-4(fp)
   4034c:	10800204 	addi	r2,r2,8
   40350:	1007883a 	mov	r3,r2
   40354:	00bfff84 	movi	r2,-2
   40358:	18800035 	stwio	r2,0(r3)

  if(IORD_ALTERA_AVALON_PWM_ENABLE(address) != ALTERA_AVALON_PWM_DISABLED)  //Confirm PWM is disabled 
   4035c:	e0bfff17 	ldw	r2,-4(fp)
   40360:	10800204 	addi	r2,r2,8
   40364:	10800037 	ldwio	r2,0(r2)
   40368:	10000226 	beq	r2,zero,40374 <altera_avalon_pwm_disable+0x3c>
  {
  	return ALTERA_AVALON_PWM_DISABLED_CONFIRMATION_ERROR;
   4036c:	00bfff44 	movi	r2,-3
   40370:	00000106 	br	40378 <altera_avalon_pwm_disable+0x40>
  }
  return ALTERA_AVALON_PWM_OK;
   40374:	0005883a 	mov	r2,zero
}
   40378:	e037883a 	mov	sp,fp
   4037c:	df000017 	ldw	fp,0(sp)
   40380:	dec00104 	addi	sp,sp,4
   40384:	f800283a 	ret

00040388 <altera_avalon_pwm_change_duty_cycle>:


int altera_avalon_pwm_change_duty_cycle(unsigned int address, unsigned int duty_cycle)
{
   40388:	defffd04 	addi	sp,sp,-12
   4038c:	df000215 	stw	fp,8(sp)
   40390:	df000204 	addi	fp,sp,8
   40394:	e13ffe15 	stw	r4,-8(fp)
   40398:	e17fff15 	stw	r5,-4(fp)
	if(duty_cycle > IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(address))  //duty cycle reg must be less than or equal to clock divider
   4039c:	e0bffe17 	ldw	r2,-8(fp)
   403a0:	10800037 	ldwio	r2,0(r2)
   403a4:	1007883a 	mov	r3,r2
   403a8:	e0bfff17 	ldw	r2,-4(fp)
   403ac:	1880022e 	bgeu	r3,r2,403b8 <altera_avalon_pwm_change_duty_cycle+0x30>
	{
		return ALTERA_AVALON_PWM_DUTY_CYCLE_GREATER_THAN_CLOCK_CYCLE_ERROR;
   403b0:	00bfffc4 	movi	r2,-1
   403b4:	00000606 	br	403d0 <altera_avalon_pwm_change_duty_cycle+0x48>
	}
	else
	{
    IOWR_ALTERA_AVALON_PWM_DUTY_CYCLE(address, duty_cycle);
   403b8:	e0bffe17 	ldw	r2,-8(fp)
   403bc:	10800104 	addi	r2,r2,4
   403c0:	1007883a 	mov	r3,r2
   403c4:	e0bfff17 	ldw	r2,-4(fp)
   403c8:	18800035 	stwio	r2,0(r3)
	}
  return ALTERA_AVALON_PWM_OK;
   403cc:	0005883a 	mov	r2,zero
}
   403d0:	e037883a 	mov	sp,fp
   403d4:	df000017 	ldw	fp,0(sp)
   403d8:	dec00104 	addi	sp,sp,4
   403dc:	f800283a 	ret

000403e0 <resetDisplay>:
#include "display.h"

void resetDisplay(void) {
   403e0:	deffff04 	addi	sp,sp,-4
   403e4:	df000015 	stw	fp,0(sp)
   403e8:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR1_BASE, RESET_DISPLAY_VALUE);
   403ec:	00c03004 	movi	r3,192
   403f0:	00800234 	movhi	r2,8
   403f4:	10841004 	addi	r2,r2,4160
   403f8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR0_BASE, RESET_DISPLAY_VALUE);
   403fc:	00c03004 	movi	r3,192
   40400:	00800234 	movhi	r2,8
   40404:	10843004 	addi	r2,r2,4288
   40408:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE1_BASE, RESET_DISPLAY_VALUE);
   4040c:	00c03004 	movi	r3,192
   40410:	00800234 	movhi	r2,8
   40414:	10841404 	addi	r2,r2,4176
   40418:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE0_BASE, RESET_DISPLAY_VALUE);
   4041c:	00c03004 	movi	r3,192
   40420:	00800234 	movhi	r2,8
   40424:	10842c04 	addi	r2,r2,4272
   40428:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND1_BASE, RESET_DISPLAY_VALUE);
   4042c:	00c03004 	movi	r3,192
   40430:	00800234 	movhi	r2,8
   40434:	10841804 	addi	r2,r2,4192
   40438:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND0_BASE, RESET_DISPLAY_VALUE);
   4043c:	00c03004 	movi	r3,192
   40440:	00800234 	movhi	r2,8
   40444:	10842804 	addi	r2,r2,4256
   40448:	10c00035 	stwio	r3,0(r2)
}
   4044c:	0001883a 	nop
   40450:	e037883a 	mov	sp,fp
   40454:	df000017 	ldw	fp,0(sp)
   40458:	dec00104 	addi	sp,sp,4
   4045c:	f800283a 	ret

00040460 <updateDisplay>:
bcd[2] = 512/100 = 5
bcd[1] = (512-5*100)/10 = 12/10 = 1
bcd[0] = (512 - (5*100 + 1*10))/1 = 2
*/
// for the moment, this is hard coded without any for loops
void updateDisplay(struct time time) {
   40460:	defffa04 	addi	sp,sp,-24
   40464:	dfc00515 	stw	ra,20(sp)
   40468:	df000415 	stw	fp,16(sp)
   4046c:	df000404 	addi	fp,sp,16
   40470:	e13fff15 	stw	r4,-4(fp)
  /* determine BCD values for hours, minutes, seconds...
  it's possible that the particular time struct member was set to a predefined
  DIGITS_OFF value, which signifies that the display should CLEAR the associated time unit digits..
  this is a sort of hacky way to check, but for right now it's fine.*/

  if (time.hour == DONT_DISPLAY) {
   40474:	e0bfff03 	ldbu	r2,-4(fp)
   40478:	10803fcc 	andi	r2,r2,255
   4047c:	10801918 	cmpnei	r2,r2,100
   40480:	1000051e 	bne	r2,zero,40498 <updateDisplay+0x38>
    bcd[5] = DIGITS_OFF;
   40484:	00800284 	movi	r2,10
   40488:	e0bffd45 	stb	r2,-11(fp)
    bcd[4] = DIGITS_OFF;
   4048c:	00800284 	movi	r2,10
   40490:	e0bffd05 	stb	r2,-12(fp)
   40494:	00000b06 	br	404c4 <updateDisplay+0x64>
  }
  else {
    bcd[5] = time.hour/10;
   40498:	e0bfff03 	ldbu	r2,-4(fp)
   4049c:	10803fcc 	andi	r2,r2,255
   404a0:	01400284 	movi	r5,10
   404a4:	1009883a 	mov	r4,r2
   404a8:	004325c0 	call	4325c <__udivsi3>
   404ac:	e0bffd45 	stb	r2,-11(fp)
    bcd[4] = time.hour - bcd[5]*10;
   404b0:	e0bfff03 	ldbu	r2,-4(fp)
   404b4:	e0fffd43 	ldbu	r3,-11(fp)
   404b8:	18fffda4 	muli	r3,r3,-10
   404bc:	10c5883a 	add	r2,r2,r3
   404c0:	e0bffd05 	stb	r2,-12(fp)
  }
  if (time.minute == DONT_DISPLAY) {
   404c4:	e0bfff43 	ldbu	r2,-3(fp)
   404c8:	10803fcc 	andi	r2,r2,255
   404cc:	10801918 	cmpnei	r2,r2,100
   404d0:	1000051e 	bne	r2,zero,404e8 <updateDisplay+0x88>
    bcd[3] = DIGITS_OFF;
   404d4:	00800284 	movi	r2,10
   404d8:	e0bffcc5 	stb	r2,-13(fp)
    bcd[2] = DIGITS_OFF;
   404dc:	00800284 	movi	r2,10
   404e0:	e0bffc85 	stb	r2,-14(fp)
   404e4:	00000b06 	br	40514 <updateDisplay+0xb4>
  }
  else {
    bcd[3] = time.minute/10;
   404e8:	e0bfff43 	ldbu	r2,-3(fp)
   404ec:	10803fcc 	andi	r2,r2,255
   404f0:	01400284 	movi	r5,10
   404f4:	1009883a 	mov	r4,r2
   404f8:	004325c0 	call	4325c <__udivsi3>
   404fc:	e0bffcc5 	stb	r2,-13(fp)
    bcd[2] = time.minute - bcd[3]*10;
   40500:	e0bfff43 	ldbu	r2,-3(fp)
   40504:	e0fffcc3 	ldbu	r3,-13(fp)
   40508:	18fffda4 	muli	r3,r3,-10
   4050c:	10c5883a 	add	r2,r2,r3
   40510:	e0bffc85 	stb	r2,-14(fp)
  }

  if (time.second == DONT_DISPLAY) {
   40514:	e0bfff83 	ldbu	r2,-2(fp)
   40518:	10803fcc 	andi	r2,r2,255
   4051c:	10801918 	cmpnei	r2,r2,100
   40520:	1000051e 	bne	r2,zero,40538 <updateDisplay+0xd8>
    bcd[1] = DIGITS_OFF;
   40524:	00800284 	movi	r2,10
   40528:	e0bffc45 	stb	r2,-15(fp)
    bcd[0] = DIGITS_OFF;
   4052c:	00800284 	movi	r2,10
   40530:	e0bffc05 	stb	r2,-16(fp)
   40534:	00000b06 	br	40564 <updateDisplay+0x104>
  }

  else {
    bcd[1] = time.second/10;
   40538:	e0bfff83 	ldbu	r2,-2(fp)
   4053c:	10803fcc 	andi	r2,r2,255
   40540:	01400284 	movi	r5,10
   40544:	1009883a 	mov	r4,r2
   40548:	004325c0 	call	4325c <__udivsi3>
   4054c:	e0bffc45 	stb	r2,-15(fp)
    bcd[0] = time.second - bcd[1]*10;
   40550:	e0bfff83 	ldbu	r2,-2(fp)
   40554:	e0fffc43 	ldbu	r3,-15(fp)
   40558:	18fffda4 	muli	r3,r3,-10
   4055c:	10c5883a 	add	r2,r2,r3
   40560:	e0bffc05 	stb	r2,-16(fp)
  }

  // convert BCD values to LED segment values
  ledseg[5] = COM_ANODE_SEG_TABLE[(bcd[5])];
   40564:	e0bffd43 	ldbu	r2,-11(fp)
   40568:	10c03fcc 	andi	r3,r2,255
   4056c:	00800134 	movhi	r2,4
   40570:	1096a004 	addi	r2,r2,23168
   40574:	10c5883a 	add	r2,r2,r3
   40578:	10800003 	ldbu	r2,0(r2)
   4057c:	e0bffec5 	stb	r2,-5(fp)
  ledseg[4] = COM_ANODE_SEG_TABLE[(bcd[4])];
   40580:	e0bffd03 	ldbu	r2,-12(fp)
   40584:	10c03fcc 	andi	r3,r2,255
   40588:	00800134 	movhi	r2,4
   4058c:	1096a004 	addi	r2,r2,23168
   40590:	10c5883a 	add	r2,r2,r3
   40594:	10800003 	ldbu	r2,0(r2)
   40598:	e0bffe85 	stb	r2,-6(fp)
  ledseg[3] = COM_ANODE_SEG_TABLE[(bcd[3])];
   4059c:	e0bffcc3 	ldbu	r2,-13(fp)
   405a0:	10c03fcc 	andi	r3,r2,255
   405a4:	00800134 	movhi	r2,4
   405a8:	1096a004 	addi	r2,r2,23168
   405ac:	10c5883a 	add	r2,r2,r3
   405b0:	10800003 	ldbu	r2,0(r2)
   405b4:	e0bffe45 	stb	r2,-7(fp)
  ledseg[2] = COM_ANODE_SEG_TABLE[(bcd[2])];
   405b8:	e0bffc83 	ldbu	r2,-14(fp)
   405bc:	10c03fcc 	andi	r3,r2,255
   405c0:	00800134 	movhi	r2,4
   405c4:	1096a004 	addi	r2,r2,23168
   405c8:	10c5883a 	add	r2,r2,r3
   405cc:	10800003 	ldbu	r2,0(r2)
   405d0:	e0bffe05 	stb	r2,-8(fp)
  ledseg[1] = COM_ANODE_SEG_TABLE[(bcd[1])];
   405d4:	e0bffc43 	ldbu	r2,-15(fp)
   405d8:	10c03fcc 	andi	r3,r2,255
   405dc:	00800134 	movhi	r2,4
   405e0:	1096a004 	addi	r2,r2,23168
   405e4:	10c5883a 	add	r2,r2,r3
   405e8:	10800003 	ldbu	r2,0(r2)
   405ec:	e0bffdc5 	stb	r2,-9(fp)
  ledseg[0] = COM_ANODE_SEG_TABLE[(bcd[0])];
   405f0:	e0bffc03 	ldbu	r2,-16(fp)
   405f4:	10c03fcc 	andi	r3,r2,255
   405f8:	00800134 	movhi	r2,4
   405fc:	1096a004 	addi	r2,r2,23168
   40600:	10c5883a 	add	r2,r2,r3
   40604:	10800003 	ldbu	r2,0(r2)
   40608:	e0bffd85 	stb	r2,-10(fp)

  // write to display port
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR1_BASE, ledseg[5]);
   4060c:	e0bffec3 	ldbu	r2,-5(fp)
   40610:	10c03fcc 	andi	r3,r2,255
   40614:	00800234 	movhi	r2,8
   40618:	10841004 	addi	r2,r2,4160
   4061c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR0_BASE, ledseg[4]);
   40620:	e0bffe83 	ldbu	r2,-6(fp)
   40624:	10c03fcc 	andi	r3,r2,255
   40628:	00800234 	movhi	r2,8
   4062c:	10843004 	addi	r2,r2,4288
   40630:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE1_BASE, ledseg[3]);
   40634:	e0bffe43 	ldbu	r2,-7(fp)
   40638:	10c03fcc 	andi	r3,r2,255
   4063c:	00800234 	movhi	r2,8
   40640:	10841404 	addi	r2,r2,4176
   40644:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE0_BASE, ledseg[2]);
   40648:	e0bffe03 	ldbu	r2,-8(fp)
   4064c:	10c03fcc 	andi	r3,r2,255
   40650:	00800234 	movhi	r2,8
   40654:	10842c04 	addi	r2,r2,4272
   40658:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND1_BASE, ledseg[1]);
   4065c:	e0bffdc3 	ldbu	r2,-9(fp)
   40660:	10c03fcc 	andi	r3,r2,255
   40664:	00800234 	movhi	r2,8
   40668:	10841804 	addi	r2,r2,4192
   4066c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND0_BASE, ledseg[0]);
   40670:	e0bffd83 	ldbu	r2,-10(fp)
   40674:	10c03fcc 	andi	r3,r2,255
   40678:	00800234 	movhi	r2,8
   4067c:	10842804 	addi	r2,r2,4256
   40680:	10c00035 	stwio	r3,0(r2)
   40684:	0001883a 	nop
   40688:	e037883a 	mov	sp,fp
   4068c:	dfc00117 	ldw	ra,4(sp)
   40690:	df000017 	ldw	fp,0(sp)
   40694:	dec00204 	addi	sp,sp,8
   40698:	f800283a 	ret

0004069c <timerSecondRegisterISR>:

/* this registration functions receives a pointer to an ISR function which takes
in a pointer to a data structure (isr_context) as a parameter, and does not
return any value (void). ISRFunction() will be called once the timerSecond
interrupt fires, and this ISR resides in main.c */
uint8_t timerSecondRegisterISR(void (*timerSecondISR)(void *isr_context)) {
   4069c:	defffb04 	addi	sp,sp,-20
   406a0:	dfc00415 	stw	ra,16(sp)
   406a4:	df000315 	stw	fp,12(sp)
   406a8:	df000304 	addi	fp,sp,12
   406ac:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(TIMER_SECOND_IRQ_INTERRUPT_CONTROLLER_ID,
   406b0:	d8000015 	stw	zero,0(sp)
   406b4:	000f883a 	mov	r7,zero
   406b8:	e1bfff17 	ldw	r6,-4(fp)
   406bc:	01400044 	movi	r5,1
   406c0:	0009883a 	mov	r4,zero
   406c4:	004466c0 	call	4466c <alt_ic_isr_register>
   406c8:	e0bffe05 	stb	r2,-8(fp)
                                            TIMER_SECOND_IRQ,
                                            timerSecondISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   406cc:	e0bffe03 	ldbu	r2,-8(fp)
}
   406d0:	e037883a 	mov	sp,fp
   406d4:	dfc00117 	ldw	ra,4(sp)
   406d8:	df000017 	ldw	fp,0(sp)
   406dc:	dec00204 	addi	sp,sp,8
   406e0:	f800283a 	ret

000406e4 <timerSecondEnableInterrupt>:

void timerSecondEnableInterrupt(void) {
   406e4:	deffff04 	addi	sp,sp,-4
   406e8:	df000015 	stw	fp,0(sp)
   406ec:	d839883a 	mov	fp,sp
 IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_SECOND_BASE,
   406f0:	00c001c4 	movi	r3,7
   406f4:	00800234 	movhi	r2,8
   406f8:	10840904 	addi	r2,r2,4132
   406fc:	10c00035 	stwio	r3,0(r2)
                 ALTERA_AVALON_TIMER_CONTROL_CONT_MSK  
               | ALTERA_AVALON_TIMER_CONTROL_START_MSK
               | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
}
   40700:	0001883a 	nop
   40704:	e037883a 	mov	sp,fp
   40708:	df000017 	ldw	fp,0(sp)
   4070c:	dec00104 	addi	sp,sp,4
   40710:	f800283a 	ret

00040714 <switchesRegisterISR>:

uint8_t switchesRegisterISR(void (*switchesISR)(void *isr_context)) {
   40714:	defffb04 	addi	sp,sp,-20
   40718:	dfc00415 	stw	ra,16(sp)
   4071c:	df000315 	stw	fp,12(sp)
   40720:	df000304 	addi	fp,sp,12
   40724:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(SWITCHES_IRQ_INTERRUPT_CONTROLLER_ID,
   40728:	d8000015 	stw	zero,0(sp)
   4072c:	000f883a 	mov	r7,zero
   40730:	e1bfff17 	ldw	r6,-4(fp)
   40734:	01400084 	movi	r5,2
   40738:	0009883a 	mov	r4,zero
   4073c:	004466c0 	call	4466c <alt_ic_isr_register>
   40740:	e0bffe05 	stb	r2,-8(fp)
                                            SWITCHES_IRQ,
                                            switchesISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   40744:	e0bffe03 	ldbu	r2,-8(fp)
}
   40748:	e037883a 	mov	sp,fp
   4074c:	dfc00117 	ldw	ra,4(sp)
   40750:	df000017 	ldw	fp,0(sp)
   40754:	dec00204 	addi	sp,sp,8
   40758:	f800283a 	ret

0004075c <buttonsRegisterISR>:


uint8_t buttonsRegisterISR(void (*buttonsISR)(void *isr_context)) {
   4075c:	defffb04 	addi	sp,sp,-20
   40760:	dfc00415 	stw	ra,16(sp)
   40764:	df000315 	stw	fp,12(sp)
   40768:	df000304 	addi	fp,sp,12
   4076c:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(BUTTONS_IRQ_INTERRUPT_CONTROLLER_ID,
   40770:	d8000015 	stw	zero,0(sp)
   40774:	000f883a 	mov	r7,zero
   40778:	e1bfff17 	ldw	r6,-4(fp)
   4077c:	014000c4 	movi	r5,3
   40780:	0009883a 	mov	r4,zero
   40784:	004466c0 	call	4466c <alt_ic_isr_register>
   40788:	e0bffe05 	stb	r2,-8(fp)
                                            BUTTONS_IRQ,
                                            buttonsISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   4078c:	e0bffe03 	ldbu	r2,-8(fp)
}
   40790:	e037883a 	mov	sp,fp
   40794:	dfc00117 	ldw	ra,4(sp)
   40798:	df000017 	ldw	fp,0(sp)
   4079c:	dec00204 	addi	sp,sp,8
   407a0:	f800283a 	ret

000407a4 <switchesEnableInterrupt>:


void switchesEnableInterrupt(void) {
   407a4:	deffff04 	addi	sp,sp,-4
   407a8:	df000015 	stw	fp,0(sp)
   407ac:	d839883a 	mov	fp,sp
  // enable all switches to fire interupts
  IOWR_ALTERA_AVALON_PIO_IRQ_MASK(SWITCHES_BASE, SWITCHES_INTERRUPT_MASK);
   407b0:	00ffffd4 	movui	r3,65535
   407b4:	00800234 	movhi	r2,8
   407b8:	10843a04 	addi	r2,r2,4328
   407bc:	10c00035 	stwio	r3,0(r2)
  
  // reset the edge capture register
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(SWITCHES_BASE, 0);
   407c0:	0007883a 	mov	r3,zero
   407c4:	00800234 	movhi	r2,8
   407c8:	10843b04 	addi	r2,r2,4332
   407cc:	10c00035 	stwio	r3,0(r2)
}
   407d0:	0001883a 	nop
   407d4:	e037883a 	mov	sp,fp
   407d8:	df000017 	ldw	fp,0(sp)
   407dc:	dec00104 	addi	sp,sp,4
   407e0:	f800283a 	ret

000407e4 <buttonsEnableInterrupt>:

void buttonsEnableInterrupt(void) {
   407e4:	deffff04 	addi	sp,sp,-4
   407e8:	df000015 	stw	fp,0(sp)
   407ec:	d839883a 	mov	fp,sp
  // enable all buttons to fire interupts
  IOWR_ALTERA_AVALON_PIO_IRQ_MASK(BUTTONS_BASE, BUTTONS_INTERRUPT_MASK);
   407f0:	00c000c4 	movi	r3,3
   407f4:	00800234 	movhi	r2,8
   407f8:	10841e04 	addi	r2,r2,4216
   407fc:	10c00035 	stwio	r3,0(r2)
  
  // reset the edge capture register
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   40800:	0007883a 	mov	r3,zero
   40804:	00800234 	movhi	r2,8
   40808:	10841f04 	addi	r2,r2,4220
   4080c:	10c00035 	stwio	r3,0(r2)
}
   40810:	0001883a 	nop
   40814:	e037883a 	mov	sp,fp
   40818:	df000017 	ldw	fp,0(sp)
   4081c:	dec00104 	addi	sp,sp,4
   40820:	f800283a 	ret

00040824 <timerPWMRegisterISR>:


uint8_t timerPWMRegisterISR(void (*timerPWMISR)(void *isr_context)) {
   40824:	defffb04 	addi	sp,sp,-20
   40828:	dfc00415 	stw	ra,16(sp)
   4082c:	df000315 	stw	fp,12(sp)
   40830:	df000304 	addi	fp,sp,12
   40834:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(TIMER_PWM_IRQ_INTERRUPT_CONTROLLER_ID,
   40838:	d8000015 	stw	zero,0(sp)
   4083c:	000f883a 	mov	r7,zero
   40840:	e1bfff17 	ldw	r6,-4(fp)
   40844:	01400104 	movi	r5,4
   40848:	0009883a 	mov	r4,zero
   4084c:	004466c0 	call	4466c <alt_ic_isr_register>
   40850:	e0bffe05 	stb	r2,-8(fp)
                                            TIMER_PWM_IRQ,
                                            timerPWMISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   40854:	e0bffe03 	ldbu	r2,-8(fp)
}
   40858:	e037883a 	mov	sp,fp
   4085c:	dfc00117 	ldw	ra,4(sp)
   40860:	df000017 	ldw	fp,0(sp)
   40864:	dec00204 	addi	sp,sp,8
   40868:	f800283a 	ret

0004086c <timerPWMEnableInterrupt>:

void timerPWMEnableInterrupt(int timeout) {
   4086c:	defffd04 	addi	sp,sp,-12
   40870:	df000215 	stw	fp,8(sp)
   40874:	df000204 	addi	fp,sp,8
   40878:	e13fff15 	stw	r4,-4(fp)
  // timeout is in miliseconds -> convert to seconds
  // set period based on input timeout variable; writing to the period 
  // registers stops the counter which automatically loads reigster value
  uint32_t period = (NIOS_CLOCK_FREQ/1000)*timeout;
   4087c:	e0ffff17 	ldw	r3,-4(fp)
   40880:	00b0d414 	movui	r2,50000
   40884:	1885383a 	mul	r2,r3,r2
   40888:	e0bffe15 	stw	r2,-8(fp)

  //write to high and low registers
  IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_PWM_BASE, period);
   4088c:	e0fffe17 	ldw	r3,-8(fp)
   40890:	00800234 	movhi	r2,8
   40894:	10840204 	addi	r2,r2,4104
   40898:	10c00035 	stwio	r3,0(r2)
  // shift by 16 to take into account high bits
  IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_PWM_BASE, (period >> AVALON_TIMER_PERIOD_WIDTH));
   4089c:	e0bffe17 	ldw	r2,-8(fp)
   408a0:	1004d43a 	srli	r2,r2,16
   408a4:	1007883a 	mov	r3,r2
   408a8:	00800234 	movhi	r2,8
   408ac:	10840304 	addi	r2,r2,4108
   408b0:	10c00035 	stwio	r3,0(r2)

  // start timer and enable interrupt
  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_PWM_BASE, 
   408b4:	00c00144 	movi	r3,5
   408b8:	00800234 	movhi	r2,8
   408bc:	10840104 	addi	r2,r2,4100
   408c0:	10c00035 	stwio	r3,0(r2)
                 ALTERA_AVALON_TIMER_CONTROL_START_MSK
               | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
}
   408c4:	0001883a 	nop
   408c8:	e037883a 	mov	sp,fp
   408cc:	df000017 	ldw	fp,0(sp)
   408d0:	dec00104 	addi	sp,sp,4
   408d4:	f800283a 	ret

000408d8 <timerPWMDisableInterrupt>:

void timerPWMDisableInterrupt(void) {
   408d8:	deffff04 	addi	sp,sp,-4
   408dc:	df000015 	stw	fp,0(sp)
   408e0:	d839883a 	mov	fp,sp
  // set ITO to 0 (thus disabling interrupts)
  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_PWM_BASE, 0);
   408e4:	0007883a 	mov	r3,zero
   408e8:	00800234 	movhi	r2,8
   408ec:	10840104 	addi	r2,r2,4100
   408f0:	10c00035 	stwio	r3,0(r2)
}
   408f4:	0001883a 	nop
   408f8:	e037883a 	mov	sp,fp
   408fc:	df000017 	ldw	fp,0(sp)
   40900:	dec00104 	addi	sp,sp,4
   40904:	f800283a 	ret

00040908 <alarmLEDoff>:
#include "led.h"

void alarmLEDoff(void) {
   40908:	deffff04 	addi	sp,sp,-4
   4090c:	df000015 	stw	fp,0(sp)
   40910:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, LED_OFF);
   40914:	0007883a 	mov	r3,zero
   40918:	00800234 	movhi	r2,8
   4091c:	10842404 	addi	r2,r2,4240
   40920:	10c00035 	stwio	r3,0(r2)
}
   40924:	0001883a 	nop
   40928:	e037883a 	mov	sp,fp
   4092c:	df000017 	ldw	fp,0(sp)
   40930:	dec00104 	addi	sp,sp,4
   40934:	f800283a 	ret

00040938 <alarmLEDon>:

void alarmLEDon(void) {
   40938:	deffff04 	addi	sp,sp,-4
   4093c:	df000015 	stw	fp,0(sp)
   40940:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, LED_ON);
   40944:	00c00044 	movi	r3,1
   40948:	00800234 	movhi	r2,8
   4094c:	10842404 	addi	r2,r2,4240
   40950:	10c00035 	stwio	r3,0(r2)
}
   40954:	0001883a 	nop
   40958:	e037883a 	mov	sp,fp
   4095c:	df000017 	ldw	fp,0(sp)
   40960:	dec00104 	addi	sp,sp,4
   40964:	f800283a 	ret

00040968 <alarmLEDtoggle>:

void alarmLEDtoggle(void) {
   40968:	defffe04 	addi	sp,sp,-8
   4096c:	df000115 	stw	fp,4(sp)
   40970:	df000104 	addi	fp,sp,4
  volatile uint8_t led_state;
  led_state = IORD_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE);
   40974:	00800234 	movhi	r2,8
   40978:	10842404 	addi	r2,r2,4240
   4097c:	10800037 	ldwio	r2,0(r2)
   40980:	e0bfff05 	stb	r2,-4(fp)
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, !led_state);
   40984:	e0bfff03 	ldbu	r2,-4(fp)
   40988:	10803fcc 	andi	r2,r2,255
   4098c:	1005003a 	cmpeq	r2,r2,zero
   40990:	10c03fcc 	andi	r3,r2,255
   40994:	00800234 	movhi	r2,8
   40998:	10842404 	addi	r2,r2,4240
   4099c:	10c00035 	stwio	r3,0(r2)
}
   409a0:	0001883a 	nop
   409a4:	e037883a 	mov	sp,fp
   409a8:	df000017 	ldw	fp,0(sp)
   409ac:	dec00104 	addi	sp,sp,4
   409b0:	f800283a 	ret

000409b4 <writeLEDPiano>:

void writeLEDPiano(char note) {
   409b4:	defffd04 	addi	sp,sp,-12
   409b8:	df000215 	stw	fp,8(sp)
   409bc:	df000204 	addi	fp,sp,8
   409c0:	2005883a 	mov	r2,r4
   409c4:	e0bfff05 	stb	r2,-4(fp)
  uint8_t led_piano_keys;

  switch(note) {
   409c8:	e0bfff07 	ldb	r2,-4(fp)
   409cc:	10c01c68 	cmpgeui	r3,r2,113
   409d0:	1800901e 	bne	r3,zero,40c14 <writeLEDPiano+0x260>
   409d4:	100690ba 	slli	r3,r2,2
   409d8:	00800134 	movhi	r2,4
   409dc:	10827b04 	addi	r2,r2,2540
   409e0:	1885883a 	add	r2,r3,r2
   409e4:	10800017 	ldw	r2,0(r2)
   409e8:	1000683a 	jmp	r2
   409ec:	00040bb0 	cmpltui	zero,zero,4142
   409f0:	00040c14 	movui	zero,4144
   409f4:	00040c14 	movui	zero,4144
   409f8:	00040c14 	movui	zero,4144
   409fc:	00040c14 	movui	zero,4144
   40a00:	00040c14 	movui	zero,4144
   40a04:	00040c14 	movui	zero,4144
   40a08:	00040c14 	movui	zero,4144
   40a0c:	00040c14 	movui	zero,4144
   40a10:	00040c14 	movui	zero,4144
   40a14:	00040c14 	movui	zero,4144
   40a18:	00040c14 	movui	zero,4144
   40a1c:	00040c14 	movui	zero,4144
   40a20:	00040c14 	movui	zero,4144
   40a24:	00040c14 	movui	zero,4144
   40a28:	00040c14 	movui	zero,4144
   40a2c:	00040c14 	movui	zero,4144
   40a30:	00040c14 	movui	zero,4144
   40a34:	00040c14 	movui	zero,4144
   40a38:	00040c14 	movui	zero,4144
   40a3c:	00040c14 	movui	zero,4144
   40a40:	00040c14 	movui	zero,4144
   40a44:	00040c14 	movui	zero,4144
   40a48:	00040c14 	movui	zero,4144
   40a4c:	00040c14 	movui	zero,4144
   40a50:	00040c14 	movui	zero,4144
   40a54:	00040c14 	movui	zero,4144
   40a58:	00040c14 	movui	zero,4144
   40a5c:	00040c14 	movui	zero,4144
   40a60:	00040c14 	movui	zero,4144
   40a64:	00040c14 	movui	zero,4144
   40a68:	00040c14 	movui	zero,4144
   40a6c:	00040c14 	movui	zero,4144
   40a70:	00040c14 	movui	zero,4144
   40a74:	00040c14 	movui	zero,4144
   40a78:	00040c14 	movui	zero,4144
   40a7c:	00040c14 	movui	zero,4144
   40a80:	00040c14 	movui	zero,4144
   40a84:	00040c14 	movui	zero,4144
   40a88:	00040c14 	movui	zero,4144
   40a8c:	00040c14 	movui	zero,4144
   40a90:	00040c14 	movui	zero,4144
   40a94:	00040c14 	movui	zero,4144
   40a98:	00040c14 	movui	zero,4144
   40a9c:	00040c14 	movui	zero,4144
   40aa0:	00040c14 	movui	zero,4144
   40aa4:	00040c14 	movui	zero,4144
   40aa8:	00040c14 	movui	zero,4144
   40aac:	00040c14 	movui	zero,4144
   40ab0:	00040c14 	movui	zero,4144
   40ab4:	00040c14 	movui	zero,4144
   40ab8:	00040c14 	movui	zero,4144
   40abc:	00040c14 	movui	zero,4144
   40ac0:	00040c14 	movui	zero,4144
   40ac4:	00040c14 	movui	zero,4144
   40ac8:	00040c14 	movui	zero,4144
   40acc:	00040c14 	movui	zero,4144
   40ad0:	00040c14 	movui	zero,4144
   40ad4:	00040c14 	movui	zero,4144
   40ad8:	00040c14 	movui	zero,4144
   40adc:	00040c14 	movui	zero,4144
   40ae0:	00040c14 	movui	zero,4144
   40ae4:	00040c14 	movui	zero,4144
   40ae8:	00040c14 	movui	zero,4144
   40aec:	00040c14 	movui	zero,4144
   40af0:	00040bc4 	movi	zero,4143
   40af4:	00040bd0 	cmplti	zero,zero,4143
   40af8:	00040bdc 	xori	zero,zero,4143
   40afc:	00040be8 	cmpgeui	zero,zero,4143
   40b00:	00040bf4 	movhi	zero,4143
   40b04:	00040c00 	call	40c0 <__alt_mem_onchip_memory-0x3bf40>
   40b08:	00040bb8 	rdprs	zero,zero,4142
   40b0c:	00040c14 	movui	zero,4144
   40b10:	00040c14 	movui	zero,4144
   40b14:	00040c14 	movui	zero,4144
   40b18:	00040c14 	movui	zero,4144
   40b1c:	00040c14 	movui	zero,4144
   40b20:	00040c14 	movui	zero,4144
   40b24:	00040c14 	movui	zero,4144
   40b28:	00040c14 	movui	zero,4144
   40b2c:	00040c0c 	andi	zero,zero,4144
   40b30:	00040c14 	movui	zero,4144
   40b34:	00040c14 	movui	zero,4144
   40b38:	00040c14 	movui	zero,4144
   40b3c:	00040c14 	movui	zero,4144
   40b40:	00040c14 	movui	zero,4144
   40b44:	00040c14 	movui	zero,4144
   40b48:	00040c14 	movui	zero,4144
   40b4c:	00040c14 	movui	zero,4144
   40b50:	00040c14 	movui	zero,4144
   40b54:	00040c14 	movui	zero,4144
   40b58:	00040c14 	movui	zero,4144
   40b5c:	00040c14 	movui	zero,4144
   40b60:	00040c14 	movui	zero,4144
   40b64:	00040c14 	movui	zero,4144
   40b68:	00040c14 	movui	zero,4144
   40b6c:	00040c14 	movui	zero,4144
   40b70:	00040bc4 	movi	zero,4143
   40b74:	00040bd0 	cmplti	zero,zero,4143
   40b78:	00040bdc 	xori	zero,zero,4143
   40b7c:	00040be8 	cmpgeui	zero,zero,4143
   40b80:	00040bf4 	movhi	zero,4143
   40b84:	00040c00 	call	40c0 <__alt_mem_onchip_memory-0x3bf40>
   40b88:	00040bb8 	rdprs	zero,zero,4142
   40b8c:	00040c14 	movui	zero,4144
   40b90:	00040c14 	movui	zero,4144
   40b94:	00040c14 	movui	zero,4144
   40b98:	00040c14 	movui	zero,4144
   40b9c:	00040c14 	movui	zero,4144
   40ba0:	00040c14 	movui	zero,4144
   40ba4:	00040c14 	movui	zero,4144
   40ba8:	00040c14 	movui	zero,4144
   40bac:	00040c0c 	andi	zero,zero,4144
    case 0: led_piano_keys = 0b0000000; break;
   40bb0:	e03ffe05 	stb	zero,-8(fp)
   40bb4:	00001906 	br	40c1c <writeLEDPiano+0x268>
    case 'G': case 'g': led_piano_keys = 0b1000000; break;
   40bb8:	00801004 	movi	r2,64
   40bbc:	e0bffe05 	stb	r2,-8(fp)
   40bc0:	00001606 	br	40c1c <writeLEDPiano+0x268>
    case 'A': case 'a': led_piano_keys = 0b0100000; break;
   40bc4:	00800804 	movi	r2,32
   40bc8:	e0bffe05 	stb	r2,-8(fp)
   40bcc:	00001306 	br	40c1c <writeLEDPiano+0x268>
    case 'B': case 'b': led_piano_keys = 0b0010000; break;
   40bd0:	00800404 	movi	r2,16
   40bd4:	e0bffe05 	stb	r2,-8(fp)
   40bd8:	00001006 	br	40c1c <writeLEDPiano+0x268>
    case 'C': case 'c': led_piano_keys = 0b0001000; break;
   40bdc:	00800204 	movi	r2,8
   40be0:	e0bffe05 	stb	r2,-8(fp)
   40be4:	00000d06 	br	40c1c <writeLEDPiano+0x268>
    case 'D': case 'd': led_piano_keys = 0b0000100; break;
   40be8:	00800104 	movi	r2,4
   40bec:	e0bffe05 	stb	r2,-8(fp)
   40bf0:	00000a06 	br	40c1c <writeLEDPiano+0x268>
    case 'E': case 'e': led_piano_keys = 0b0000010; break;
   40bf4:	00800084 	movi	r2,2
   40bf8:	e0bffe05 	stb	r2,-8(fp)
   40bfc:	00000706 	br	40c1c <writeLEDPiano+0x268>
    case 'F': case 'f': led_piano_keys = 0b0000001; break;
   40c00:	00800044 	movi	r2,1
   40c04:	e0bffe05 	stb	r2,-8(fp)
   40c08:	00000406 	br	40c1c <writeLEDPiano+0x268>
    case 'P': case 'p': led_piano_keys = 0b0000000; break;
   40c0c:	e03ffe05 	stb	zero,-8(fp)
   40c10:	00000206 	br	40c1c <writeLEDPiano+0x268>
    default: led_piano_keys = 0b0000000; break;
   40c14:	e03ffe05 	stb	zero,-8(fp)
   40c18:	0001883a 	nop
  }

  IOWR_ALTERA_AVALON_PIO_DATA(LED_PIANO_BASE, led_piano_keys);
   40c1c:	e0fffe03 	ldbu	r3,-8(fp)
   40c20:	00800234 	movhi	r2,8
   40c24:	10843404 	addi	r2,r2,4304
   40c28:	10c00035 	stwio	r3,0(r2)
}
   40c2c:	0001883a 	nop
   40c30:	e037883a 	mov	sp,fp
   40c34:	df000017 	ldw	fp,0(sp)
   40c38:	dec00104 	addi	sp,sp,4
   40c3c:	f800283a 	ret

00040c40 <LEDPianoOff>:

void LEDPianoOff(void) {
   40c40:	deffff04 	addi	sp,sp,-4
   40c44:	df000015 	stw	fp,0(sp)
   40c48:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(LED_PIANO_BASE, 0b0000000);
   40c4c:	0007883a 	mov	r3,zero
   40c50:	00800234 	movhi	r2,8
   40c54:	10843404 	addi	r2,r2,4304
   40c58:	10c00035 	stwio	r3,0(r2)
   40c5c:	0001883a 	nop
   40c60:	e037883a 	mov	sp,fp
   40c64:	df000017 	ldw	fp,0(sp)
   40c68:	dec00104 	addi	sp,sp,4
   40c6c:	f800283a 	ret

00040c70 <main>:
/* the mode struct is global so that the callback functions 
in main.c can access it and determine the appropiate courses
of action */
struct mode mode;

int main(void) {
   40c70:	defffe04 	addi	sp,sp,-8
   40c74:	dfc00115 	stw	ra,4(sp)
   40c78:	df000015 	stw	fp,0(sp)
   40c7c:	d839883a 	mov	fp,sp

  // modde initialization: free running clock mode
  mode.invalid = FALSE;
   40c80:	d020f705 	stb	zero,-31780(gp)
  mode.display = DISP_CLOCK;
   40c84:	d020f745 	stb	zero,-31779(gp)
  mode.alarm = OFF;
   40c88:	d020f785 	stb	zero,-31778(gp)
  mode.config.on = FALSE;
   40c8c:	d020f7c5 	stb	zero,-31777(gp)
  mode.config.hour = FALSE;
   40c90:	d020f805 	stb	zero,-31776(gp)
  mode.config.minute = FALSE;
   40c94:	d020f845 	stb	zero,-31775(gp)

  // module intialization
  alarmLEDoff();
   40c98:	00409080 	call	40908 <alarmLEDoff>
  LEDPianoOff();
   40c9c:	0040c400 	call	40c40 <LEDPianoOff>
  resetClockTime();
   40ca0:	00428600 	call	42860 <resetClockTime>
  resetAlarmTime();
   40ca4:	0042da00 	call	42da0 <resetAlarmTime>
  resetDisplay();
   40ca8:	00403e00 	call	403e0 <resetDisplay>

  // ISR registration
  if (timerSecondRegisterISR(&timerSecondISR) == ISR_REGISTRATION_SUCCESS) {
   40cac:	01000134 	movhi	r4,4
   40cb0:	21034104 	addi	r4,r4,3332
   40cb4:	004069c0 	call	4069c <timerSecondRegisterISR>
   40cb8:	10803fcc 	andi	r2,r2,255
   40cbc:	1000011e 	bne	r2,zero,40cc4 <main+0x54>
    //printf("timerSecondISR successively registered!\n");
    timerSecondEnableInterrupt();
   40cc0:	00406e40 	call	406e4 <timerSecondEnableInterrupt>
  }
  else {
   //printf("ERROR: timerSecondISR unsuccessively registered!\n");
  }

  if (switchesRegisterISR(&switchesISR) == ISR_REGISTRATION_SUCCESS) {
   40cc4:	01000134 	movhi	r4,4
   40cc8:	2103b204 	addi	r4,r4,3784
   40ccc:	00407140 	call	40714 <switchesRegisterISR>
   40cd0:	10803fcc 	andi	r2,r2,255
   40cd4:	1000011e 	bne	r2,zero,40cdc <main+0x6c>
    //printf("switchesISR successively registered!\n");
    switchesEnableInterrupt();
   40cd8:	00407a40 	call	407a4 <switchesEnableInterrupt>
  }
  else {
   //printf("ERROR: switchesISR unsuccessively registered!\n");
  }

  if (buttonsRegisterISR(&buttonsISR) == ISR_REGISTRATION_SUCCESS) {
   40cdc:	01000134 	movhi	r4,4
   40ce0:	21044104 	addi	r4,r4,4356
   40ce4:	004075c0 	call	4075c <buttonsRegisterISR>
   40ce8:	10803fcc 	andi	r2,r2,255
   40cec:	1000011e 	bne	r2,zero,40cf4 <main+0x84>
    //printf("buttonsISR successively registered!\n");
    buttonsEnableInterrupt();
   40cf0:	00407e40 	call	407e4 <buttonsEnableInterrupt>
  }
  else {
   //printf("ERROR: buttonsISR unsuccessively registered!\n");
  }

  if (timerPWMRegisterISR(&timerPWMISR) == ISR_REGISTRATION_SUCCESS) {
   40cf4:	01000134 	movhi	r4,4
   40cf8:	21053c04 	addi	r4,r4,5360
   40cfc:	00408240 	call	40824 <timerPWMRegisterISR>
  }
  else {
   //printf("ERROR: timerPWMISR unsuccessively registered!\n");
  }

  while(1) {}  
   40d00:	003fff06 	br	40d00 <__alt_data_end+0xfffd8d00>

00040d04 <timerSecondISR>:

// -------------- ISR callbacks -------------------

/* ISR: update the time of the clock and depending on whether or not the user
is in config mode, carry the time digits. */
void timerSecondISR(void* isr_context) {
   40d04:	defff704 	addi	sp,sp,-36
   40d08:	dfc00815 	stw	ra,32(sp)
   40d0c:	df000715 	stw	fp,28(sp)
   40d10:	df000704 	addi	fp,sp,28
   40d14:	e13fff15 	stw	r4,-4(fp)

  // clear timeout bit because the internal counter for the timer reached zero
  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_SECOND_BASE, 0);
   40d18:	0007883a 	mov	r3,zero
   40d1c:	00800234 	movhi	r2,8
   40d20:	10840804 	addi	r2,r2,4128
   40d24:	10c00035 	stwio	r3,0(r2)

  // temporary time struct for data transfer between modules and for //printf debugging
  struct time clock;
 
  if (mode.display == DISP_CLOCK) {
   40d28:	d0a0f743 	ldbu	r2,-31779(gp)
   40d2c:	10803fcc 	andi	r2,r2,255
   40d30:	1000521e 	bne	r2,zero,40e7c <timerSecondISR+0x178>
    if (mode.config.on == TRUE) {
   40d34:	d0a0f7c3 	ldbu	r2,-31777(gp)
   40d38:	10803fcc 	andi	r2,r2,255
   40d3c:	10800058 	cmpnei	r2,r2,1
   40d40:	10000e1e 	bne	r2,zero,40d7c <timerSecondISR+0x78>

      // digits should not carry over while configuring the time
      clock = upClockSecond(CARRY_OFF);
   40d44:	0009883a 	mov	r4,zero
   40d48:	004291c0 	call	4291c <upClockSecond>
   40d4c:	e0bff905 	stb	r2,-28(fp)
   40d50:	1006d23a 	srli	r3,r2,8
   40d54:	1809883a 	mov	r4,r3
   40d58:	00ffffc4 	movi	r3,-1
   40d5c:	20c6703a 	and	r3,r4,r3
   40d60:	e0fff945 	stb	r3,-27(fp)
   40d64:	1004d43a 	srli	r2,r2,16
   40d68:	1007883a 	mov	r3,r2
   40d6c:	00bfffc4 	movi	r2,-1
   40d70:	1884703a 	and	r2,r3,r2
   40d74:	e0bff985 	stb	r2,-26(fp)
   40d78:	00003d06 	br	40e70 <timerSecondISR+0x16c>

    }
    else if (mode.config.on == FALSE) {
   40d7c:	d0a0f7c3 	ldbu	r2,-31777(gp)
   40d80:	10803fcc 	andi	r2,r2,255
   40d84:	10003a1e 	bne	r2,zero,40e70 <timerSecondISR+0x16c>

      // since we're not in config mode, the time 
      // should normally count and carry.
      clock = upClockSecond(CARRY_ON);
   40d88:	01000044 	movi	r4,1
   40d8c:	004291c0 	call	4291c <upClockSecond>
   40d90:	e0bff905 	stb	r2,-28(fp)
   40d94:	1006d23a 	srli	r3,r2,8
   40d98:	1809883a 	mov	r4,r3
   40d9c:	00ffffc4 	movi	r3,-1
   40da0:	20c6703a 	and	r3,r4,r3
   40da4:	e0fff945 	stb	r3,-27(fp)
   40da8:	1004d43a 	srli	r2,r2,16
   40dac:	1007883a 	mov	r3,r2
   40db0:	00bfffc4 	movi	r2,-1
   40db4:	1884703a 	and	r2,r3,r2
   40db8:	e0bff985 	stb	r2,-26(fp)

      // check the alarm
      if (mode.alarm == ON) {
   40dbc:	d0a0f783 	ldbu	r2,-31778(gp)
   40dc0:	10803fcc 	andi	r2,r2,255
   40dc4:	10800058 	cmpnei	r2,r2,1
   40dc8:	1000291e 	bne	r2,zero,40e70 <timerSecondISR+0x16c>

        struct time alarm;
        alarm = getAlarmTime();
   40dcc:	0042dd40 	call	42dd4 <getAlarmTime>
   40dd0:	e0bff9c5 	stb	r2,-25(fp)
   40dd4:	1006d23a 	srli	r3,r2,8
   40dd8:	1809883a 	mov	r4,r3
   40ddc:	00ffffc4 	movi	r3,-1
   40de0:	20c6703a 	and	r3,r4,r3
   40de4:	e0fffa05 	stb	r3,-24(fp)
   40de8:	1004d43a 	srli	r2,r2,16
   40dec:	1007883a 	mov	r3,r2
   40df0:	00bfffc4 	movi	r2,-1
   40df4:	1884703a 	and	r2,r3,r2
   40df8:	e0bffa45 	stb	r2,-23(fp)

        /* to avoid executing the following block of code everytime and to only call initializeSong() once, 
        we have to check whether or not the time is currently at XX:XX:00. 
        --> at 0 seconds, thats when the alarm will be activated */
        if ( (clock.second == 0) && (alarm.hour == clock.hour) && (alarm.minute == clock.minute) ) {
   40dfc:	e0bff983 	ldbu	r2,-26(fp)
   40e00:	10803fcc 	andi	r2,r2,255
   40e04:	10001a1e 	bne	r2,zero,40e70 <timerSecondISR+0x16c>
   40e08:	e0fff9c3 	ldbu	r3,-25(fp)
   40e0c:	e0bff903 	ldbu	r2,-28(fp)
   40e10:	18c03fcc 	andi	r3,r3,255
   40e14:	10803fcc 	andi	r2,r2,255
   40e18:	1880151e 	bne	r3,r2,40e70 <timerSecondISR+0x16c>
   40e1c:	e0fffa03 	ldbu	r3,-24(fp)
   40e20:	e0bff943 	ldbu	r2,-27(fp)
   40e24:	18c03fcc 	andi	r3,r3,255
   40e28:	10803fcc 	andi	r2,r2,255
   40e2c:	1880101e 	bne	r3,r2,40e70 <timerSecondISR+0x16c>

          // immediately start the alarm after initializing the song
          initializeSong();
   40e30:	0041b940 	call	41b94 <initializeSong>
          struct note_info note;
          note = nextSongNote();
   40e34:	e0bffb04 	addi	r2,fp,-20
   40e38:	1009883a 	mov	r4,r2
   40e3c:	0041e4c0 	call	41e4c <nextSongNote>
          //printf("BEEP! BEEP! BEEP! Alarm has gone off...\n");
          //printf("note.frequency == %d\n",note.frequency);
          //printf("note.duration == %d\n",note.duration);
          //printf("note.endofsong == %d\n",note.endofsong);

          writePWM(note.frequency);
   40e40:	e0bffc17 	ldw	r2,-16(fp)
   40e44:	1009883a 	mov	r4,r2
   40e48:	00416980 	call	41698 <writePWM>
          writeLEDPiano(note.letter);
   40e4c:	e0bffb03 	ldbu	r2,-20(fp)
   40e50:	10803fcc 	andi	r2,r2,255
   40e54:	1080201c 	xori	r2,r2,128
   40e58:	10bfe004 	addi	r2,r2,-128
   40e5c:	1009883a 	mov	r4,r2
   40e60:	00409b40 	call	409b4 <writeLEDPiano>
          timerPWMEnableInterrupt(note.duration);
   40e64:	e0bffd17 	ldw	r2,-12(fp)
   40e68:	1009883a 	mov	r4,r2
   40e6c:	004086c0 	call	4086c <timerPWMEnableInterrupt>
      //printf("ERROR: mode.config.on has an invalid value\n");
    }

    // since we're currently in clock mode, 
    // we have to update the display after every second tick
    updateDisplay(clock);
   40e70:	e13ff917 	ldw	r4,-28(fp)
   40e74:	00404600 	call	40460 <updateDisplay>
    clock = upClockSecond(CARRY_ON);
  }

  //printf("CLOCK TIME: %d:%d:%d\n",clock.hour,clock.minute,clock.second);

}
   40e78:	00000d06 	br	40eb0 <timerSecondISR+0x1ac>

  }
  else {
    // since the current time is not being displayed, 
    // we don't update the display
    clock = upClockSecond(CARRY_ON);
   40e7c:	01000044 	movi	r4,1
   40e80:	004291c0 	call	4291c <upClockSecond>
   40e84:	e0bff905 	stb	r2,-28(fp)
   40e88:	1006d23a 	srli	r3,r2,8
   40e8c:	1809883a 	mov	r4,r3
   40e90:	00ffffc4 	movi	r3,-1
   40e94:	20c6703a 	and	r3,r4,r3
   40e98:	e0fff945 	stb	r3,-27(fp)
   40e9c:	1004d43a 	srli	r2,r2,16
   40ea0:	1007883a 	mov	r3,r2
   40ea4:	00bfffc4 	movi	r2,-1
   40ea8:	1884703a 	and	r2,r3,r2
   40eac:	e0bff985 	stb	r2,-26(fp)
  }

  //printf("CLOCK TIME: %d:%d:%d\n",clock.hour,clock.minute,clock.second);

}
   40eb0:	0001883a 	nop
   40eb4:	e037883a 	mov	sp,fp
   40eb8:	dfc00117 	ldw	ra,4(sp)
   40ebc:	df000017 	ldw	fp,0(sp)
   40ec0:	dec00204 	addi	sp,sp,8
   40ec4:	f800283a 	ret

00040ec8 <switchesISR>:


/* ISR determines user requested mode
Once determined, the system will update the display to match what was requested, 
and perform other actions such as turn on/off the alarm (for example)*/
void switchesISR(void* isr_context) {
   40ec8:	defffa04 	addi	sp,sp,-24
   40ecc:	dfc00515 	stw	ra,20(sp)
   40ed0:	df000415 	stw	fp,16(sp)
   40ed4:	df000404 	addi	fp,sp,16
   40ed8:	e13fff15 	stw	r4,-4(fp)

  // reset edge capture register by writing to it 
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(SWITCHES_BASE, 0);
   40edc:	0007883a 	mov	r3,zero
   40ee0:	00800234 	movhi	r2,8
   40ee4:	10843b04 	addi	r2,r2,4332
   40ee8:	10c00035 	stwio	r3,0(r2)

  /* temporary mode struct for data transfer between modules and for testing
  the requested mode based on the switches state */
  struct mode mode_request;

  mode_request = determineMode();
   40eec:	00425040 	call	42504 <determineMode>
   40ef0:	1009883a 	mov	r4,r2
   40ef4:	180b883a 	mov	r5,r3
   40ef8:	e13ffc05 	stb	r4,-16(fp)
   40efc:	2004d23a 	srli	r2,r4,8
   40f00:	1007883a 	mov	r3,r2
   40f04:	00bfffc4 	movi	r2,-1
   40f08:	1884703a 	and	r2,r3,r2
   40f0c:	e0bffc45 	stb	r2,-15(fp)
   40f10:	2004d43a 	srli	r2,r4,16
   40f14:	1007883a 	mov	r3,r2
   40f18:	00bfffc4 	movi	r2,-1
   40f1c:	1884703a 	and	r2,r3,r2
   40f20:	e0bffc85 	stb	r2,-14(fp)
   40f24:	2004d63a 	srli	r2,r4,24
   40f28:	e0bffcc5 	stb	r2,-13(fp)
   40f2c:	e17ffd05 	stb	r5,-12(fp)
   40f30:	2804d23a 	srli	r2,r5,8
   40f34:	1007883a 	mov	r3,r2
   40f38:	00bfffc4 	movi	r2,-1
   40f3c:	1884703a 	and	r2,r3,r2
   40f40:	e0bffd45 	stb	r2,-11(fp)

  /* if an invalid mode is requested, nothing needs to change except for the mode struct.
  if a valid mode is requested, we have to determine what display to change to
  and/or if the alarm needs to be turned on/off */
  if (mode_request.invalid == FALSE) {
   40f44:	e0bffc03 	ldbu	r2,-16(fp)
   40f48:	10803fcc 	andi	r2,r2,255
   40f4c:	10005b1e 	bne	r2,zero,410bc <switchesISR+0x1f4>

    /* don't need to update the display if we're currently displaying the 
    the same mode that was requested */
    if (mode_request.display != mode.display) {
   40f50:	e0fffc43 	ldbu	r3,-15(fp)
   40f54:	d0a0f743 	ldbu	r2,-31779(gp)
   40f58:	18c03fcc 	andi	r3,r3,255
   40f5c:	10803fcc 	andi	r2,r2,255
   40f60:	18804926 	beq	r3,r2,41088 <switchesISR+0x1c0>
      *** although the struct's name is time, the information located 
      in this struct is not necessarily time data. This struct could contain
      volume or song information as well depending on the switch resolution. */
      struct time display;

      switch(mode_request.display) {
   40f64:	e0bffc43 	ldbu	r2,-15(fp)
   40f68:	10803fcc 	andi	r2,r2,255
   40f6c:	10c00060 	cmpeqi	r3,r2,1
   40f70:	1800161e 	bne	r3,zero,40fcc <switchesISR+0x104>
   40f74:	10c00088 	cmpgei	r3,r2,2
   40f78:	1800021e 	bne	r3,zero,40f84 <switchesISR+0xbc>
   40f7c:	10000626 	beq	r2,zero,40f98 <switchesISR+0xd0>
   40f80:	00003006 	br	41044 <switchesISR+0x17c>
   40f84:	10c000a0 	cmpeqi	r3,r2,2
   40f88:	18001d1e 	bne	r3,zero,41000 <switchesISR+0x138>
   40f8c:	108000e0 	cmpeqi	r2,r2,3
   40f90:	1000221e 	bne	r2,zero,4101c <switchesISR+0x154>
   40f94:	00002b06 	br	41044 <switchesISR+0x17c>
        case DISP_CLOCK: 
          display = getClockTime();
   40f98:	00428980 	call	42898 <getClockTime>
   40f9c:	e0bffd85 	stb	r2,-10(fp)
   40fa0:	1006d23a 	srli	r3,r2,8
   40fa4:	1809883a 	mov	r4,r3
   40fa8:	00ffffc4 	movi	r3,-1
   40fac:	20c6703a 	and	r3,r4,r3
   40fb0:	e0fffdc5 	stb	r3,-9(fp)
   40fb4:	1004d43a 	srli	r2,r2,16
   40fb8:	1007883a 	mov	r3,r2
   40fbc:	00bfffc4 	movi	r2,-1
   40fc0:	1884703a 	and	r2,r3,r2
   40fc4:	e0bffe05 	stb	r2,-8(fp)
          break;
   40fc8:	00002106 	br	41050 <switchesISR+0x188>

        case DISP_ALARM:
          display = getAlarmTime();
   40fcc:	0042dd40 	call	42dd4 <getAlarmTime>
   40fd0:	e0bffd85 	stb	r2,-10(fp)
   40fd4:	1006d23a 	srli	r3,r2,8
   40fd8:	1809883a 	mov	r4,r3
   40fdc:	00ffffc4 	movi	r3,-1
   40fe0:	20c6703a 	and	r3,r4,r3
   40fe4:	e0fffdc5 	stb	r3,-9(fp)
   40fe8:	1004d43a 	srli	r2,r2,16
   40fec:	1007883a 	mov	r3,r2
   40ff0:	00bfffc4 	movi	r2,-1
   40ff4:	1884703a 	and	r2,r3,r2
   40ff8:	e0bffe05 	stb	r2,-8(fp)
          break;
   40ffc:	00001406 	br	41050 <switchesISR+0x188>

        case DISP_VOLUME:
          /* the current volume will be displayed on the "second" digits for the 7 seg display.
          For the moment this means that we're not going to check if the volume exceeds 99 */
          display.hour = DONT_DISPLAY;
   41000:	00801904 	movi	r2,100
   41004:	e0bffd85 	stb	r2,-10(fp)
          display.minute = DONT_DISPLAY;
   41008:	00801904 	movi	r2,100
   4100c:	e0bffdc5 	stb	r2,-9(fp)
          display.second = getVolume();
   41010:	00415b80 	call	415b8 <getVolume>
   41014:	e0bffe05 	stb	r2,-8(fp)
          break;
   41018:	00000d06 	br	41050 <switchesISR+0x188>
          //printf("switch to song display mode...\n");

          /* the current song will be displayed on the "second" digits for the 7 seg display.
          7 segment displays. For the moment this means that we're not going to check 
          if the song index exceeds 99  */
          display.hour = DONT_DISPLAY;
   4101c:	00801904 	movi	r2,100
   41020:	e0bffd85 	stb	r2,-10(fp)
          display.minute = DONT_DISPLAY;
   41024:	00801904 	movi	r2,100
   41028:	e0bffdc5 	stb	r2,-9(fp)
          display.second = getSongIndex();
   4102c:	0041a600 	call	41a60 <getSongIndex>
   41030:	e0bffe05 	stb	r2,-8(fp)

          initializeSong();
   41034:	0041b940 	call	41b94 <initializeSong>
          timerPWMEnableInterrupt(PAUSE_DURATION_MS);
   41038:	0100fa04 	movi	r4,1000
   4103c:	004086c0 	call	4086c <timerPWMEnableInterrupt>

          break;
   41040:	00000306 	br	41050 <switchesISR+0x188>

        default:
          printf("ERORR: An invalid display mode is requested\n");
   41044:	01000134 	movhi	r4,4
   41048:	2116a304 	addi	r4,r4,23180
   4104c:	0043f800 	call	43f80 <puts>
      }

      // since the display mode was changed, we'll have to update the display
      updateDisplay(display);  
   41050:	e0bffd8b 	ldhu	r2,-10(fp)
   41054:	e0fffe0b 	ldhu	r3,-8(fp)
   41058:	18c03fcc 	andi	r3,r3,255
   4105c:	1806943a 	slli	r3,r3,16
   41060:	1888b03a 	or	r4,r3,r2
   41064:	0007883a 	mov	r3,zero
   41068:	00804034 	movhi	r2,256
   4106c:	10bfffc4 	addi	r2,r2,-1
   41070:	2084703a 	and	r2,r4,r2
   41074:	18ffc02c 	andhi	r3,r3,65280
   41078:	1884b03a 	or	r2,r3,r2
   4107c:	1007883a 	mov	r3,r2
   41080:	1809883a 	mov	r4,r3
   41084:	00404600 	call	40460 <updateDisplay>
    else { 
      //printf("The requested display mode is already active\n");
    }

    // update the alarm mode if necessary
    if (mode_request.alarm == OFF) {
   41088:	e0bffc83 	ldbu	r2,-14(fp)
   4108c:	10803fcc 	andi	r2,r2,255
   41090:	1000091e 	bne	r2,zero,410b8 <switchesISR+0x1f0>
      alarmLEDoff();
   41094:	00409080 	call	40908 <alarmLEDoff>
      /* only stop the song if we're not in the song selection display.
      otherwise, the song that is being sampled while on this display will suddenly
      stop playing. A song should only stop playing if an armed alarm went off,
      and then a user decides to turn off said alarm, OR if a user changes from
      the song display menu to any other menu */
      if (mode_request.display != DISP_SONG) {
   41098:	e0bffc43 	ldbu	r2,-15(fp)
   4109c:	10803fcc 	andi	r2,r2,255
   410a0:	108000e0 	cmpeqi	r2,r2,3
   410a4:	1000051e 	bne	r2,zero,410bc <switchesISR+0x1f4>
          //printf("song stopped because alarm is off and system is not currently in song display mode!\n");

        stopPWM();
   410a8:	004164c0 	call	4164c <stopPWM>
        LEDPianoOff();
   410ac:	0040c400 	call	40c40 <LEDPianoOff>
        timerPWMDisableInterrupt();
   410b0:	00408d80 	call	408d8 <timerPWMDisableInterrupt>
   410b4:	00000106 	br	410bc <switchesISR+0x1f4>
      }
    }

    // occurs when mode_request.alarm == ON
    else {
      alarmLEDon();
   410b8:	00409380 	call	40938 <alarmLEDon>
  else {
    //printf("ERROR: An invalid mode was requested\n");
  }

  // make sure to update the mode struct before leaving ISR
  mode = mode_request;
   410bc:	e0bffc03 	ldbu	r2,-16(fp)
   410c0:	d0a0f705 	stb	r2,-31780(gp)
   410c4:	e0bffc43 	ldbu	r2,-15(fp)
   410c8:	d0a0f745 	stb	r2,-31779(gp)
   410cc:	e0bffc83 	ldbu	r2,-14(fp)
   410d0:	d0a0f785 	stb	r2,-31778(gp)
   410d4:	e0bffcc3 	ldbu	r2,-13(fp)
   410d8:	d0a0f7c5 	stb	r2,-31777(gp)
   410dc:	e0bffd03 	ldbu	r2,-12(fp)
   410e0:	d0a0f805 	stb	r2,-31776(gp)
   410e4:	e0bffd43 	ldbu	r2,-11(fp)
   410e8:	d0a0f845 	stb	r2,-31775(gp)
  return;
   410ec:	0001883a 	nop
}
   410f0:	e037883a 	mov	sp,fp
   410f4:	dfc00117 	ldw	ra,4(sp)
   410f8:	df000017 	ldw	fp,0(sp)
   410fc:	dec00204 	addi	sp,sp,8
   41100:	f800283a 	ret

00041104 <buttonsISR>:

/* ISR determines what sort of operation the user wants to perform for the
correctly active display mode (increase/decrease clock time, song select, etc.).
Once the requested operation is determined, the system will 
update the display to match what was requested */
void buttonsISR(void* isr_context) {
   41104:	defffc04 	addi	sp,sp,-16
   41108:	dfc00315 	stw	ra,12(sp)
   4110c:	df000215 	stw	fp,8(sp)
   41110:	df000204 	addi	fp,sp,8
   41114:	e13fff15 	stw	r4,-4(fp)

  /* if the user is not currently configuring something (time, alarm, etc), 
  then a button press won't do anything */
  if (mode.config.on == FALSE) {
   41118:	d0a0f7c3 	ldbu	r2,-31777(gp)
   4111c:	10803fcc 	andi	r2,r2,255
   41120:	1000051e 	bne	r2,zero,41138 <buttonsISR+0x34>
    //printf("ERROR: Not currently in config mode! Button press ignored\n");

    /* don't forget to reset edge capture register by writing to it and before
    exiting ISR */
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   41124:	0007883a 	mov	r3,zero
   41128:	00800234 	movhi	r2,8
   4112c:	10841f04 	addi	r2,r2,4220
   41130:	10c00035 	stwio	r3,0(r2)

    return;
   41134:	0000e906 	br	414dc <buttonsISR+0x3d8>
  }
  else {
    // determine the operation requested based on the button's state
    uint8_t buttons_state = IORD_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE);
   41138:	00800234 	movhi	r2,8
   4113c:	10841f04 	addi	r2,r2,4220
   41140:	10800037 	ldwio	r2,0(r2)
   41144:	e0bffe05 	stb	r2,-8(fp)
      struct time display;

      /* what happens next is entirely dependant on what the current display mode is, whether or not 
      the button press was an UP or DOWN operation, and finally if the config was for the 
      minute or hour time units. This scary case statement figures it out */
      switch(mode.display) {
   41148:	d0a0f743 	ldbu	r2,-31779(gp)
   4114c:	10803fcc 	andi	r2,r2,255
   41150:	10c00060 	cmpeqi	r3,r2,1
   41154:	1800551e 	bne	r3,zero,412ac <buttonsISR+0x1a8>
   41158:	10c00088 	cmpgei	r3,r2,2
   4115c:	1800021e 	bne	r3,zero,41168 <buttonsISR+0x64>
   41160:	10000626 	beq	r2,zero,4117c <buttonsISR+0x78>
   41164:	0000c006 	br	41468 <buttonsISR+0x364>
   41168:	10c000a0 	cmpeqi	r3,r2,2
   4116c:	1800991e 	bne	r3,zero,413d4 <buttonsISR+0x2d0>
   41170:	108000e0 	cmpeqi	r2,r2,3
   41174:	1000a71e 	bne	r2,zero,41414 <buttonsISR+0x310>
   41178:	0000bb06 	br	41468 <buttonsISR+0x364>

        case DISP_CLOCK: 

          if (buttons_state == UP) {
   4117c:	e0bffe03 	ldbu	r2,-8(fp)
   41180:	10800098 	cmpnei	r2,r2,2
   41184:	1000231e 	bne	r2,zero,41214 <buttonsISR+0x110>
            if (mode.config.hour == TRUE) {
   41188:	d0a0f803 	ldbu	r2,-31776(gp)
   4118c:	10803fcc 	andi	r2,r2,255
   41190:	10800058 	cmpnei	r2,r2,1
   41194:	10000d1e 	bne	r2,zero,411cc <buttonsISR+0xc8>
              display = upClockHour();
   41198:	0042ab00 	call	42ab0 <upClockHour>
   4119c:	e0bffe45 	stb	r2,-7(fp)
   411a0:	1006d23a 	srli	r3,r2,8
   411a4:	1809883a 	mov	r4,r3
   411a8:	00ffffc4 	movi	r3,-1
   411ac:	20c6703a 	and	r3,r4,r3
   411b0:	e0fffe85 	stb	r3,-6(fp)
   411b4:	1004d43a 	srli	r2,r2,16
   411b8:	1007883a 	mov	r3,r2
   411bc:	00bfffc4 	movi	r2,-1
   411c0:	1884703a 	and	r2,r3,r2
   411c4:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   411c8:	0000ab06 	br	41478 <buttonsISR+0x374>

          if (buttons_state == UP) {
            if (mode.config.hour == TRUE) {
              display = upClockHour();
            }
            else if (mode.config.minute == TRUE) {
   411cc:	d0a0f843 	ldbu	r2,-31775(gp)
   411d0:	10803fcc 	andi	r2,r2,255
   411d4:	10800058 	cmpnei	r2,r2,1
   411d8:	1000a71e 	bne	r2,zero,41478 <buttonsISR+0x374>
              display = upClockMinute(CARRY_OFF);
   411dc:	0009883a 	mov	r4,zero
   411e0:	00429e80 	call	429e8 <upClockMinute>
   411e4:	e0bffe45 	stb	r2,-7(fp)
   411e8:	1006d23a 	srli	r3,r2,8
   411ec:	1809883a 	mov	r4,r3
   411f0:	00ffffc4 	movi	r3,-1
   411f4:	20c6703a 	and	r3,r4,r3
   411f8:	e0fffe85 	stb	r3,-6(fp)
   411fc:	1004d43a 	srli	r2,r2,16
   41200:	1007883a 	mov	r3,r2
   41204:	00bfffc4 	movi	r2,-1
   41208:	1884703a 	and	r2,r3,r2
   4120c:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   41210:	00009906 	br	41478 <buttonsISR+0x374>
            }
            else if (mode.config.minute == TRUE) {
              display = upClockMinute(CARRY_OFF);
            }
          }
          else if (buttons_state == DOWN) {
   41214:	e0bffe03 	ldbu	r2,-8(fp)
   41218:	10800058 	cmpnei	r2,r2,1
   4121c:	1000961e 	bne	r2,zero,41478 <buttonsISR+0x374>
            if (mode.config.hour == TRUE) {
   41220:	d0a0f803 	ldbu	r2,-31776(gp)
   41224:	10803fcc 	andi	r2,r2,255
   41228:	10800058 	cmpnei	r2,r2,1
   4122c:	10000d1e 	bne	r2,zero,41264 <buttonsISR+0x160>
              display = downClockHour();
   41230:	0042cf40 	call	42cf4 <downClockHour>
   41234:	e0bffe45 	stb	r2,-7(fp)
   41238:	1006d23a 	srli	r3,r2,8
   4123c:	1809883a 	mov	r4,r3
   41240:	00ffffc4 	movi	r3,-1
   41244:	20c6703a 	and	r3,r4,r3
   41248:	e0fffe85 	stb	r3,-6(fp)
   4124c:	1004d43a 	srli	r2,r2,16
   41250:	1007883a 	mov	r3,r2
   41254:	00bfffc4 	movi	r2,-1
   41258:	1884703a 	and	r2,r3,r2
   4125c:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   41260:	00008506 	br	41478 <buttonsISR+0x374>
          }
          else if (buttons_state == DOWN) {
            if (mode.config.hour == TRUE) {
              display = downClockHour();
            }
            else if (mode.config.minute == TRUE) {
   41264:	d0a0f843 	ldbu	r2,-31775(gp)
   41268:	10803fcc 	andi	r2,r2,255
   4126c:	10800058 	cmpnei	r2,r2,1
   41270:	1000811e 	bne	r2,zero,41478 <buttonsISR+0x374>
              display = downClockMinute(CARRY_OFF);
   41274:	0009883a 	mov	r4,zero
   41278:	0042c2c0 	call	42c2c <downClockMinute>
   4127c:	e0bffe45 	stb	r2,-7(fp)
   41280:	1006d23a 	srli	r3,r2,8
   41284:	1809883a 	mov	r4,r3
   41288:	00ffffc4 	movi	r3,-1
   4128c:	20c6703a 	and	r3,r4,r3
   41290:	e0fffe85 	stb	r3,-6(fp)
   41294:	1004d43a 	srli	r2,r2,16
   41298:	1007883a 	mov	r3,r2
   4129c:	00bfffc4 	movi	r2,-1
   412a0:	1884703a 	and	r2,r3,r2
   412a4:	e0bffec5 	stb	r2,-5(fp)
            }
          }
          break;
   412a8:	00007306 	br	41478 <buttonsISR+0x374>

        case DISP_ALARM:

          if (buttons_state == UP) {
   412ac:	e0bffe03 	ldbu	r2,-8(fp)
   412b0:	10800098 	cmpnei	r2,r2,2
   412b4:	1000221e 	bne	r2,zero,41340 <buttonsISR+0x23c>
            if (mode.config.hour == TRUE) {
   412b8:	d0a0f803 	ldbu	r2,-31776(gp)
   412bc:	10803fcc 	andi	r2,r2,255
   412c0:	10800058 	cmpnei	r2,r2,1
   412c4:	10000d1e 	bne	r2,zero,412fc <buttonsISR+0x1f8>
              display = upAlarmHour();
   412c8:	0042f000 	call	42f00 <upAlarmHour>
   412cc:	e0bffe45 	stb	r2,-7(fp)
   412d0:	1006d23a 	srli	r3,r2,8
   412d4:	1809883a 	mov	r4,r3
   412d8:	00ffffc4 	movi	r3,-1
   412dc:	20c6703a 	and	r3,r4,r3
   412e0:	e0fffe85 	stb	r3,-6(fp)
   412e4:	1004d43a 	srli	r2,r2,16
   412e8:	1007883a 	mov	r3,r2
   412ec:	00bfffc4 	movi	r2,-1
   412f0:	1884703a 	and	r2,r3,r2
   412f4:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   412f8:	00006106 	br	41480 <buttonsISR+0x37c>

          if (buttons_state == UP) {
            if (mode.config.hour == TRUE) {
              display = upAlarmHour();
            }
            else if (mode.config.minute == TRUE) {
   412fc:	d0a0f843 	ldbu	r2,-31775(gp)
   41300:	10803fcc 	andi	r2,r2,255
   41304:	10800058 	cmpnei	r2,r2,1
   41308:	10005d1e 	bne	r2,zero,41480 <buttonsISR+0x37c>
              display = upAlarmMinute();
   4130c:	0042e580 	call	42e58 <upAlarmMinute>
   41310:	e0bffe45 	stb	r2,-7(fp)
   41314:	1006d23a 	srli	r3,r2,8
   41318:	1809883a 	mov	r4,r3
   4131c:	00ffffc4 	movi	r3,-1
   41320:	20c6703a 	and	r3,r4,r3
   41324:	e0fffe85 	stb	r3,-6(fp)
   41328:	1004d43a 	srli	r2,r2,16
   4132c:	1007883a 	mov	r3,r2
   41330:	00bfffc4 	movi	r2,-1
   41334:	1884703a 	and	r2,r3,r2
   41338:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   4133c:	00005006 	br	41480 <buttonsISR+0x37c>
            }
            else if (mode.config.minute == TRUE) {
              display = upAlarmMinute();
            }
          }
          else if (buttons_state == DOWN) {
   41340:	e0bffe03 	ldbu	r2,-8(fp)
   41344:	10800058 	cmpnei	r2,r2,1
   41348:	10004d1e 	bne	r2,zero,41480 <buttonsISR+0x37c>
            if (mode.config.hour == TRUE) {
   4134c:	d0a0f803 	ldbu	r2,-31776(gp)
   41350:	10803fcc 	andi	r2,r2,255
   41354:	10800058 	cmpnei	r2,r2,1
   41358:	10000d1e 	bne	r2,zero,41390 <buttonsISR+0x28c>
              display = downAlarmHour();
   4135c:	00430580 	call	43058 <downAlarmHour>
   41360:	e0bffe45 	stb	r2,-7(fp)
   41364:	1006d23a 	srli	r3,r2,8
   41368:	1809883a 	mov	r4,r3
   4136c:	00ffffc4 	movi	r3,-1
   41370:	20c6703a 	and	r3,r4,r3
   41374:	e0fffe85 	stb	r3,-6(fp)
   41378:	1004d43a 	srli	r2,r2,16
   4137c:	1007883a 	mov	r3,r2
   41380:	00bfffc4 	movi	r2,-1
   41384:	1884703a 	and	r2,r3,r2
   41388:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   4138c:	00003c06 	br	41480 <buttonsISR+0x37c>
          }
          else if (buttons_state == DOWN) {
            if (mode.config.hour == TRUE) {
              display = downAlarmHour();
            }
            else if (mode.config.minute == TRUE) {
   41390:	d0a0f843 	ldbu	r2,-31775(gp)
   41394:	10803fcc 	andi	r2,r2,255
   41398:	10800058 	cmpnei	r2,r2,1
   4139c:	1000381e 	bne	r2,zero,41480 <buttonsISR+0x37c>
              display = downAlarmMinute();
   413a0:	0042fb00 	call	42fb0 <downAlarmMinute>
   413a4:	e0bffe45 	stb	r2,-7(fp)
   413a8:	1006d23a 	srli	r3,r2,8
   413ac:	1809883a 	mov	r4,r3
   413b0:	00ffffc4 	movi	r3,-1
   413b4:	20c6703a 	and	r3,r4,r3
   413b8:	e0fffe85 	stb	r3,-6(fp)
   413bc:	1004d43a 	srli	r2,r2,16
   413c0:	1007883a 	mov	r3,r2
   413c4:	00bfffc4 	movi	r2,-1
   413c8:	1884703a 	and	r2,r3,r2
   413cc:	e0bffec5 	stb	r2,-5(fp)
            }
          }
          break;
   413d0:	00002b06 	br	41480 <buttonsISR+0x37c>


        case DISP_VOLUME:

          display.hour = DONT_DISPLAY;
   413d4:	00801904 	movi	r2,100
   413d8:	e0bffe45 	stb	r2,-7(fp)
          display.minute = DONT_DISPLAY;
   413dc:	00801904 	movi	r2,100
   413e0:	e0bffe85 	stb	r2,-6(fp)
          if (buttons_state == UP) {
   413e4:	e0bffe03 	ldbu	r2,-8(fp)
   413e8:	10800098 	cmpnei	r2,r2,2
   413ec:	1000031e 	bne	r2,zero,413fc <buttonsISR+0x2f8>
            display.second = upVolume();
   413f0:	00415d80 	call	415d8 <upVolume>
   413f4:	e0bffec5 	stb	r2,-5(fp)
          }
          else if (buttons_state == DOWN) {
            display.second = downVolume();
          }
          
          break;
   413f8:	00002306 	br	41488 <buttonsISR+0x384>
          display.hour = DONT_DISPLAY;
          display.minute = DONT_DISPLAY;
          if (buttons_state == UP) {
            display.second = upVolume();
          }
          else if (buttons_state == DOWN) {
   413fc:	e0bffe03 	ldbu	r2,-8(fp)
   41400:	10800058 	cmpnei	r2,r2,1
   41404:	1000201e 	bne	r2,zero,41488 <buttonsISR+0x384>
            display.second = downVolume();
   41408:	00416140 	call	41614 <downVolume>
   4140c:	e0bffec5 	stb	r2,-5(fp)
          }
          
          break;
   41410:	00001d06 	br	41488 <buttonsISR+0x384>

        case DISP_SONG:

          // immediately cut the PWM in case a song is currently being played
          stopPWM();
   41414:	004164c0 	call	4164c <stopPWM>
          LEDPianoOff();
   41418:	0040c400 	call	40c40 <LEDPianoOff>

          //printf("button input while in display song mode...\n");

          display.hour = DONT_DISPLAY;
   4141c:	00801904 	movi	r2,100
   41420:	e0bffe45 	stb	r2,-7(fp)
          display.minute = DONT_DISPLAY;
   41424:	00801904 	movi	r2,100
   41428:	e0bffe85 	stb	r2,-6(fp)
          if (buttons_state == UP) {
   4142c:	e0bffe03 	ldbu	r2,-8(fp)
   41430:	10800098 	cmpnei	r2,r2,2
   41434:	1000031e 	bne	r2,zero,41444 <buttonsISR+0x340>
            display.second = upSong();
   41438:	0041a800 	call	41a80 <upSong>
   4143c:	e0bffec5 	stb	r2,-5(fp)
   41440:	00000506 	br	41458 <buttonsISR+0x354>
          }
          else if (buttons_state == DOWN) {
   41444:	e0bffe03 	ldbu	r2,-8(fp)
   41448:	10800058 	cmpnei	r2,r2,1
   4144c:	1000021e 	bne	r2,zero,41458 <buttonsISR+0x354>
            display.second = downSong();
   41450:	0041ac40 	call	41ac4 <downSong>
   41454:	e0bffec5 	stb	r2,-5(fp)
          }

          // intialize song, but add a pause before song starts
          initializeSong();
   41458:	0041b940 	call	41b94 <initializeSong>

          timerPWMEnableInterrupt(PAUSE_DURATION_MS);
   4145c:	0100fa04 	movi	r4,1000
   41460:	004086c0 	call	4086c <timerPWMEnableInterrupt>

          break;
   41464:	00000906 	br	4148c <buttonsISR+0x388>

        default:
          // if the switches.c module didn't mess up, this should never print!
          printf("ERORR: The system is currently in an invalid display mode!!\n");
   41468:	01000134 	movhi	r4,4
   4146c:	2116ae04 	addi	r4,r4,23224
   41470:	0043f800 	call	43f80 <puts>
   41474:	00000506 	br	4148c <buttonsISR+0x388>
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   41478:	0001883a 	nop
   4147c:	00000306 	br	4148c <buttonsISR+0x388>
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   41480:	0001883a 	nop
   41484:	00000106 	br	4148c <buttonsISR+0x388>
          }
          else if (buttons_state == DOWN) {
            display.second = downVolume();
          }
          
          break;
   41488:	0001883a 	nop
          // if the switches.c module didn't mess up, this should never print!
          printf("ERORR: The system is currently in an invalid display mode!!\n");
      }

      // since the display mode was changed, we'll have to update the display
      updateDisplay(display);  
   4148c:	e0bffe43 	ldbu	r2,-7(fp)
   41490:	e0fffe83 	ldbu	r3,-6(fp)
   41494:	1806923a 	slli	r3,r3,8
   41498:	1884b03a 	or	r2,r3,r2
   4149c:	e0fffec3 	ldbu	r3,-5(fp)
   414a0:	1806943a 	slli	r3,r3,16
   414a4:	1888b03a 	or	r4,r3,r2
   414a8:	0007883a 	mov	r3,zero
   414ac:	00804034 	movhi	r2,256
   414b0:	10bfffc4 	addi	r2,r2,-1
   414b4:	2084703a 	and	r2,r4,r2
   414b8:	18ffc02c 	andhi	r3,r3,65280
   414bc:	1884b03a 	or	r2,r3,r2
   414c0:	1007883a 	mov	r3,r2
   414c4:	1809883a 	mov	r4,r3
   414c8:	00404600 	call	40460 <updateDisplay>
    }

  // we can't forget to reset edge capture register by writing to it!
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   414cc:	0007883a 	mov	r3,zero
   414d0:	00800234 	movhi	r2,8
   414d4:	10841f04 	addi	r2,r2,4220
   414d8:	10c00035 	stwio	r3,0(r2)

}
   414dc:	e037883a 	mov	sp,fp
   414e0:	dfc00117 	ldw	ra,4(sp)
   414e4:	df000017 	ldw	fp,0(sp)
   414e8:	dec00204 	addi	sp,sp,8
   414ec:	f800283a 	ret

000414f0 <timerPWMISR>:


void timerPWMISR(void* isr_context) {
   414f0:	defff904 	addi	sp,sp,-28
   414f4:	dfc00615 	stw	ra,24(sp)
   414f8:	df000515 	stw	fp,20(sp)
   414fc:	df000504 	addi	fp,sp,20
   41500:	e13fff15 	stw	r4,-4(fp)
  //printf("timerPWMISR has fired!\n");

  /* The TO (timeout) bit is set to 1 when the internal counter reaches zero. Once set by a
  timeout event, the TO bit stays set until explicitly cleared by a master peripheral. 
  The TO bit is cleared by writing 0 to the status register. */
  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_PWM_BASE, 0);
   41504:	0007883a 	mov	r3,zero
   41508:	00800234 	movhi	r2,8
   4150c:	10840004 	addi	r2,r2,4096
   41510:	10c00035 	stwio	r3,0(r2)

  struct note_info note;

  note = nextSongNote();
   41514:	e13ffb04 	addi	r4,fp,-20
   41518:	0041e4c0 	call	41e4c <nextSongNote>
  //printf("note.frequency == %d\n",note.frequency);
  //printf("note.duration == %d\n",note.duration);
  //printf("note.endofsong == %d\n",note.endofsong);

  if (note.endofsong == FALSE) {
   4151c:	e0bffe17 	ldw	r2,-8(fp)
   41520:	10000d1e 	bne	r2,zero,41558 <timerPWMISR+0x68>
    writePWM(note.frequency);
   41524:	e0bffc17 	ldw	r2,-16(fp)
   41528:	1009883a 	mov	r4,r2
   4152c:	00416980 	call	41698 <writePWM>
    writeLEDPiano(note.letter);
   41530:	e0bffb03 	ldbu	r2,-20(fp)
   41534:	10803fcc 	andi	r2,r2,255
   41538:	1080201c 	xori	r2,r2,128
   4153c:	10bfe004 	addi	r2,r2,-128
   41540:	1009883a 	mov	r4,r2
   41544:	00409b40 	call	409b4 <writeLEDPiano>
    timerPWMEnableInterrupt(note.duration);
   41548:	e0bffd17 	ldw	r2,-12(fp)
   4154c:	1009883a 	mov	r4,r2
   41550:	004086c0 	call	4086c <timerPWMEnableInterrupt>
      initializeSong();
      timerPWMEnableInterrupt(PAUSE_DURATION_MS);  
    }
  }

}
   41554:	00001206 	br	415a0 <timerPWMISR+0xb0>
  if (note.endofsong == FALSE) {
    writePWM(note.frequency);
    writeLEDPiano(note.letter);
    timerPWMEnableInterrupt(note.duration);
  }
  else if (note.endofsong == TRUE) {
   41558:	e0bffe17 	ldw	r2,-8(fp)
   4155c:	10800058 	cmpnei	r2,r2,1
   41560:	10000f1e 	bne	r2,zero,415a0 <timerPWMISR+0xb0>

    if (mode.display == DISP_SONG) {
   41564:	d0a0f743 	ldbu	r2,-31779(gp)
   41568:	10803fcc 	andi	r2,r2,255
   4156c:	108000d8 	cmpnei	r2,r2,3
   41570:	1000061e 	bne	r2,zero,4158c <timerPWMISR+0x9c>
      
      #ifdef REPEAT_SONG_PREVIEW
        //printf("repeating song preview while in display song mode...\n");
        stopPWM();   
   41574:	004164c0 	call	4164c <stopPWM>
        LEDPianoOff();
   41578:	0040c400 	call	40c40 <LEDPianoOff>
        initializeSong();
   4157c:	0041b940 	call	41b94 <initializeSong>
        timerPWMEnableInterrupt(PAUSE_DURATION_MS);  
   41580:	0100fa04 	movi	r4,1000
   41584:	004086c0 	call	4086c <timerPWMEnableInterrupt>
      initializeSong();
      timerPWMEnableInterrupt(PAUSE_DURATION_MS);  
    }
  }

}
   41588:	00000506 	br	415a0 <timerPWMISR+0xb0>
      #endif

    }

    else {
      stopPWM();
   4158c:	004164c0 	call	4164c <stopPWM>
      LEDPianoOff();
   41590:	0040c400 	call	40c40 <LEDPianoOff>
      //printf("repeating song while alarm is currently going off\n");
      initializeSong();
   41594:	0041b940 	call	41b94 <initializeSong>
      timerPWMEnableInterrupt(PAUSE_DURATION_MS);  
   41598:	0100fa04 	movi	r4,1000
   4159c:	004086c0 	call	4086c <timerPWMEnableInterrupt>
    }
  }

}
   415a0:	0001883a 	nop
   415a4:	e037883a 	mov	sp,fp
   415a8:	dfc00117 	ldw	ra,4(sp)
   415ac:	df000017 	ldw	fp,0(sp)
   415b0:	dec00204 	addi	sp,sp,8
   415b4:	f800283a 	ret

000415b8 <getVolume>:
#include "pwm.h"

uint8_t volume = 1;

uint8_t getVolume(void) {
   415b8:	deffff04 	addi	sp,sp,-4
   415bc:	df000015 	stw	fp,0(sp)
   415c0:	d839883a 	mov	fp,sp
  return volume;
   415c4:	d0a00003 	ldbu	r2,-32768(gp)
}
   415c8:	e037883a 	mov	sp,fp
   415cc:	df000017 	ldw	fp,0(sp)
   415d0:	dec00104 	addi	sp,sp,4
   415d4:	f800283a 	ret

000415d8 <upVolume>:

uint8_t upVolume(void) {
   415d8:	deffff04 	addi	sp,sp,-4
   415dc:	df000015 	stw	fp,0(sp)
   415e0:	d839883a 	mov	fp,sp
  if (volume != MAX_VOLUME) {
   415e4:	d0a00003 	ldbu	r2,-32768(gp)
   415e8:	10803fcc 	andi	r2,r2,255
   415ec:	10800320 	cmpeqi	r2,r2,12
   415f0:	1000031e 	bne	r2,zero,41600 <upVolume+0x28>
    volume++;
   415f4:	d0a00003 	ldbu	r2,-32768(gp)
   415f8:	10800044 	addi	r2,r2,1
   415fc:	d0a00005 	stb	r2,-32768(gp)
  }
  return volume;
   41600:	d0a00003 	ldbu	r2,-32768(gp)
}
   41604:	e037883a 	mov	sp,fp
   41608:	df000017 	ldw	fp,0(sp)
   4160c:	dec00104 	addi	sp,sp,4
   41610:	f800283a 	ret

00041614 <downVolume>:
uint8_t downVolume(void) {
   41614:	deffff04 	addi	sp,sp,-4
   41618:	df000015 	stw	fp,0(sp)
   4161c:	d839883a 	mov	fp,sp
  if (volume != 0) {
   41620:	d0a00003 	ldbu	r2,-32768(gp)
   41624:	10803fcc 	andi	r2,r2,255
   41628:	10000326 	beq	r2,zero,41638 <downVolume+0x24>
    volume--;
   4162c:	d0a00003 	ldbu	r2,-32768(gp)
   41630:	10bfffc4 	addi	r2,r2,-1
   41634:	d0a00005 	stb	r2,-32768(gp)
  }
  return volume;
   41638:	d0a00003 	ldbu	r2,-32768(gp)
}
   4163c:	e037883a 	mov	sp,fp
   41640:	df000017 	ldw	fp,0(sp)
   41644:	dec00104 	addi	sp,sp,4
   41648:	f800283a 	ret

0004164c <stopPWM>:

void stopPWM(void) {
   4164c:	defffd04 	addi	sp,sp,-12
   41650:	dfc00215 	stw	ra,8(sp)
   41654:	df000115 	stw	fp,4(sp)
   41658:	df000104 	addi	fp,sp,4
  int return_code = ALTERA_AVALON_PWM_OK;
   4165c:	e03fff15 	stw	zero,-4(fp)

  //Disable PWM and Check Return Code
  return_code = altera_avalon_pwm_disable(PWM_BASE); 
   41660:	01000234 	movhi	r4,8
   41664:	21043c04 	addi	r4,r4,4336
   41668:	00403380 	call	40338 <altera_avalon_pwm_disable>
   4166c:	e0bfff15 	stw	r2,-4(fp)
  check_return_code(PWM_BASE, return_code);
   41670:	e17fff17 	ldw	r5,-4(fp)
   41674:	01000234 	movhi	r4,8
   41678:	21043c04 	addi	r4,r4,4336
   4167c:	00419300 	call	41930 <check_return_code>
}
   41680:	0001883a 	nop
   41684:	e037883a 	mov	sp,fp
   41688:	dfc00117 	ldw	ra,4(sp)
   4168c:	df000017 	ldw	fp,0(sp)
   41690:	dec00204 	addi	sp,sp,8
   41694:	f800283a 	ret

00041698 <writePWM>:

void writePWM(int frequency) {
   41698:	defffa04 	addi	sp,sp,-24
   4169c:	dfc00515 	stw	ra,20(sp)
   416a0:	df000415 	stw	fp,16(sp)
   416a4:	df000404 	addi	fp,sp,16
   416a8:	e13fff15 	stw	r4,-4(fp)

  if (frequency == 0) {
   416ac:	e0bfff17 	ldw	r2,-4(fp)
   416b0:	1000021e 	bne	r2,zero,416bc <writePWM+0x24>
    // this happens if the 'note' to play is a musical rest
    stopPWM();
   416b4:	004164c0 	call	4164c <stopPWM>
    
    //Enable PWM and Check Return Code
    return_code = altera_avalon_pwm_enable(PWM_BASE); 
    check_return_code(PWM_BASE, return_code);
  }
}
   416b8:	00002a06 	br	41764 <writePWM+0xcc>
    // this happens if the 'note' to play is a musical rest
    stopPWM();
  }
  else {
    // conversion of input frequency to PWM clock cycle divide value
    unsigned int clock_divide = NIOS_CLOCK_FREQ/frequency;
   416bc:	e17fff17 	ldw	r5,-4(fp)
   416c0:	0100bef4 	movhi	r4,763
   416c4:	213c2004 	addi	r4,r4,-3968
   416c8:	00431640 	call	43164 <__divsi3>
   416cc:	e0bffc15 	stw	r2,-16(fp)

    unsigned int duty_cycle = clock_divide*duty_cycle_lookup_table[volume];
   416d0:	e13ffc17 	ldw	r4,-16(fp)
   416d4:	0043d240 	call	43d24 <__floatunsisf>
   416d8:	1009883a 	mov	r4,r2
   416dc:	d0a00003 	ldbu	r2,-32768(gp)
   416e0:	10c03fcc 	andi	r3,r2,255
   416e4:	00800134 	movhi	r2,4
   416e8:	1096bd04 	addi	r2,r2,23284
   416ec:	18c7883a 	add	r3,r3,r3
   416f0:	18c7883a 	add	r3,r3,r3
   416f4:	10c5883a 	add	r2,r2,r3
   416f8:	10c00017 	ldw	r3,0(r2)
   416fc:	180b883a 	mov	r5,r3
   41700:	00433d40 	call	433d4 <__mulsf3>
   41704:	1007883a 	mov	r3,r2
   41708:	1805883a 	mov	r2,r3
   4170c:	1009883a 	mov	r4,r2
   41710:	00431040 	call	43104 <__fixunssfsi>
   41714:	e0bffd15 	stw	r2,-12(fp)

    int return_code = ALTERA_AVALON_PWM_OK;
   41718:	e03ffe15 	stw	zero,-8(fp)
    
    //Initialize PWM and Check Return Code
    return_code = altera_avalon_pwm_init(PWM_BASE, clock_divide, duty_cycle);  
   4171c:	e1bffd17 	ldw	r6,-12(fp)
   41720:	e17ffc17 	ldw	r5,-16(fp)
   41724:	01000234 	movhi	r4,8
   41728:	21043c04 	addi	r4,r4,4336
   4172c:	00402800 	call	40280 <altera_avalon_pwm_init>
   41730:	e0bffe15 	stw	r2,-8(fp)
    check_return_code(PWM_BASE, return_code);
   41734:	e17ffe17 	ldw	r5,-8(fp)
   41738:	01000234 	movhi	r4,8
   4173c:	21043c04 	addi	r4,r4,4336
   41740:	00419300 	call	41930 <check_return_code>
    
    //Enable PWM and Check Return Code
    return_code = altera_avalon_pwm_enable(PWM_BASE); 
   41744:	01000234 	movhi	r4,8
   41748:	21043c04 	addi	r4,r4,4336
   4174c:	00402e40 	call	402e4 <altera_avalon_pwm_enable>
   41750:	e0bffe15 	stw	r2,-8(fp)
    check_return_code(PWM_BASE, return_code);
   41754:	e17ffe17 	ldw	r5,-8(fp)
   41758:	01000234 	movhi	r4,8
   4175c:	21043c04 	addi	r4,r4,4336
   41760:	00419300 	call	41930 <check_return_code>
  }
}
   41764:	0001883a 	nop
   41768:	e037883a 	mov	sp,fp
   4176c:	dfc00117 	ldw	ra,4(sp)
   41770:	df000017 	ldw	fp,0(sp)
   41774:	dec00204 	addi	sp,sp,8
   41778:	f800283a 	ret

0004177c <default500HzSquareWave>:

void default500HzSquareWave(void) {
   4177c:	defffb04 	addi	sp,sp,-20
   41780:	dfc00415 	stw	ra,16(sp)
   41784:	df000315 	stw	fp,12(sp)
   41788:	df000304 	addi	fp,sp,12

 unsigned int clock_divide = 100000;
   4178c:	008000b4 	movhi	r2,2
   41790:	10a1a804 	addi	r2,r2,-31072
   41794:	e0bffd15 	stw	r2,-12(fp)
 unsigned int duty_cycle =    50000;
   41798:	00b0d414 	movui	r2,50000
   4179c:	e0bffe15 	stw	r2,-8(fp)
 int return_code = ALTERA_AVALON_PWM_OK;
   417a0:	e03fff15 	stw	zero,-4(fp)
 
 //Initialize PWM and Check Return Code
 return_code = altera_avalon_pwm_init(PWM_BASE, clock_divide, duty_cycle);  
   417a4:	e1bffe17 	ldw	r6,-8(fp)
   417a8:	e17ffd17 	ldw	r5,-12(fp)
   417ac:	01000234 	movhi	r4,8
   417b0:	21043c04 	addi	r4,r4,4336
   417b4:	00402800 	call	40280 <altera_avalon_pwm_init>
   417b8:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   417bc:	e17fff17 	ldw	r5,-4(fp)
   417c0:	01000234 	movhi	r4,8
   417c4:	21043c04 	addi	r4,r4,4336
   417c8:	00419300 	call	41930 <check_return_code>
 
 //Enable PWM and Check Return Code
 return_code = altera_avalon_pwm_enable(PWM_BASE); 
   417cc:	01000234 	movhi	r4,8
   417d0:	21043c04 	addi	r4,r4,4336
   417d4:	00402e40 	call	402e4 <altera_avalon_pwm_enable>
   417d8:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   417dc:	e17fff17 	ldw	r5,-4(fp)
   417e0:	01000234 	movhi	r4,8
   417e4:	21043c04 	addi	r4,r4,4336
   417e8:	00419300 	call	41930 <check_return_code>
}
   417ec:	0001883a 	nop
   417f0:	e037883a 	mov	sp,fp
   417f4:	dfc00117 	ldw	ra,4(sp)
   417f8:	df000017 	ldw	fp,0(sp)
   417fc:	dec00204 	addi	sp,sp,8
   41800:	f800283a 	ret

00041804 <testPWM>:



void testPWM(void) {
   41804:	defffc04 	addi	sp,sp,-16
   41808:	dfc00315 	stw	ra,12(sp)
   4180c:	df000215 	stw	fp,8(sp)
   41810:	df000204 	addi	fp,sp,8
 
 unsigned int duty_cycle;
 int return_code = ALTERA_AVALON_PWM_OK;
   41814:	e03fff15 	stw	zero,-4(fp)
 
 printf("Period = %u\n", IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE) );
   41818:	00800234 	movhi	r2,8
   4181c:	10843c04 	addi	r2,r2,4336
   41820:	10800037 	ldwio	r2,0(r2)
   41824:	100b883a 	mov	r5,r2
   41828:	01000134 	movhi	r4,4
   4182c:	2116ca04 	addi	r4,r4,23336
   41830:	0043eb40 	call	43eb4 <printf>
 printf("Duty cycle = %u\n", IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(PWM_BASE) );
   41834:	00800234 	movhi	r2,8
   41838:	10843d04 	addi	r2,r2,4340
   4183c:	10800037 	ldwio	r2,0(r2)
   41840:	100b883a 	mov	r5,r2
   41844:	01000134 	movhi	r4,4
   41848:	2116ce04 	addi	r4,r4,23352
   4184c:	0043eb40 	call	43eb4 <printf>
 
 //Initialize PWM and Check Return Code
 return_code = altera_avalon_pwm_init(PWM_BASE, 500000, 1);  
   41850:	01800044 	movi	r6,1
   41854:	01400234 	movhi	r5,8
   41858:	29684804 	addi	r5,r5,-24288
   4185c:	01000234 	movhi	r4,8
   41860:	21043c04 	addi	r4,r4,4336
   41864:	00402800 	call	40280 <altera_avalon_pwm_init>
   41868:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   4186c:	e17fff17 	ldw	r5,-4(fp)
   41870:	01000234 	movhi	r4,8
   41874:	21043c04 	addi	r4,r4,4336
   41878:	00419300 	call	41930 <check_return_code>
 
 //Enable PWM and Check Return Code
 return_code = altera_avalon_pwm_enable(PWM_BASE); 
   4187c:	01000234 	movhi	r4,8
   41880:	21043c04 	addi	r4,r4,4336
   41884:	00402e40 	call	402e4 <altera_avalon_pwm_enable>
   41888:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   4188c:	e17fff17 	ldw	r5,-4(fp)
   41890:	01000234 	movhi	r4,8
   41894:	21043c04 	addi	r4,r4,4336
   41898:	00419300 	call	41930 <check_return_code>

//init duty_cycle with the value written to duty_cycle register during initialization
 duty_cycle = IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(PWM_BASE);
   4189c:	00800234 	movhi	r2,8
   418a0:	10843d04 	addi	r2,r2,4340
   418a4:	10800037 	ldwio	r2,0(r2)
   418a8:	e0bffe15 	stw	r2,-8(fp)
 
 
 while(1)
   {
     while(duty_cycle++ < IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE))
   418ac:	00000906 	br	418d4 <testPWM+0xd0>
     {
      	return_code = altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
   418b0:	e17ffe17 	ldw	r5,-8(fp)
   418b4:	01000234 	movhi	r4,8
   418b8:	21043c04 	addi	r4,r4,4336
   418bc:	00403880 	call	40388 <altera_avalon_pwm_change_duty_cycle>
   418c0:	e0bfff15 	stw	r2,-4(fp)
      	check_return_code(PWM_BASE, return_code);
   418c4:	e17fff17 	ldw	r5,-4(fp)
   418c8:	01000234 	movhi	r4,8
   418cc:	21043c04 	addi	r4,r4,4336
   418d0:	00419300 	call	41930 <check_return_code>
 duty_cycle = IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(PWM_BASE);
 
 
 while(1)
   {
     while(duty_cycle++ < IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE))
   418d4:	e0fffe17 	ldw	r3,-8(fp)
   418d8:	18800044 	addi	r2,r3,1
   418dc:	e0bffe15 	stw	r2,-8(fp)
   418e0:	00800234 	movhi	r2,8
   418e4:	10843c04 	addi	r2,r2,4336
   418e8:	10800037 	ldwio	r2,0(r2)
   418ec:	18bff036 	bltu	r3,r2,418b0 <__alt_data_end+0xfffd98b0>
     {
      	return_code = altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
      	check_return_code(PWM_BASE, return_code);
     }          
     while(--duty_cycle > 1)
   418f0:	00000406 	br	41904 <testPWM+0x100>
      	altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
   418f4:	e17ffe17 	ldw	r5,-8(fp)
   418f8:	01000234 	movhi	r4,8
   418fc:	21043c04 	addi	r4,r4,4336
   41900:	00403880 	call	40388 <altera_avalon_pwm_change_duty_cycle>
     while(duty_cycle++ < IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE))
     {
      	return_code = altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
      	check_return_code(PWM_BASE, return_code);
     }          
     while(--duty_cycle > 1)
   41904:	e0bffe17 	ldw	r2,-8(fp)
   41908:	10bfffc4 	addi	r2,r2,-1
   4190c:	e0bffe15 	stw	r2,-8(fp)
   41910:	e0bffe17 	ldw	r2,-8(fp)
   41914:	108000a8 	cmpgeui	r2,r2,2
   41918:	103ff61e 	bne	r2,zero,418f4 <__alt_data_end+0xfffd98f4>
      	altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
        check_return_code(PWM_BASE, return_code);
   4191c:	e17fff17 	ldw	r5,-4(fp)
   41920:	01000234 	movhi	r4,8
   41924:	21043c04 	addi	r4,r4,4336
   41928:	00419300 	call	41930 <check_return_code>
   }
   4192c:	003fdf06 	br	418ac <__alt_data_end+0xfffd98ac>

00041930 <check_return_code>:
}

void check_return_code(unsigned int address, int return_code)
{
   41930:	defffc04 	addi	sp,sp,-16
   41934:	dfc00315 	stw	ra,12(sp)
   41938:	df000215 	stw	fp,8(sp)
   4193c:	df000204 	addi	fp,sp,8
   41940:	e13ffe15 	stw	r4,-8(fp)
   41944:	e17fff15 	stw	r5,-4(fp)
	if(return_code != ALTERA_AVALON_PWM_OK)
   41948:	e0bfff17 	ldw	r2,-4(fp)
   4194c:	10000326 	beq	r2,zero,4195c <check_return_code+0x2c>
      		print_error(address, return_code);	
   41950:	e17fff17 	ldw	r5,-4(fp)
   41954:	e13ffe17 	ldw	r4,-8(fp)
   41958:	00419740 	call	41974 <print_error>
}
   4195c:	0001883a 	nop
   41960:	e037883a 	mov	sp,fp
   41964:	dfc00117 	ldw	ra,4(sp)
   41968:	df000017 	ldw	fp,0(sp)
   4196c:	dec00204 	addi	sp,sp,8
   41970:	f800283a 	ret

00041974 <print_error>:

void print_error(unsigned int address, int return_code)
{
   41974:	defffc04 	addi	sp,sp,-16
   41978:	dfc00315 	stw	ra,12(sp)
   4197c:	df000215 	stw	fp,8(sp)
   41980:	df000204 	addi	fp,sp,8
   41984:	e13ffe15 	stw	r4,-8(fp)
   41988:	e17fff15 	stw	r5,-4(fp)
	printf("Program Terminated Due to an error with Avalon PWM located at 0x%x:\n", address);
   4198c:	e17ffe17 	ldw	r5,-8(fp)
   41990:	01000134 	movhi	r4,4
   41994:	2116d304 	addi	r4,r4,23372
   41998:	0043eb40 	call	43eb4 <printf>
	switch(return_code)
   4199c:	e0bfff17 	ldw	r2,-4(fp)
   419a0:	10ffffa0 	cmpeqi	r3,r2,-2
   419a4:	1800161e 	bne	r3,zero,41a00 <print_error+0x8c>
   419a8:	10ffffe0 	cmpeqi	r3,r2,-1
   419ac:	1800031e 	bne	r3,zero,419bc <print_error+0x48>
   419b0:	10bfff60 	cmpeqi	r2,r2,-3
   419b4:	10001d1e 	bne	r2,zero,41a2c <print_error+0xb8>
   419b8:	00002706 	br	41a58 <print_error+0xe4>
	{
	case ALTERA_AVALON_PWM_DUTY_CYCLE_GREATER_THAN_CLOCK_CYCLE_ERROR:
		printf("The value in the clock cycle register must be greater than the value in the duty cycle register\n");
   419bc:	01000134 	movhi	r4,4
   419c0:	2116e504 	addi	r4,r4,23444
   419c4:	0043f800 	call	43f80 <puts>
		printf("Value in the Clock Divide Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(address)); 
   419c8:	e0bffe17 	ldw	r2,-8(fp)
   419cc:	10800037 	ldwio	r2,0(r2)
   419d0:	100b883a 	mov	r5,r2
   419d4:	01000134 	movhi	r4,4
   419d8:	2116fd04 	addi	r4,r4,23540
   419dc:	0043eb40 	call	43eb4 <printf>
		printf("Value in the Duty Cycle Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(address));
   419e0:	e0bffe17 	ldw	r2,-8(fp)
   419e4:	10800104 	addi	r2,r2,4
   419e8:	10800037 	ldwio	r2,0(r2)
   419ec:	100b883a 	mov	r5,r2
   419f0:	01000134 	movhi	r4,4
   419f4:	21170804 	addi	r4,r4,23584
   419f8:	0043eb40 	call	43eb4 <printf>
		break;
   419fc:	00001706 	br	41a5c <print_error+0xe8>
  case ALTERA_AVALON_PWM_ENABLED_CONFIRMATION_ERROR:
    printf("Unable to confirm that the PWM is enabled\n");
   41a00:	01000134 	movhi	r4,4
   41a04:	21171204 	addi	r4,r4,23624
   41a08:	0043f800 	call	43f80 <puts>
		printf("Value in the Enable Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_ENABLE(address)); 
   41a0c:	e0bffe17 	ldw	r2,-8(fp)
   41a10:	10800204 	addi	r2,r2,8
   41a14:	10800037 	ldwio	r2,0(r2)
   41a18:	100b883a 	mov	r5,r2
   41a1c:	01000134 	movhi	r4,4
   41a20:	21171d04 	addi	r4,r4,23668
   41a24:	0043eb40 	call	43eb4 <printf>
    break;
   41a28:	00000c06 	br	41a5c <print_error+0xe8>
  case ALTERA_AVALON_PWM_DISABLED_CONFIRMATION_ERROR:
  	printf("Unable to confirm that the PWM is disabled\n");
   41a2c:	01000134 	movhi	r4,4
   41a30:	21172604 	addi	r4,r4,23704
   41a34:	0043f800 	call	43f80 <puts>
		printf("Value in the Enable Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_ENABLE(address)); 
   41a38:	e0bffe17 	ldw	r2,-8(fp)
   41a3c:	10800204 	addi	r2,r2,8
   41a40:	10800037 	ldwio	r2,0(r2)
   41a44:	100b883a 	mov	r5,r2
   41a48:	01000134 	movhi	r4,4
   41a4c:	21171d04 	addi	r4,r4,23668
   41a50:	0043eb40 	call	43eb4 <printf>
  	break;
   41a54:	00000106 	br	41a5c <print_error+0xe8>
  default:
  	break; 		     
   41a58:	0001883a 	nop
	}
while(1);
   41a5c:	003fff06 	br	41a5c <__alt_data_end+0xfffd9a5c>

00041a60 <getSongIndex>:

/* p is a pointer to a const char -> we can change what to point at
but we can't change the actual value of the object that we're pointing at */
const char *p;

uint8_t getSongIndex(void) {
   41a60:	deffff04 	addi	sp,sp,-4
   41a64:	df000015 	stw	fp,0(sp)
   41a68:	d839883a 	mov	fp,sp
  return song_index;
   41a6c:	d0a0f903 	ldbu	r2,-31772(gp)
}
   41a70:	e037883a 	mov	sp,fp
   41a74:	df000017 	ldw	fp,0(sp)
   41a78:	dec00104 	addi	sp,sp,4
   41a7c:	f800283a 	ret

00041a80 <upSong>:

uint8_t upSong(void) {
   41a80:	deffff04 	addi	sp,sp,-4
   41a84:	df000015 	stw	fp,0(sp)
   41a88:	d839883a 	mov	fp,sp
  /* song is an array of pointers of type const char. Since each pointer has the same
  size in memory (char* takes up 1 byte) if we divide the size of the entire array by the size
  of 1 char pointer, we'll get the number char pointers and thus the number of songs */
  if (song_index == (sizeof(song)/sizeof(song[0]))-1){
   41a8c:	d0a0f903 	ldbu	r2,-31772(gp)
   41a90:	10803fcc 	andi	r2,r2,255
   41a94:	10800758 	cmpnei	r2,r2,29
   41a98:	1000021e 	bne	r2,zero,41aa4 <upSong+0x24>

    // wrap around when scrolling through songs
    song_index = 0;
   41a9c:	d020f905 	stb	zero,-31772(gp)
   41aa0:	00000306 	br	41ab0 <upSong+0x30>
  }
  else {
    song_index++;
   41aa4:	d0a0f903 	ldbu	r2,-31772(gp)
   41aa8:	10800044 	addi	r2,r2,1
   41aac:	d0a0f905 	stb	r2,-31772(gp)
  }
  return song_index;
   41ab0:	d0a0f903 	ldbu	r2,-31772(gp)
}
   41ab4:	e037883a 	mov	sp,fp
   41ab8:	df000017 	ldw	fp,0(sp)
   41abc:	dec00104 	addi	sp,sp,4
   41ac0:	f800283a 	ret

00041ac4 <downSong>:

uint8_t downSong(void) {
   41ac4:	deffff04 	addi	sp,sp,-4
   41ac8:	df000015 	stw	fp,0(sp)
   41acc:	d839883a 	mov	fp,sp
  if (song_index == 0) {
   41ad0:	d0a0f903 	ldbu	r2,-31772(gp)
   41ad4:	10803fcc 	andi	r2,r2,255
   41ad8:	1000031e 	bne	r2,zero,41ae8 <downSong+0x24>

    // wrap around when scrolling through songs
    song_index = (sizeof(song)/sizeof(song[0])-1);
   41adc:	00800744 	movi	r2,29
   41ae0:	d0a0f905 	stb	r2,-31772(gp)
   41ae4:	00000306 	br	41af4 <downSong+0x30>
  }
  else {
    song_index--;
   41ae8:	d0a0f903 	ldbu	r2,-31772(gp)
   41aec:	10bfffc4 	addi	r2,r2,-1
   41af0:	d0a0f905 	stb	r2,-31772(gp)
  }
  return song_index;
   41af4:	d0a0f903 	ldbu	r2,-31772(gp)
}
   41af8:	e037883a 	mov	sp,fp
   41afc:	df000017 	ldw	fp,0(sp)
   41b00:	dec00104 	addi	sp,sp,4
   41b04:	f800283a 	ret

00041b08 <note2freq>:

int note2freq(int note) {
   41b08:	defffc04 	addi	sp,sp,-16
   41b0c:	dfc00315 	stw	ra,12(sp)
   41b10:	df000215 	stw	fp,8(sp)
   41b14:	dc000115 	stw	r16,4(sp)
   41b18:	df000204 	addi	fp,sp,8
   41b1c:	e13ffe15 	stw	r4,-8(fp)
  return notefreq[note % 12] / (1 << (9 - (note / 12)));
   41b20:	e0bffe17 	ldw	r2,-8(fp)
   41b24:	01400304 	movi	r5,12
   41b28:	1009883a 	mov	r4,r2
   41b2c:	00431e80 	call	431e8 <__modsi3>
   41b30:	1007883a 	mov	r3,r2
   41b34:	00800134 	movhi	r2,4
   41b38:	109d7f04 	addi	r2,r2,30204
   41b3c:	18c7883a 	add	r3,r3,r3
   41b40:	18c7883a 	add	r3,r3,r3
   41b44:	10c5883a 	add	r2,r2,r3
   41b48:	14000017 	ldw	r16,0(r2)
   41b4c:	e0bffe17 	ldw	r2,-8(fp)
   41b50:	01400304 	movi	r5,12
   41b54:	1009883a 	mov	r4,r2
   41b58:	00431640 	call	43164 <__divsi3>
   41b5c:	1007883a 	mov	r3,r2
   41b60:	00800244 	movi	r2,9
   41b64:	10c5c83a 	sub	r2,r2,r3
   41b68:	00c00044 	movi	r3,1
   41b6c:	1884983a 	sll	r2,r3,r2
   41b70:	100b883a 	mov	r5,r2
   41b74:	8009883a 	mov	r4,r16
   41b78:	00431640 	call	43164 <__divsi3>
}
   41b7c:	e6ffff04 	addi	sp,fp,-4
   41b80:	dfc00217 	ldw	ra,8(sp)
   41b84:	df000117 	ldw	fp,4(sp)
   41b88:	dc000017 	ldw	r16,0(sp)
   41b8c:	dec00304 	addi	sp,sp,12
   41b90:	f800283a 	ret

00041b94 <initializeSong>:

void initializeSong(void) {
   41b94:	defffc04 	addi	sp,sp,-16
   41b98:	dfc00315 	stw	ra,12(sp)
   41b9c:	df000215 	stw	fp,8(sp)
   41ba0:	df000204 	addi	fp,sp,8

  p = song[song_index];
   41ba4:	d0a0f903 	ldbu	r2,-31772(gp)
   41ba8:	10c03fcc 	andi	r3,r2,255
   41bac:	00800134 	movhi	r2,4
   41bb0:	109d6104 	addi	r2,r2,30084
   41bb4:	18c7883a 	add	r3,r3,r3
   41bb8:	18c7883a 	add	r3,r3,r3
   41bbc:	10c5883a 	add	r2,r2,r3
   41bc0:	10800017 	ldw	r2,0(r2)
   41bc4:	d0a0fb15 	stw	r2,-31764(gp)
  
  // Skip name
  while (*p && *p != ':') p++;
   41bc8:	00000306 	br	41bd8 <initializeSong+0x44>
   41bcc:	d0a0fb17 	ldw	r2,-31764(gp)
   41bd0:	10800044 	addi	r2,r2,1
   41bd4:	d0a0fb15 	stw	r2,-31764(gp)
   41bd8:	d0a0fb17 	ldw	r2,-31764(gp)
   41bdc:	10800003 	ldbu	r2,0(r2)
   41be0:	10803fcc 	andi	r2,r2,255
   41be4:	1080201c 	xori	r2,r2,128
   41be8:	10bfe004 	addi	r2,r2,-128
   41bec:	10000726 	beq	r2,zero,41c0c <initializeSong+0x78>
   41bf0:	d0a0fb17 	ldw	r2,-31764(gp)
   41bf4:	10800003 	ldbu	r2,0(r2)
   41bf8:	10803fcc 	andi	r2,r2,255
   41bfc:	1080201c 	xori	r2,r2,128
   41c00:	10bfe004 	addi	r2,r2,-128
   41c04:	10800e98 	cmpnei	r2,r2,58
   41c08:	103ff01e 	bne	r2,zero,41bcc <__alt_data_end+0xfffd9bcc>
  if (!*p) {printf("ERROR in rtttl.c: 0 after name:\n"); return;}
   41c0c:	d0a0fb17 	ldw	r2,-31764(gp)
   41c10:	10800003 	ldbu	r2,0(r2)
   41c14:	10803fcc 	andi	r2,r2,255
   41c18:	1080201c 	xori	r2,r2,128
   41c1c:	10bfe004 	addi	r2,r2,-128
   41c20:	1000041e 	bne	r2,zero,41c34 <initializeSong+0xa0>
   41c24:	01000134 	movhi	r4,4
   41c28:	211cd104 	addi	r4,r4,29508
   41c2c:	0043f800 	call	43f80 <puts>
   41c30:	00008106 	br	41e38 <initializeSong+0x2a4>
  p++;
   41c34:	d0a0fb17 	ldw	r2,-31764(gp)
   41c38:	10800044 	addi	r2,r2,1
   41c3c:	d0a0fb15 	stw	r2,-31764(gp)

  // Parse defaults
  while (*p) {
   41c40:	00007206 	br	41e0c <initializeSong+0x278>
    char param;
    int value;

    while (*p == ' ') p++;
   41c44:	d0a0fb17 	ldw	r2,-31764(gp)
   41c48:	10800044 	addi	r2,r2,1
   41c4c:	d0a0fb15 	stw	r2,-31764(gp)
   41c50:	d0a0fb17 	ldw	r2,-31764(gp)
   41c54:	10800003 	ldbu	r2,0(r2)
   41c58:	10803fcc 	andi	r2,r2,255
   41c5c:	1080201c 	xori	r2,r2,128
   41c60:	10bfe004 	addi	r2,r2,-128
   41c64:	10800820 	cmpeqi	r2,r2,32
   41c68:	103ff61e 	bne	r2,zero,41c44 <__alt_data_end+0xfffd9c44>
    if (!*p) {printf("ERROR in rtttl.c: defaults: never found\n"); return;}
   41c6c:	d0a0fb17 	ldw	r2,-31764(gp)
   41c70:	10800003 	ldbu	r2,0(r2)
   41c74:	10803fcc 	andi	r2,r2,255
   41c78:	1080201c 	xori	r2,r2,128
   41c7c:	10bfe004 	addi	r2,r2,-128
   41c80:	1000041e 	bne	r2,zero,41c94 <initializeSong+0x100>
   41c84:	01000134 	movhi	r4,4
   41c88:	211cd904 	addi	r4,r4,29540
   41c8c:	0043f800 	call	43f80 <puts>
   41c90:	00006906 	br	41e38 <initializeSong+0x2a4>
    if (*p == ':') break;
   41c94:	d0a0fb17 	ldw	r2,-31764(gp)
   41c98:	10800003 	ldbu	r2,0(r2)
   41c9c:	10803fcc 	andi	r2,r2,255
   41ca0:	1080201c 	xori	r2,r2,128
   41ca4:	10bfe004 	addi	r2,r2,-128
   41ca8:	10800e98 	cmpnei	r2,r2,58
   41cac:	10005e26 	beq	r2,zero,41e28 <initializeSong+0x294>

    param = *p++;
   41cb0:	d0a0fb17 	ldw	r2,-31764(gp)
   41cb4:	10c00044 	addi	r3,r2,1
   41cb8:	d0e0fb15 	stw	r3,-31764(gp)
   41cbc:	10800003 	ldbu	r2,0(r2)
   41cc0:	e0bfff05 	stb	r2,-4(fp)
    if (*p != '=') {printf("ERROR in rtttl.c: = never found\n"); return;}
   41cc4:	d0a0fb17 	ldw	r2,-31764(gp)
   41cc8:	10800003 	ldbu	r2,0(r2)
   41ccc:	10803fcc 	andi	r2,r2,255
   41cd0:	1080201c 	xori	r2,r2,128
   41cd4:	10bfe004 	addi	r2,r2,-128
   41cd8:	10800f60 	cmpeqi	r2,r2,61
   41cdc:	1000041e 	bne	r2,zero,41cf0 <initializeSong+0x15c>
   41ce0:	01000134 	movhi	r4,4
   41ce4:	211ce304 	addi	r4,r4,29580
   41ce8:	0043f800 	call	43f80 <puts>
   41cec:	00005206 	br	41e38 <initializeSong+0x2a4>
    
    p++;
   41cf0:	d0a0fb17 	ldw	r2,-31764(gp)
   41cf4:	10800044 	addi	r2,r2,1
   41cf8:	d0a0fb15 	stw	r2,-31764(gp)
    value = 0;
   41cfc:	e03ffe15 	stw	zero,-8(fp)
    while (*p >= '0' && *p <= '9') value = value * 10 + (*p++ - '0');
   41d00:	00000c06 	br	41d34 <initializeSong+0x1a0>
   41d04:	e0bffe17 	ldw	r2,-8(fp)
   41d08:	10c002a4 	muli	r3,r2,10
   41d0c:	d0a0fb17 	ldw	r2,-31764(gp)
   41d10:	11000044 	addi	r4,r2,1
   41d14:	d120fb15 	stw	r4,-31764(gp)
   41d18:	10800003 	ldbu	r2,0(r2)
   41d1c:	10803fcc 	andi	r2,r2,255
   41d20:	1080201c 	xori	r2,r2,128
   41d24:	10bfe004 	addi	r2,r2,-128
   41d28:	10bff404 	addi	r2,r2,-48
   41d2c:	1885883a 	add	r2,r3,r2
   41d30:	e0bffe15 	stw	r2,-8(fp)
   41d34:	d0a0fb17 	ldw	r2,-31764(gp)
   41d38:	10800003 	ldbu	r2,0(r2)
   41d3c:	10803fcc 	andi	r2,r2,255
   41d40:	1080201c 	xori	r2,r2,128
   41d44:	10bfe004 	addi	r2,r2,-128
   41d48:	10800c10 	cmplti	r2,r2,48
   41d4c:	1000071e 	bne	r2,zero,41d6c <initializeSong+0x1d8>
   41d50:	d0a0fb17 	ldw	r2,-31764(gp)
   41d54:	10800003 	ldbu	r2,0(r2)
   41d58:	10803fcc 	andi	r2,r2,255
   41d5c:	1080201c 	xori	r2,r2,128
   41d60:	10bfe004 	addi	r2,r2,-128
   41d64:	10800e90 	cmplti	r2,r2,58
   41d68:	103fe61e 	bne	r2,zero,41d04 <__alt_data_end+0xfffd9d04>

    switch (param) {
   41d6c:	e0bfff07 	ldb	r2,-4(fp)
   41d70:	10c01920 	cmpeqi	r3,r2,100
   41d74:	1800051e 	bne	r3,zero,41d8c <initializeSong+0x1f8>
   41d78:	10c01be0 	cmpeqi	r3,r2,111
   41d7c:	1800081e 	bne	r3,zero,41da0 <initializeSong+0x20c>
   41d80:	108018a0 	cmpeqi	r2,r2,98
   41d84:	1000091e 	bne	r2,zero,41dac <initializeSong+0x218>
   41d88:	00000b06 	br	41db8 <initializeSong+0x224>
      case 'd': defdur = 32 / value; break;
   41d8c:	e17ffe17 	ldw	r5,-8(fp)
   41d90:	01000804 	movi	r4,32
   41d94:	00431640 	call	43164 <__divsi3>
   41d98:	d0a00115 	stw	r2,-32764(gp)
   41d9c:	00000606 	br	41db8 <initializeSong+0x224>
      case 'o': defscale = value; break;
   41da0:	e0bffe17 	ldw	r2,-8(fp)
   41da4:	d0a00215 	stw	r2,-32760(gp)
   41da8:	00000306 	br	41db8 <initializeSong+0x224>
      case 'b': bpm = value; break;
   41dac:	e0bffe17 	ldw	r2,-8(fp)
   41db0:	d0a00315 	stw	r2,-32756(gp)
   41db4:	0001883a 	nop
    }

    while (*p == ' ') p++;
   41db8:	00000306 	br	41dc8 <initializeSong+0x234>
   41dbc:	d0a0fb17 	ldw	r2,-31764(gp)
   41dc0:	10800044 	addi	r2,r2,1
   41dc4:	d0a0fb15 	stw	r2,-31764(gp)
   41dc8:	d0a0fb17 	ldw	r2,-31764(gp)
   41dcc:	10800003 	ldbu	r2,0(r2)
   41dd0:	10803fcc 	andi	r2,r2,255
   41dd4:	1080201c 	xori	r2,r2,128
   41dd8:	10bfe004 	addi	r2,r2,-128
   41ddc:	10800820 	cmpeqi	r2,r2,32
   41de0:	103ff61e 	bne	r2,zero,41dbc <__alt_data_end+0xfffd9dbc>
    if (*p == ',') p++;
   41de4:	d0a0fb17 	ldw	r2,-31764(gp)
   41de8:	10800003 	ldbu	r2,0(r2)
   41dec:	10803fcc 	andi	r2,r2,255
   41df0:	1080201c 	xori	r2,r2,128
   41df4:	10bfe004 	addi	r2,r2,-128
   41df8:	10800b18 	cmpnei	r2,r2,44
   41dfc:	1000031e 	bne	r2,zero,41e0c <initializeSong+0x278>
   41e00:	d0a0fb17 	ldw	r2,-31764(gp)
   41e04:	10800044 	addi	r2,r2,1
   41e08:	d0a0fb15 	stw	r2,-31764(gp)
  while (*p && *p != ':') p++;
  if (!*p) {printf("ERROR in rtttl.c: 0 after name:\n"); return;}
  p++;

  // Parse defaults
  while (*p) {
   41e0c:	d0a0fb17 	ldw	r2,-31764(gp)
   41e10:	10800003 	ldbu	r2,0(r2)
   41e14:	10803fcc 	andi	r2,r2,255
   41e18:	1080201c 	xori	r2,r2,128
   41e1c:	10bfe004 	addi	r2,r2,-128
   41e20:	103f8b1e 	bne	r2,zero,41c50 <__alt_data_end+0xfffd9c50>
   41e24:	00000106 	br	41e2c <initializeSong+0x298>
    char param;
    int value;

    while (*p == ' ') p++;
    if (!*p) {printf("ERROR in rtttl.c: defaults: never found\n"); return;}
    if (*p == ':') break;
   41e28:	0001883a 	nop
    }

    while (*p == ' ') p++;
    if (*p == ',') p++;
  }
  p++;
   41e2c:	d0a0fb17 	ldw	r2,-31764(gp)
   41e30:	10800044 	addi	r2,r2,1
   41e34:	d0a0fb15 	stw	r2,-31764(gp)

}
   41e38:	e037883a 	mov	sp,fp
   41e3c:	dfc00117 	ldw	ra,4(sp)
   41e40:	df000017 	ldw	fp,0(sp)
   41e44:	dec00204 	addi	sp,sp,8
   41e48:	f800283a 	ret

00041e4c <nextSongNote>:

// used to get the first note of the song and the subsequent ones
struct note_info nextSongNote(void) {
   41e4c:	defff304 	addi	sp,sp,-52
   41e50:	dfc00c15 	stw	ra,48(sp)
   41e54:	df000b15 	stw	fp,44(sp)
   41e58:	df000b04 	addi	fp,sp,44
   41e5c:	e13fff15 	stw	r4,-4(fp)

  int note = -1;
   41e60:	00bfffc4 	movi	r2,-1
   41e64:	e0bff515 	stw	r2,-44(fp)
  int scale = defscale;
   41e68:	d0a00217 	ldw	r2,-32760(gp)
   41e6c:	e0bff615 	stw	r2,-40(fp)
  int dur = defdur;
   41e70:	d0a00117 	ldw	r2,-32764(gp)
   41e74:	e0bff715 	stw	r2,-36(fp)
  int ms;
  int freq;
  struct note_info payload;

  if (!*p) {printf("End of song!\n");payload.endofsong = TRUE; return payload;}
   41e78:	d0a0fb17 	ldw	r2,-31764(gp)
   41e7c:	10800003 	ldbu	r2,0(r2)
   41e80:	10803fcc 	andi	r2,r2,255
   41e84:	1080201c 	xori	r2,r2,128
   41e88:	10bfe004 	addi	r2,r2,-128
   41e8c:	1000121e 	bne	r2,zero,41ed8 <nextSongNote+0x8c>
   41e90:	01000134 	movhi	r4,4
   41e94:	211ceb04 	addi	r4,r4,29612
   41e98:	0043f800 	call	43f80 <puts>
   41e9c:	00800044 	movi	r2,1
   41ea0:	e0bffe15 	stw	r2,-8(fp)
   41ea4:	e0bfff17 	ldw	r2,-4(fp)
   41ea8:	e0fffb17 	ldw	r3,-20(fp)
   41eac:	10c00015 	stw	r3,0(r2)
   41eb0:	e0fffc17 	ldw	r3,-16(fp)
   41eb4:	10c00115 	stw	r3,4(r2)
   41eb8:	e0fffd17 	ldw	r3,-12(fp)
   41ebc:	10c00215 	stw	r3,8(r2)
   41ec0:	e0fffe17 	ldw	r3,-8(fp)
   41ec4:	10c00315 	stw	r3,12(r2)
   41ec8:	00018806 	br	424ec <nextSongNote+0x6a0>

  else {

    // Skip whitespace
    while (*p == ' ') p++;
   41ecc:	d0a0fb17 	ldw	r2,-31764(gp)
   41ed0:	10800044 	addi	r2,r2,1
   41ed4:	d0a0fb15 	stw	r2,-31764(gp)
   41ed8:	d0a0fb17 	ldw	r2,-31764(gp)
   41edc:	10800003 	ldbu	r2,0(r2)
   41ee0:	10803fcc 	andi	r2,r2,255
   41ee4:	1080201c 	xori	r2,r2,128
   41ee8:	10bfe004 	addi	r2,r2,-128
   41eec:	10800820 	cmpeqi	r2,r2,32
   41ef0:	103ff61e 	bne	r2,zero,41ecc <__alt_data_end+0xfffd9ecc>
    if (!*p) {printf("ERROR in rtttl.c: 0 found during nextSongNote\n");payload.letter = ERROR_CHAR; return payload;}
   41ef4:	d0a0fb17 	ldw	r2,-31764(gp)
   41ef8:	10800003 	ldbu	r2,0(r2)
   41efc:	10803fcc 	andi	r2,r2,255
   41f00:	1080201c 	xori	r2,r2,128
   41f04:	10bfe004 	addi	r2,r2,-128
   41f08:	10000f1e 	bne	r2,zero,41f48 <nextSongNote+0xfc>
   41f0c:	01000134 	movhi	r4,4
   41f10:	211cef04 	addi	r4,r4,29628
   41f14:	0043f800 	call	43f80 <puts>
   41f18:	00801604 	movi	r2,88
   41f1c:	e0bffb05 	stb	r2,-20(fp)
   41f20:	e0bfff17 	ldw	r2,-4(fp)
   41f24:	e0fffb17 	ldw	r3,-20(fp)
   41f28:	10c00015 	stw	r3,0(r2)
   41f2c:	e0fffc17 	ldw	r3,-16(fp)
   41f30:	10c00115 	stw	r3,4(r2)
   41f34:	e0fffd17 	ldw	r3,-12(fp)
   41f38:	10c00215 	stw	r3,8(r2)
   41f3c:	e0fffe17 	ldw	r3,-8(fp)
   41f40:	10c00315 	stw	r3,12(r2)
   41f44:	00016906 	br	424ec <nextSongNote+0x6a0>

    // Parse duration
    if (*p >= '0' && *p <= '9') {
   41f48:	d0a0fb17 	ldw	r2,-31764(gp)
   41f4c:	10800003 	ldbu	r2,0(r2)
   41f50:	10803fcc 	andi	r2,r2,255
   41f54:	1080201c 	xori	r2,r2,128
   41f58:	10bfe004 	addi	r2,r2,-128
   41f5c:	10800c10 	cmplti	r2,r2,48
   41f60:	1000271e 	bne	r2,zero,42000 <nextSongNote+0x1b4>
   41f64:	d0a0fb17 	ldw	r2,-31764(gp)
   41f68:	10800003 	ldbu	r2,0(r2)
   41f6c:	10803fcc 	andi	r2,r2,255
   41f70:	1080201c 	xori	r2,r2,128
   41f74:	10bfe004 	addi	r2,r2,-128
   41f78:	10800e88 	cmpgei	r2,r2,58
   41f7c:	1000201e 	bne	r2,zero,42000 <nextSongNote+0x1b4>
      int value = 0;
   41f80:	e03ff915 	stw	zero,-28(fp)
      while (*p >= '0' && *p <= '9') value = value * 10 + (*p++ - '0');
   41f84:	00000c06 	br	41fb8 <nextSongNote+0x16c>
   41f88:	e0bff917 	ldw	r2,-28(fp)
   41f8c:	10c002a4 	muli	r3,r2,10
   41f90:	d0a0fb17 	ldw	r2,-31764(gp)
   41f94:	11000044 	addi	r4,r2,1
   41f98:	d120fb15 	stw	r4,-31764(gp)
   41f9c:	10800003 	ldbu	r2,0(r2)
   41fa0:	10803fcc 	andi	r2,r2,255
   41fa4:	1080201c 	xori	r2,r2,128
   41fa8:	10bfe004 	addi	r2,r2,-128
   41fac:	10bff404 	addi	r2,r2,-48
   41fb0:	1885883a 	add	r2,r3,r2
   41fb4:	e0bff915 	stw	r2,-28(fp)
   41fb8:	d0a0fb17 	ldw	r2,-31764(gp)
   41fbc:	10800003 	ldbu	r2,0(r2)
   41fc0:	10803fcc 	andi	r2,r2,255
   41fc4:	1080201c 	xori	r2,r2,128
   41fc8:	10bfe004 	addi	r2,r2,-128
   41fcc:	10800c10 	cmplti	r2,r2,48
   41fd0:	1000071e 	bne	r2,zero,41ff0 <nextSongNote+0x1a4>
   41fd4:	d0a0fb17 	ldw	r2,-31764(gp)
   41fd8:	10800003 	ldbu	r2,0(r2)
   41fdc:	10803fcc 	andi	r2,r2,255
   41fe0:	1080201c 	xori	r2,r2,128
   41fe4:	10bfe004 	addi	r2,r2,-128
   41fe8:	10800e90 	cmplti	r2,r2,58
   41fec:	103fe61e 	bne	r2,zero,41f88 <__alt_data_end+0xfffd9f88>

      dur = 32 / value;
   41ff0:	e17ff917 	ldw	r5,-28(fp)
   41ff4:	01000804 	movi	r4,32
   41ff8:	00431640 	call	43164 <__divsi3>
   41ffc:	e0bff715 	stw	r2,-36(fp)
    }

    // Parse note
    switch (*p) {
   42000:	d0a0fb17 	ldw	r2,-31764(gp)
   42004:	10800003 	ldbu	r2,0(r2)
   42008:	10803fcc 	andi	r2,r2,255
   4200c:	1080201c 	xori	r2,r2,128
   42010:	10bfe004 	addi	r2,r2,-128
   42014:	10c01c68 	cmpgeui	r3,r2,113
   42018:	1800a01e 	bne	r3,zero,4229c <nextSongNote+0x450>
   4201c:	100690ba 	slli	r3,r2,2
   42020:	00800134 	movhi	r2,4
   42024:	10880d04 	addi	r2,r2,8244
   42028:	1885883a 	add	r2,r3,r2
   4202c:	10800017 	ldw	r2,0(r2)
   42030:	1000683a 	jmp	r2
   42034:	000421f8 	rdprs	zero,zero,4231
   42038:	0004229c 	xori	zero,zero,4234
   4203c:	0004229c 	xori	zero,zero,4234
   42040:	0004229c 	xori	zero,zero,4234
   42044:	0004229c 	xori	zero,zero,4234
   42048:	0004229c 	xori	zero,zero,4234
   4204c:	0004229c 	xori	zero,zero,4234
   42050:	0004229c 	xori	zero,zero,4234
   42054:	0004229c 	xori	zero,zero,4234
   42058:	0004229c 	xori	zero,zero,4234
   4205c:	0004229c 	xori	zero,zero,4234
   42060:	0004229c 	xori	zero,zero,4234
   42064:	0004229c 	xori	zero,zero,4234
   42068:	0004229c 	xori	zero,zero,4234
   4206c:	0004229c 	xori	zero,zero,4234
   42070:	0004229c 	xori	zero,zero,4234
   42074:	0004229c 	xori	zero,zero,4234
   42078:	0004229c 	xori	zero,zero,4234
   4207c:	0004229c 	xori	zero,zero,4234
   42080:	0004229c 	xori	zero,zero,4234
   42084:	0004229c 	xori	zero,zero,4234
   42088:	0004229c 	xori	zero,zero,4234
   4208c:	0004229c 	xori	zero,zero,4234
   42090:	0004229c 	xori	zero,zero,4234
   42094:	0004229c 	xori	zero,zero,4234
   42098:	0004229c 	xori	zero,zero,4234
   4209c:	0004229c 	xori	zero,zero,4234
   420a0:	0004229c 	xori	zero,zero,4234
   420a4:	0004229c 	xori	zero,zero,4234
   420a8:	0004229c 	xori	zero,zero,4234
   420ac:	0004229c 	xori	zero,zero,4234
   420b0:	0004229c 	xori	zero,zero,4234
   420b4:	0004229c 	xori	zero,zero,4234
   420b8:	0004229c 	xori	zero,zero,4234
   420bc:	0004229c 	xori	zero,zero,4234
   420c0:	0004229c 	xori	zero,zero,4234
   420c4:	0004229c 	xori	zero,zero,4234
   420c8:	0004229c 	xori	zero,zero,4234
   420cc:	0004229c 	xori	zero,zero,4234
   420d0:	0004229c 	xori	zero,zero,4234
   420d4:	0004229c 	xori	zero,zero,4234
   420d8:	0004229c 	xori	zero,zero,4234
   420dc:	0004229c 	xori	zero,zero,4234
   420e0:	0004229c 	xori	zero,zero,4234
   420e4:	0004229c 	xori	zero,zero,4234
   420e8:	0004229c 	xori	zero,zero,4234
   420ec:	0004229c 	xori	zero,zero,4234
   420f0:	0004229c 	xori	zero,zero,4234
   420f4:	0004229c 	xori	zero,zero,4234
   420f8:	0004229c 	xori	zero,zero,4234
   420fc:	0004229c 	xori	zero,zero,4234
   42100:	0004229c 	xori	zero,zero,4234
   42104:	0004229c 	xori	zero,zero,4234
   42108:	0004229c 	xori	zero,zero,4234
   4210c:	0004229c 	xori	zero,zero,4234
   42110:	0004229c 	xori	zero,zero,4234
   42114:	0004229c 	xori	zero,zero,4234
   42118:	0004229c 	xori	zero,zero,4234
   4211c:	0004229c 	xori	zero,zero,4234
   42120:	0004229c 	xori	zero,zero,4234
   42124:	0004229c 	xori	zero,zero,4234
   42128:	0004229c 	xori	zero,zero,4234
   4212c:	0004229c 	xori	zero,zero,4234
   42130:	0004229c 	xori	zero,zero,4234
   42134:	0004229c 	xori	zero,zero,4234
   42138:	0004226c 	andhi	zero,zero,4233
   4213c:	00042284 	movi	zero,4234
   42140:	00042234 	movhi	zero,4232
   42144:	0004223c 	xorhi	zero,zero,4232
   42148:	00042248 	cmpgei	zero,zero,4233
   4214c:	00042254 	movui	zero,4233
   42150:	00042260 	cmpeqi	zero,zero,4233
   42154:	00042278 	rdprs	zero,zero,4233
   42158:	0004229c 	xori	zero,zero,4234
   4215c:	0004229c 	xori	zero,zero,4234
   42160:	0004229c 	xori	zero,zero,4234
   42164:	0004229c 	xori	zero,zero,4234
   42168:	0004229c 	xori	zero,zero,4234
   4216c:	0004229c 	xori	zero,zero,4234
   42170:	0004229c 	xori	zero,zero,4234
   42174:	00042290 	cmplti	zero,zero,4234
   42178:	0004229c 	xori	zero,zero,4234
   4217c:	0004229c 	xori	zero,zero,4234
   42180:	0004229c 	xori	zero,zero,4234
   42184:	0004229c 	xori	zero,zero,4234
   42188:	0004229c 	xori	zero,zero,4234
   4218c:	0004229c 	xori	zero,zero,4234
   42190:	0004229c 	xori	zero,zero,4234
   42194:	0004229c 	xori	zero,zero,4234
   42198:	0004229c 	xori	zero,zero,4234
   4219c:	0004229c 	xori	zero,zero,4234
   421a0:	0004229c 	xori	zero,zero,4234
   421a4:	0004229c 	xori	zero,zero,4234
   421a8:	0004229c 	xori	zero,zero,4234
   421ac:	0004229c 	xori	zero,zero,4234
   421b0:	0004229c 	xori	zero,zero,4234
   421b4:	0004229c 	xori	zero,zero,4234
   421b8:	0004226c 	andhi	zero,zero,4233
   421bc:	00042284 	movi	zero,4234
   421c0:	00042234 	movhi	zero,4232
   421c4:	0004223c 	xorhi	zero,zero,4232
   421c8:	00042248 	cmpgei	zero,zero,4233
   421cc:	00042254 	movui	zero,4233
   421d0:	00042260 	cmpeqi	zero,zero,4233
   421d4:	00042278 	rdprs	zero,zero,4233
   421d8:	0004229c 	xori	zero,zero,4234
   421dc:	0004229c 	xori	zero,zero,4234
   421e0:	0004229c 	xori	zero,zero,4234
   421e4:	0004229c 	xori	zero,zero,4234
   421e8:	0004229c 	xori	zero,zero,4234
   421ec:	0004229c 	xori	zero,zero,4234
   421f0:	0004229c 	xori	zero,zero,4234
   421f4:	00042290 	cmplti	zero,zero,4234
      // i *think* means the null-terminated character is reached
      case 0: printf("End of song!\n"); payload.endofsong = TRUE; return payload;
   421f8:	01000134 	movhi	r4,4
   421fc:	211ceb04 	addi	r4,r4,29612
   42200:	0043f800 	call	43f80 <puts>
   42204:	00800044 	movi	r2,1
   42208:	e0bffe15 	stw	r2,-8(fp)
   4220c:	e0bfff17 	ldw	r2,-4(fp)
   42210:	e0fffb17 	ldw	r3,-20(fp)
   42214:	10c00015 	stw	r3,0(r2)
   42218:	e0fffc17 	ldw	r3,-16(fp)
   4221c:	10c00115 	stw	r3,4(r2)
   42220:	e0fffd17 	ldw	r3,-12(fp)
   42224:	10c00215 	stw	r3,8(r2)
   42228:	e0fffe17 	ldw	r3,-8(fp)
   4222c:	10c00315 	stw	r3,12(r2)
   42230:	0000ae06 	br	424ec <nextSongNote+0x6a0>
      case 'C': case 'c': note = 0; break;
   42234:	e03ff515 	stw	zero,-44(fp)
   42238:	00001806 	br	4229c <nextSongNote+0x450>
      case 'D': case 'd': note = 2; break;
   4223c:	00800084 	movi	r2,2
   42240:	e0bff515 	stw	r2,-44(fp)
   42244:	00001506 	br	4229c <nextSongNote+0x450>
      case 'E': case 'e': note = 4; break;
   42248:	00800104 	movi	r2,4
   4224c:	e0bff515 	stw	r2,-44(fp)
   42250:	00001206 	br	4229c <nextSongNote+0x450>
      case 'F': case 'f': note = 5; break;
   42254:	00800144 	movi	r2,5
   42258:	e0bff515 	stw	r2,-44(fp)
   4225c:	00000f06 	br	4229c <nextSongNote+0x450>
      case 'G': case 'g': note = 7; break;
   42260:	008001c4 	movi	r2,7
   42264:	e0bff515 	stw	r2,-44(fp)
   42268:	00000c06 	br	4229c <nextSongNote+0x450>
      case 'A': case 'a': note = 9; break;
   4226c:	00800244 	movi	r2,9
   42270:	e0bff515 	stw	r2,-44(fp)
   42274:	00000906 	br	4229c <nextSongNote+0x450>
      case 'H': case 'h': note = 11; break;
   42278:	008002c4 	movi	r2,11
   4227c:	e0bff515 	stw	r2,-44(fp)
   42280:	00000606 	br	4229c <nextSongNote+0x450>
      case 'B': case 'b': note = 11; break;
   42284:	008002c4 	movi	r2,11
   42288:	e0bff515 	stw	r2,-44(fp)
   4228c:	00000306 	br	4229c <nextSongNote+0x450>
      case 'P': case 'p': note = -1; break;
   42290:	00bfffc4 	movi	r2,-1
   42294:	e0bff515 	stw	r2,-44(fp)
   42298:	0001883a 	nop
    }

    // this info is picked up for the LED piano module
    payload.letter = *p;
   4229c:	d0a0fb17 	ldw	r2,-31764(gp)
   422a0:	10800003 	ldbu	r2,0(r2)
   422a4:	e0bffb05 	stb	r2,-20(fp)

    p++;
   422a8:	d0a0fb17 	ldw	r2,-31764(gp)
   422ac:	10800044 	addi	r2,r2,1
   422b0:	d0a0fb15 	stw	r2,-31764(gp)
    if (*p == '#') {
   422b4:	d0a0fb17 	ldw	r2,-31764(gp)
   422b8:	10800003 	ldbu	r2,0(r2)
   422bc:	10803fcc 	andi	r2,r2,255
   422c0:	1080201c 	xori	r2,r2,128
   422c4:	10bfe004 	addi	r2,r2,-128
   422c8:	108008d8 	cmpnei	r2,r2,35
   422cc:	1000061e 	bne	r2,zero,422e8 <nextSongNote+0x49c>
      note++;
   422d0:	e0bff517 	ldw	r2,-44(fp)
   422d4:	10800044 	addi	r2,r2,1
   422d8:	e0bff515 	stw	r2,-44(fp)
      p++;
   422dc:	d0a0fb17 	ldw	r2,-31764(gp)
   422e0:	10800044 	addi	r2,r2,1
   422e4:	d0a0fb15 	stw	r2,-31764(gp)
    }
    if (*p == 'b') {
   422e8:	d0a0fb17 	ldw	r2,-31764(gp)
   422ec:	10800003 	ldbu	r2,0(r2)
   422f0:	10803fcc 	andi	r2,r2,255
   422f4:	1080201c 	xori	r2,r2,128
   422f8:	10bfe004 	addi	r2,r2,-128
   422fc:	10801898 	cmpnei	r2,r2,98
   42300:	1000061e 	bne	r2,zero,4231c <nextSongNote+0x4d0>
      note--;
   42304:	e0bff517 	ldw	r2,-44(fp)
   42308:	10bfffc4 	addi	r2,r2,-1
   4230c:	e0bff515 	stw	r2,-44(fp)
      p++;
   42310:	d0a0fb17 	ldw	r2,-31764(gp)
   42314:	10800044 	addi	r2,r2,1
   42318:	d0a0fb15 	stw	r2,-31764(gp)
    }

    // Parse special duration
    if (*p == '.') {
   4231c:	d0a0fb17 	ldw	r2,-31764(gp)
   42320:	10800003 	ldbu	r2,0(r2)
   42324:	10803fcc 	andi	r2,r2,255
   42328:	1080201c 	xori	r2,r2,128
   4232c:	10bfe004 	addi	r2,r2,-128
   42330:	10800b98 	cmpnei	r2,r2,46
   42334:	10000b1e 	bne	r2,zero,42364 <nextSongNote+0x518>
      dur += dur / 2;
   42338:	e0bff717 	ldw	r2,-36(fp)
   4233c:	1006d7fa 	srli	r3,r2,31
   42340:	1885883a 	add	r2,r3,r2
   42344:	1005d07a 	srai	r2,r2,1
   42348:	1007883a 	mov	r3,r2
   4234c:	e0bff717 	ldw	r2,-36(fp)
   42350:	10c5883a 	add	r2,r2,r3
   42354:	e0bff715 	stw	r2,-36(fp)
      p++;
   42358:	d0a0fb17 	ldw	r2,-31764(gp)
   4235c:	10800044 	addi	r2,r2,1
   42360:	d0a0fb15 	stw	r2,-31764(gp)
    }

    // Parse scale
    if (*p >= '0' && *p <= '9') scale = (*p++ - '0');
   42364:	d0a0fb17 	ldw	r2,-31764(gp)
   42368:	10800003 	ldbu	r2,0(r2)
   4236c:	10803fcc 	andi	r2,r2,255
   42370:	1080201c 	xori	r2,r2,128
   42374:	10bfe004 	addi	r2,r2,-128
   42378:	10800c10 	cmplti	r2,r2,48
   4237c:	1000101e 	bne	r2,zero,423c0 <nextSongNote+0x574>
   42380:	d0a0fb17 	ldw	r2,-31764(gp)
   42384:	10800003 	ldbu	r2,0(r2)
   42388:	10803fcc 	andi	r2,r2,255
   4238c:	1080201c 	xori	r2,r2,128
   42390:	10bfe004 	addi	r2,r2,-128
   42394:	10800e88 	cmpgei	r2,r2,58
   42398:	1000091e 	bne	r2,zero,423c0 <nextSongNote+0x574>
   4239c:	d0a0fb17 	ldw	r2,-31764(gp)
   423a0:	10c00044 	addi	r3,r2,1
   423a4:	d0e0fb15 	stw	r3,-31764(gp)
   423a8:	10800003 	ldbu	r2,0(r2)
   423ac:	10803fcc 	andi	r2,r2,255
   423b0:	1080201c 	xori	r2,r2,128
   423b4:	10bfe004 	addi	r2,r2,-128
   423b8:	10bff404 	addi	r2,r2,-48
   423bc:	e0bff615 	stw	r2,-40(fp)

    // Parse special duration (again...)
    if (*p == '.') {
   423c0:	d0a0fb17 	ldw	r2,-31764(gp)
   423c4:	10800003 	ldbu	r2,0(r2)
   423c8:	10803fcc 	andi	r2,r2,255
   423cc:	1080201c 	xori	r2,r2,128
   423d0:	10bfe004 	addi	r2,r2,-128
   423d4:	10800b98 	cmpnei	r2,r2,46
   423d8:	10000f1e 	bne	r2,zero,42418 <nextSongNote+0x5cc>
      dur += dur / 2;
   423dc:	e0bff717 	ldw	r2,-36(fp)
   423e0:	1006d7fa 	srli	r3,r2,31
   423e4:	1885883a 	add	r2,r3,r2
   423e8:	1005d07a 	srai	r2,r2,1
   423ec:	1007883a 	mov	r3,r2
   423f0:	e0bff717 	ldw	r2,-36(fp)
   423f4:	10c5883a 	add	r2,r2,r3
   423f8:	e0bff715 	stw	r2,-36(fp)
      p++;
   423fc:	d0a0fb17 	ldw	r2,-31764(gp)
   42400:	10800044 	addi	r2,r2,1
   42404:	d0a0fb15 	stw	r2,-31764(gp)
    }

    // Skip delimiter
    while (*p == ' ') p++;
   42408:	00000306 	br	42418 <nextSongNote+0x5cc>
   4240c:	d0a0fb17 	ldw	r2,-31764(gp)
   42410:	10800044 	addi	r2,r2,1
   42414:	d0a0fb15 	stw	r2,-31764(gp)
   42418:	d0a0fb17 	ldw	r2,-31764(gp)
   4241c:	10800003 	ldbu	r2,0(r2)
   42420:	10803fcc 	andi	r2,r2,255
   42424:	1080201c 	xori	r2,r2,128
   42428:	10bfe004 	addi	r2,r2,-128
   4242c:	10800820 	cmpeqi	r2,r2,32
   42430:	103ff61e 	bne	r2,zero,4240c <__alt_data_end+0xfffda40c>
    if (*p == ',') p++;
   42434:	d0a0fb17 	ldw	r2,-31764(gp)
   42438:	10800003 	ldbu	r2,0(r2)
   4243c:	10803fcc 	andi	r2,r2,255
   42440:	1080201c 	xori	r2,r2,128
   42444:	10bfe004 	addi	r2,r2,-128
   42448:	10800b18 	cmpnei	r2,r2,44
   4244c:	1000031e 	bne	r2,zero,4245c <nextSongNote+0x610>
   42450:	d0a0fb17 	ldw	r2,-31764(gp)
   42454:	10800044 	addi	r2,r2,1
   42458:	d0a0fb15 	stw	r2,-31764(gp)

    // Play note
    ms = dur * 60000 / (bpm * 8);
   4245c:	e0fff717 	ldw	r3,-36(fp)
   42460:	00ba9814 	movui	r2,60000
   42464:	1887383a 	mul	r3,r3,r2
   42468:	d0a00317 	ldw	r2,-32756(gp)
   4246c:	100490fa 	slli	r2,r2,3
   42470:	100b883a 	mov	r5,r2
   42474:	1809883a 	mov	r4,r3
   42478:	00431640 	call	43164 <__divsi3>
   4247c:	e0bffa15 	stw	r2,-24(fp)
    if (note == -1) {
   42480:	e0bff517 	ldw	r2,-44(fp)
   42484:	10bfffd8 	cmpnei	r2,r2,-1
   42488:	1000021e 	bne	r2,zero,42494 <nextSongNote+0x648>
      freq = 0;
   4248c:	e03ff815 	stw	zero,-32(fp)
   42490:	00000806 	br	424b4 <nextSongNote+0x668>
    } else {
      freq = note2freq((scale + 1) * 12 + note);
   42494:	e0bff617 	ldw	r2,-40(fp)
   42498:	10800044 	addi	r2,r2,1
   4249c:	10c00324 	muli	r3,r2,12
   424a0:	e0bff517 	ldw	r2,-44(fp)
   424a4:	1885883a 	add	r2,r3,r2
   424a8:	1009883a 	mov	r4,r2
   424ac:	0041b080 	call	41b08 <note2freq>
   424b0:	e0bff815 	stw	r2,-32(fp)
    }


    payload.frequency = freq;
   424b4:	e0bff817 	ldw	r2,-32(fp)
   424b8:	e0bffc15 	stw	r2,-16(fp)
    payload.duration = ms;
   424bc:	e0bffa17 	ldw	r2,-24(fp)
   424c0:	e0bffd15 	stw	r2,-12(fp)
    payload.endofsong = FALSE;
   424c4:	e03ffe15 	stw	zero,-8(fp)
    
    return payload;   
   424c8:	e0bfff17 	ldw	r2,-4(fp)
   424cc:	e0fffb17 	ldw	r3,-20(fp)
   424d0:	10c00015 	stw	r3,0(r2)
   424d4:	e0fffc17 	ldw	r3,-16(fp)
   424d8:	10c00115 	stw	r3,4(r2)
   424dc:	e0fffd17 	ldw	r3,-12(fp)
   424e0:	10c00215 	stw	r3,8(r2)
   424e4:	e0fffe17 	ldw	r3,-8(fp)
   424e8:	10c00315 	stw	r3,12(r2)
    
  }
   424ec:	e0bfff17 	ldw	r2,-4(fp)
   424f0:	e037883a 	mov	sp,fp
   424f4:	dfc00117 	ldw	ra,4(sp)
   424f8:	df000017 	ldw	fp,0(sp)
   424fc:	dec00204 	addi	sp,sp,8
   42500:	f800283a 	ret

00042504 <determineMode>:
#include "switches.h" 

struct mode determineMode(void) {
   42504:	defff904 	addi	sp,sp,-28
   42508:	dfc00615 	stw	ra,24(sp)
   4250c:	df000515 	stw	fp,20(sp)
   42510:	dc400415 	stw	r17,16(sp)
   42514:	dc000315 	stw	r16,12(sp)
   42518:	df000504 	addi	fp,sp,20
  ISR, the current mode is known allowing us to determine if an 
  invalid mode was requested */
  static struct mode mode;

  // this variable lets us test whether or not an invalid mode was requested
  volatile uint16_t switches_state_request = IORD_ALTERA_AVALON_PIO_DATA(SWITCHES_BASE);
   4251c:	00800234 	movhi	r2,8
   42520:	10843804 	addi	r2,r2,4320
   42524:	10800037 	ldwio	r2,0(r2)
   42528:	e0bffd0d 	sth	r2,-12(fp)

  // check if the request is invalid
  if (checkInvalidMode(switches_state_request) == INVALID) {
   4252c:	e0bffd0b 	ldhu	r2,-12(fp)
   42530:	10bfffcc 	andi	r2,r2,65535
   42534:	1009883a 	mov	r4,r2
   42538:	00427800 	call	42780 <checkInvalidMode>
   4253c:	10803fcc 	andi	r2,r2,255
   42540:	10800058 	cmpnei	r2,r2,1
   42544:	10000f1e 	bne	r2,zero,42584 <determineMode+0x80>
    mode.invalid = TRUE;
   42548:	00800044 	movi	r2,1
   4254c:	d0a0fc05 	stb	r2,-31760(gp)
    return mode;
   42550:	d0a0fc03 	ldbu	r2,-31760(gp)
   42554:	e0bffb45 	stb	r2,-19(fp)
   42558:	d0a0fc43 	ldbu	r2,-31759(gp)
   4255c:	e0bffb85 	stb	r2,-18(fp)
   42560:	d0a0fc83 	ldbu	r2,-31758(gp)
   42564:	e0bffbc5 	stb	r2,-17(fp)
   42568:	d0a0fcc3 	ldbu	r2,-31757(gp)
   4256c:	e0bffc05 	stb	r2,-16(fp)
   42570:	d0a0fd03 	ldbu	r2,-31756(gp)
   42574:	e0bffc45 	stb	r2,-15(fp)
   42578:	d0a0fd43 	ldbu	r2,-31755(gp)
   4257c:	e0bffc85 	stb	r2,-14(fp)
   42580:	00004906 	br	426a8 <determineMode+0x1a4>
  }

  else {
    // now that we know the mode request is valid, let's determine what it is
    mode.invalid = FALSE;
   42584:	d020fc05 	stb	zero,-31760(gp)

    uint8_t i = 0;
   42588:	e03ffb05 	stb	zero,-20(fp)

    // check for the valid mode request in lookup table
    while (switches_state_request != mode_lookup_table[i][0]) {
   4258c:	00000606 	br	425a8 <determineMode+0xa4>
      i++;
   42590:	e0bffb03 	ldbu	r2,-20(fp)
   42594:	10800044 	addi	r2,r2,1
   42598:	e0bffb05 	stb	r2,-20(fp)
      // catch error in case the bounds of the lookup table are exceeded
      if (i == NUM_VALID_MODES) {
   4259c:	e0bffb03 	ldbu	r2,-20(fp)
   425a0:	10800218 	cmpnei	r2,r2,8
   425a4:	10000b26 	beq	r2,zero,425d4 <determineMode+0xd0>
    mode.invalid = FALSE;

    uint8_t i = 0;

    // check for the valid mode request in lookup table
    while (switches_state_request != mode_lookup_table[i][0]) {
   425a8:	e0fffb03 	ldbu	r3,-20(fp)
   425ac:	00800134 	movhi	r2,4
   425b0:	109cfa84 	addi	r2,r2,29674
   425b4:	18c00324 	muli	r3,r3,12
   425b8:	10c5883a 	add	r2,r2,r3
   425bc:	10c0000b 	ldhu	r3,0(r2)
   425c0:	e0bffd0b 	ldhu	r2,-12(fp)
   425c4:	18ffffcc 	andi	r3,r3,65535
   425c8:	10bfffcc 	andi	r2,r2,65535
   425cc:	18bff01e 	bne	r3,r2,42590 <__alt_data_end+0xfffda590>
   425d0:	00000106 	br	425d8 <determineMode+0xd4>
      i++;
      // catch error in case the bounds of the lookup table are exceeded
      if (i == NUM_VALID_MODES) {
        break;
   425d4:	0001883a 	nop
    }

    // once the valid mode request is find, the while loop ends and we have found
    // the correct mode; its location is determined by the index i
    // at this point, we can update the members of the mode struct
    mode.display = mode_lookup_table[i][1];
   425d8:	e0fffb03 	ldbu	r3,-20(fp)
   425dc:	00800134 	movhi	r2,4
   425e0:	109cfa84 	addi	r2,r2,29674
   425e4:	18c00324 	muli	r3,r3,12
   425e8:	10c5883a 	add	r2,r2,r3
   425ec:	10800084 	addi	r2,r2,2
   425f0:	1080000b 	ldhu	r2,0(r2)
   425f4:	d0a0fc45 	stb	r2,-31759(gp)
    mode.config.on = mode_lookup_table[i][2];
   425f8:	e0fffb03 	ldbu	r3,-20(fp)
   425fc:	00800134 	movhi	r2,4
   42600:	109cfa84 	addi	r2,r2,29674
   42604:	18c00324 	muli	r3,r3,12
   42608:	10c5883a 	add	r2,r2,r3
   4260c:	10800104 	addi	r2,r2,4
   42610:	1080000b 	ldhu	r2,0(r2)
   42614:	d0a0fcc5 	stb	r2,-31757(gp)
    mode.config.hour = mode_lookup_table[i][3];
   42618:	e0fffb03 	ldbu	r3,-20(fp)
   4261c:	00800134 	movhi	r2,4
   42620:	109cfa84 	addi	r2,r2,29674
   42624:	18c00324 	muli	r3,r3,12
   42628:	10c5883a 	add	r2,r2,r3
   4262c:	10800184 	addi	r2,r2,6
   42630:	1080000b 	ldhu	r2,0(r2)
   42634:	d0a0fd05 	stb	r2,-31756(gp)
    mode.config.minute = mode_lookup_table[i][4];
   42638:	e0fffb03 	ldbu	r3,-20(fp)
   4263c:	00800134 	movhi	r2,4
   42640:	109cfa84 	addi	r2,r2,29674
   42644:	18c00324 	muli	r3,r3,12
   42648:	10c5883a 	add	r2,r2,r3
   4264c:	10800204 	addi	r2,r2,8
   42650:	1080000b 	ldhu	r2,0(r2)
   42654:	d0a0fd45 	stb	r2,-31755(gp)
    mode.alarm = mode_lookup_table[i][5];
   42658:	e0fffb03 	ldbu	r3,-20(fp)
   4265c:	00800134 	movhi	r2,4
   42660:	109cfa84 	addi	r2,r2,29674
   42664:	18c00324 	muli	r3,r3,12
   42668:	10c5883a 	add	r2,r2,r3
   4266c:	10800284 	addi	r2,r2,10
   42670:	1080000b 	ldhu	r2,0(r2)
   42674:	d0a0fc85 	stb	r2,-31758(gp)

    return mode;
   42678:	d0a0fc03 	ldbu	r2,-31760(gp)
   4267c:	e0bffb45 	stb	r2,-19(fp)
   42680:	d0a0fc43 	ldbu	r2,-31759(gp)
   42684:	e0bffb85 	stb	r2,-18(fp)
   42688:	d0a0fc83 	ldbu	r2,-31758(gp)
   4268c:	e0bffbc5 	stb	r2,-17(fp)
   42690:	d0a0fcc3 	ldbu	r2,-31757(gp)
   42694:	e0bffc05 	stb	r2,-16(fp)
   42698:	d0a0fd03 	ldbu	r2,-31756(gp)
   4269c:	e0bffc45 	stb	r2,-15(fp)
   426a0:	d0a0fd43 	ldbu	r2,-31755(gp)
   426a4:	e0bffc85 	stb	r2,-14(fp)
   426a8:	0005883a 	mov	r2,zero
   426ac:	e0fffb43 	ldbu	r3,-19(fp)
   426b0:	18c03fcc 	andi	r3,r3,255
   426b4:	013fc004 	movi	r4,-256
   426b8:	1104703a 	and	r2,r2,r4
   426bc:	10c4b03a 	or	r2,r2,r3
   426c0:	e0fffb83 	ldbu	r3,-18(fp)
   426c4:	18c03fcc 	andi	r3,r3,255
   426c8:	1808923a 	slli	r4,r3,8
   426cc:	00fffff4 	movhi	r3,65535
   426d0:	18c03fc4 	addi	r3,r3,255
   426d4:	10c4703a 	and	r2,r2,r3
   426d8:	1104b03a 	or	r2,r2,r4
   426dc:	e0fffbc3 	ldbu	r3,-17(fp)
   426e0:	18c03fcc 	andi	r3,r3,255
   426e4:	1808943a 	slli	r4,r3,16
   426e8:	00ffc074 	movhi	r3,65281
   426ec:	18ffffc4 	addi	r3,r3,-1
   426f0:	10c4703a 	and	r2,r2,r3
   426f4:	1104b03a 	or	r2,r2,r4
   426f8:	e0fffc03 	ldbu	r3,-16(fp)
   426fc:	1808963a 	slli	r4,r3,24
   42700:	00c04034 	movhi	r3,256
   42704:	18ffffc4 	addi	r3,r3,-1
   42708:	10c4703a 	and	r2,r2,r3
   4270c:	1104b03a 	or	r2,r2,r4
   42710:	0009883a 	mov	r4,zero
   42714:	e0fffc43 	ldbu	r3,-15(fp)
   42718:	18c03fcc 	andi	r3,r3,255
   4271c:	017fc004 	movi	r5,-256
   42720:	2148703a 	and	r4,r4,r5
   42724:	20c6b03a 	or	r3,r4,r3
   42728:	1809883a 	mov	r4,r3
   4272c:	e0fffc83 	ldbu	r3,-14(fp)
   42730:	18c03fcc 	andi	r3,r3,255
   42734:	180a923a 	slli	r5,r3,8
   42738:	00fffff4 	movhi	r3,65535
   4273c:	18c03fc4 	addi	r3,r3,255
   42740:	20c6703a 	and	r3,r4,r3
   42744:	1946b03a 	or	r3,r3,r5
   42748:	1809883a 	mov	r4,r3
   4274c:	1021883a 	mov	r16,r2
   42750:	2023883a 	mov	r17,r4
   42754:	8007883a 	mov	r3,r16
   42758:	8809883a 	mov	r4,r17
  }

}
   4275c:	1805883a 	mov	r2,r3
   42760:	2007883a 	mov	r3,r4
   42764:	e6fffe04 	addi	sp,fp,-8
   42768:	dfc00317 	ldw	ra,12(sp)
   4276c:	df000217 	ldw	fp,8(sp)
   42770:	dc400117 	ldw	r17,4(sp)
   42774:	dc000017 	ldw	r16,0(sp)
   42778:	dec00404 	addi	sp,sp,16
   4277c:	f800283a 	ret

00042780 <checkInvalidMode>:

uint8_t checkInvalidMode(uint16_t switches_state_request) {
   42780:	defffc04 	addi	sp,sp,-16
   42784:	dfc00315 	stw	ra,12(sp)
   42788:	df000215 	stw	fp,8(sp)
   4278c:	df000204 	addi	fp,sp,8
   42790:	2005883a 	mov	r2,r4
   42794:	e0bfff0d 	sth	r2,-4(fp)
  // check if an unused switch was turned on
  uint8_t i = 0;
   42798:	e03ffe05 	stb	zero,-8(fp)

  do {
    // if the entire array of unused_switches was searched but an
    // unused switch was not activated, then exit while loop
    if (i == NUM_UNUSED_SWITCHES) {
   4279c:	e0bffe03 	ldbu	r2,-8(fp)
   427a0:	108000d8 	cmpnei	r2,r2,3
   427a4:	10000e26 	beq	r2,zero,427e0 <checkInvalidMode+0x60>
      break;
    }
    // if an unused switch was activated, exit function and indicate that
    // an invalid mode was selected
    else if (switches_state_request == unused_switches[i]) {
   427a8:	e0bffe03 	ldbu	r2,-8(fp)
   427ac:	1087883a 	add	r3,r2,r2
   427b0:	d0a00404 	addi	r2,gp,-32752
   427b4:	1885883a 	add	r2,r3,r2
   427b8:	1080000b 	ldhu	r2,0(r2)
   427bc:	10ffffcc 	andi	r3,r2,65535
   427c0:	e0bfff0b 	ldhu	r2,-4(fp)
   427c4:	1880021e 	bne	r3,r2,427d0 <checkInvalidMode+0x50>
      return INVALID;
   427c8:	00800044 	movi	r2,1
   427cc:	00000e06 	br	42808 <checkInvalidMode+0x88>
    }

    // increment index of unused_switches array
    i++;
   427d0:	e0bffe03 	ldbu	r2,-8(fp)
   427d4:	10800044 	addi	r2,r2,1
   427d8:	e0bffe05 	stb	r2,-8(fp)

  } while(1);
   427dc:	003fef06 	br	4279c <__alt_data_end+0xfffda79c>

  do {
    // if the entire array of unused_switches was searched but an
    // unused switch was not activated, then exit while loop
    if (i == NUM_UNUSED_SWITCHES) {
      break;
   427e0:	0001883a 	nop

  } while(1);

  // now that we know an unused switch is not activated, we need to verify that 
  // the used switches are in a valid configuration
  if ( isPowerOfTwoOrZero(switches_state_request) == TRUE ) {
   427e4:	e0bfff0b 	ldhu	r2,-4(fp)
   427e8:	1009883a 	mov	r4,r2
   427ec:	004281c0 	call	4281c <isPowerOfTwoOrZero>
   427f0:	10803fcc 	andi	r2,r2,255
   427f4:	10800058 	cmpnei	r2,r2,1
   427f8:	1000021e 	bne	r2,zero,42804 <checkInvalidMode+0x84>
    return VALID;
   427fc:	0005883a 	mov	r2,zero
   42800:	00000106 	br	42808 <checkInvalidMode+0x88>
  }

  else {
    return INVALID;
   42804:	00800044 	movi	r2,1
  }
}
   42808:	e037883a 	mov	sp,fp
   4280c:	dfc00117 	ldw	ra,4(sp)
   42810:	df000017 	ldw	fp,0(sp)
   42814:	dec00204 	addi	sp,sp,8
   42818:	f800283a 	ret

0004281c <isPowerOfTwoOrZero>:
6 & 5  != 0 -> invalid!
7 & 6  != 0 -> invalid!
---------------------------------------------
*/ 

uint8_t isPowerOfTwoOrZero(uint16_t value) {
   4281c:	defffe04 	addi	sp,sp,-8
   42820:	df000115 	stw	fp,4(sp)
   42824:	df000104 	addi	fp,sp,4
   42828:	2005883a 	mov	r2,r4
   4282c:	e0bfff0d 	sth	r2,-4(fp)
  if ((value & (value-1)) == 0) {
   42830:	e0ffff0b 	ldhu	r3,-4(fp)
   42834:	e0bfff0b 	ldhu	r2,-4(fp)
   42838:	10bfffc4 	addi	r2,r2,-1
   4283c:	1884703a 	and	r2,r3,r2
   42840:	1000021e 	bne	r2,zero,4284c <isPowerOfTwoOrZero+0x30>
    return TRUE;
   42844:	00800044 	movi	r2,1
   42848:	00000106 	br	42850 <isPowerOfTwoOrZero+0x34>
  }
  else {
    return FALSE;
   4284c:	0005883a 	mov	r2,zero
  }
   42850:	e037883a 	mov	sp,fp
   42854:	df000017 	ldw	fp,0(sp)
   42858:	dec00104 	addi	sp,sp,4
   4285c:	f800283a 	ret

00042860 <resetClockTime>:


/* ------------------------ CLOCK functions ---------------------- */

// initialize clock time to default time (see display.h)
void resetClockTime(void) {
   42860:	deffff04 	addi	sp,sp,-4
   42864:	df000015 	stw	fp,0(sp)
   42868:	d839883a 	mov	fp,sp
  clock.hour = reset_clock_value[0];
   4286c:	008002c4 	movi	r2,11
   42870:	d0a0fe45 	stb	r2,-31751(gp)
  clock.minute = reset_clock_value[1];
   42874:	00800ec4 	movi	r2,59
   42878:	d0a0fe85 	stb	r2,-31750(gp)
  clock.second = reset_clock_value[2];
   4287c:	0005883a 	mov	r2,zero
   42880:	d0a0fec5 	stb	r2,-31749(gp)
}
   42884:	0001883a 	nop
   42888:	e037883a 	mov	sp,fp
   4288c:	df000017 	ldw	fp,0(sp)
   42890:	dec00104 	addi	sp,sp,4
   42894:	f800283a 	ret

00042898 <getClockTime>:

struct time getClockTime(void) {
   42898:	defffe04 	addi	sp,sp,-8
   4289c:	df000115 	stw	fp,4(sp)
   428a0:	df000104 	addi	fp,sp,4
  return clock;
   428a4:	d0a0fe43 	ldbu	r2,-31751(gp)
   428a8:	e0bfff05 	stb	r2,-4(fp)
   428ac:	d0a0fe83 	ldbu	r2,-31750(gp)
   428b0:	e0bfff45 	stb	r2,-3(fp)
   428b4:	d0a0fec3 	ldbu	r2,-31749(gp)
   428b8:	e0bfff85 	stb	r2,-2(fp)
   428bc:	0005883a 	mov	r2,zero
   428c0:	e0ffff03 	ldbu	r3,-4(fp)
   428c4:	18c03fcc 	andi	r3,r3,255
   428c8:	013fc004 	movi	r4,-256
   428cc:	1104703a 	and	r2,r2,r4
   428d0:	10c4b03a 	or	r2,r2,r3
   428d4:	e0ffff43 	ldbu	r3,-3(fp)
   428d8:	18c03fcc 	andi	r3,r3,255
   428dc:	1808923a 	slli	r4,r3,8
   428e0:	00fffff4 	movhi	r3,65535
   428e4:	18c03fc4 	addi	r3,r3,255
   428e8:	10c4703a 	and	r2,r2,r3
   428ec:	1104b03a 	or	r2,r2,r4
   428f0:	e0ffff83 	ldbu	r3,-2(fp)
   428f4:	18c03fcc 	andi	r3,r3,255
   428f8:	1808943a 	slli	r4,r3,16
   428fc:	00ffc074 	movhi	r3,65281
   42900:	18ffffc4 	addi	r3,r3,-1
   42904:	10c4703a 	and	r2,r2,r3
   42908:	1104b03a 	or	r2,r2,r4
}
   4290c:	e037883a 	mov	sp,fp
   42910:	df000017 	ldw	fp,0(sp)
   42914:	dec00104 	addi	sp,sp,4
   42918:	f800283a 	ret

0004291c <upClockSecond>:

/*--------- up operations -------*/

// SECONDS
struct time upClockSecond(uint8_t carry_setting) {
   4291c:	defffc04 	addi	sp,sp,-16
   42920:	dfc00315 	stw	ra,12(sp)
   42924:	df000215 	stw	fp,8(sp)
   42928:	df000204 	addi	fp,sp,8
   4292c:	2005883a 	mov	r2,r4
   42930:	e0bfff05 	stb	r2,-4(fp)
  if (clock.second == (ONE_MINUTE-1)) {
   42934:	d0a0fec3 	ldbu	r2,-31749(gp)
   42938:	10803fcc 	andi	r2,r2,255
   4293c:	10800ed8 	cmpnei	r2,r2,59
   42940:	1000071e 	bne	r2,zero,42960 <upClockSecond+0x44>
    clock.second = 0;
   42944:	d020fec5 	stb	zero,-31749(gp)
    
    if (carry_setting == CARRY_ON) {
   42948:	e0bfff03 	ldbu	r2,-4(fp)
   4294c:	10800058 	cmpnei	r2,r2,1
   42950:	1000061e 	bne	r2,zero,4296c <upClockSecond+0x50>
      upClockMinute(CARRY_ON);
   42954:	01000044 	movi	r4,1
   42958:	00429e80 	call	429e8 <upClockMinute>
   4295c:	00000306 	br	4296c <upClockSecond+0x50>
    }
  }
  else {
    clock.second++;
   42960:	d0a0fec3 	ldbu	r2,-31749(gp)
   42964:	10800044 	addi	r2,r2,1
   42968:	d0a0fec5 	stb	r2,-31749(gp)
  }
  return clock;
   4296c:	d0a0fe43 	ldbu	r2,-31751(gp)
   42970:	e0bffe05 	stb	r2,-8(fp)
   42974:	d0a0fe83 	ldbu	r2,-31750(gp)
   42978:	e0bffe45 	stb	r2,-7(fp)
   4297c:	d0a0fec3 	ldbu	r2,-31749(gp)
   42980:	e0bffe85 	stb	r2,-6(fp)
   42984:	0005883a 	mov	r2,zero
   42988:	e0fffe03 	ldbu	r3,-8(fp)
   4298c:	18c03fcc 	andi	r3,r3,255
   42990:	013fc004 	movi	r4,-256
   42994:	1104703a 	and	r2,r2,r4
   42998:	10c4b03a 	or	r2,r2,r3
   4299c:	e0fffe43 	ldbu	r3,-7(fp)
   429a0:	18c03fcc 	andi	r3,r3,255
   429a4:	1808923a 	slli	r4,r3,8
   429a8:	00fffff4 	movhi	r3,65535
   429ac:	18c03fc4 	addi	r3,r3,255
   429b0:	10c4703a 	and	r2,r2,r3
   429b4:	1104b03a 	or	r2,r2,r4
   429b8:	e0fffe83 	ldbu	r3,-6(fp)
   429bc:	18c03fcc 	andi	r3,r3,255
   429c0:	1808943a 	slli	r4,r3,16
   429c4:	00ffc074 	movhi	r3,65281
   429c8:	18ffffc4 	addi	r3,r3,-1
   429cc:	10c4703a 	and	r2,r2,r3
   429d0:	1104b03a 	or	r2,r2,r4
}
   429d4:	e037883a 	mov	sp,fp
   429d8:	dfc00117 	ldw	ra,4(sp)
   429dc:	df000017 	ldw	fp,0(sp)
   429e0:	dec00204 	addi	sp,sp,8
   429e4:	f800283a 	ret

000429e8 <upClockMinute>:

// MINUTES
struct time upClockMinute(uint8_t carry_setting) {
   429e8:	defffc04 	addi	sp,sp,-16
   429ec:	dfc00315 	stw	ra,12(sp)
   429f0:	df000215 	stw	fp,8(sp)
   429f4:	df000204 	addi	fp,sp,8
   429f8:	2005883a 	mov	r2,r4
   429fc:	e0bfff05 	stb	r2,-4(fp)
  if (clock.minute == (ONE_HOUR-1)) {
   42a00:	d0a0fe83 	ldbu	r2,-31750(gp)
   42a04:	10803fcc 	andi	r2,r2,255
   42a08:	10800ed8 	cmpnei	r2,r2,59
   42a0c:	1000061e 	bne	r2,zero,42a28 <upClockMinute+0x40>
    clock.minute = 0;
   42a10:	d020fe85 	stb	zero,-31750(gp)
    
    if (carry_setting == CARRY_ON) {
   42a14:	e0bfff03 	ldbu	r2,-4(fp)
   42a18:	10800058 	cmpnei	r2,r2,1
   42a1c:	1000051e 	bne	r2,zero,42a34 <upClockMinute+0x4c>
      upClockHour();
   42a20:	0042ab00 	call	42ab0 <upClockHour>
   42a24:	00000306 	br	42a34 <upClockMinute+0x4c>
    }
  }
  else {
    clock.minute++;
   42a28:	d0a0fe83 	ldbu	r2,-31750(gp)
   42a2c:	10800044 	addi	r2,r2,1
   42a30:	d0a0fe85 	stb	r2,-31750(gp)
  }
  return clock;
   42a34:	d0a0fe43 	ldbu	r2,-31751(gp)
   42a38:	e0bffe05 	stb	r2,-8(fp)
   42a3c:	d0a0fe83 	ldbu	r2,-31750(gp)
   42a40:	e0bffe45 	stb	r2,-7(fp)
   42a44:	d0a0fec3 	ldbu	r2,-31749(gp)
   42a48:	e0bffe85 	stb	r2,-6(fp)
   42a4c:	0005883a 	mov	r2,zero
   42a50:	e0fffe03 	ldbu	r3,-8(fp)
   42a54:	18c03fcc 	andi	r3,r3,255
   42a58:	013fc004 	movi	r4,-256
   42a5c:	1104703a 	and	r2,r2,r4
   42a60:	10c4b03a 	or	r2,r2,r3
   42a64:	e0fffe43 	ldbu	r3,-7(fp)
   42a68:	18c03fcc 	andi	r3,r3,255
   42a6c:	1808923a 	slli	r4,r3,8
   42a70:	00fffff4 	movhi	r3,65535
   42a74:	18c03fc4 	addi	r3,r3,255
   42a78:	10c4703a 	and	r2,r2,r3
   42a7c:	1104b03a 	or	r2,r2,r4
   42a80:	e0fffe83 	ldbu	r3,-6(fp)
   42a84:	18c03fcc 	andi	r3,r3,255
   42a88:	1808943a 	slli	r4,r3,16
   42a8c:	00ffc074 	movhi	r3,65281
   42a90:	18ffffc4 	addi	r3,r3,-1
   42a94:	10c4703a 	and	r2,r2,r3
   42a98:	1104b03a 	or	r2,r2,r4
}
   42a9c:	e037883a 	mov	sp,fp
   42aa0:	dfc00117 	ldw	ra,4(sp)
   42aa4:	df000017 	ldw	fp,0(sp)
   42aa8:	dec00204 	addi	sp,sp,8
   42aac:	f800283a 	ret

00042ab0 <upClockHour>:

// HOURS
struct time upClockHour(void) {
   42ab0:	defffe04 	addi	sp,sp,-8
   42ab4:	df000115 	stw	fp,4(sp)
   42ab8:	df000104 	addi	fp,sp,4
  if (clock.hour == (time_format-1)) {
   42abc:	d0a0fe43 	ldbu	r2,-31751(gp)
   42ac0:	10c03fcc 	andi	r3,r2,255
   42ac4:	d0a00643 	ldbu	r2,-32743(gp)
   42ac8:	10803fcc 	andi	r2,r2,255
   42acc:	10bfffc4 	addi	r2,r2,-1
   42ad0:	1880021e 	bne	r3,r2,42adc <upClockHour+0x2c>
    clock.hour = 0;
   42ad4:	d020fe45 	stb	zero,-31751(gp)
   42ad8:	00000306 	br	42ae8 <upClockHour+0x38>
  }
  else {
    clock.hour++;
   42adc:	d0a0fe43 	ldbu	r2,-31751(gp)
   42ae0:	10800044 	addi	r2,r2,1
   42ae4:	d0a0fe45 	stb	r2,-31751(gp)
  }
  return clock;
   42ae8:	d0a0fe43 	ldbu	r2,-31751(gp)
   42aec:	e0bfff05 	stb	r2,-4(fp)
   42af0:	d0a0fe83 	ldbu	r2,-31750(gp)
   42af4:	e0bfff45 	stb	r2,-3(fp)
   42af8:	d0a0fec3 	ldbu	r2,-31749(gp)
   42afc:	e0bfff85 	stb	r2,-2(fp)
   42b00:	0005883a 	mov	r2,zero
   42b04:	e0ffff03 	ldbu	r3,-4(fp)
   42b08:	18c03fcc 	andi	r3,r3,255
   42b0c:	013fc004 	movi	r4,-256
   42b10:	1104703a 	and	r2,r2,r4
   42b14:	10c4b03a 	or	r2,r2,r3
   42b18:	e0ffff43 	ldbu	r3,-3(fp)
   42b1c:	18c03fcc 	andi	r3,r3,255
   42b20:	1808923a 	slli	r4,r3,8
   42b24:	00fffff4 	movhi	r3,65535
   42b28:	18c03fc4 	addi	r3,r3,255
   42b2c:	10c4703a 	and	r2,r2,r3
   42b30:	1104b03a 	or	r2,r2,r4
   42b34:	e0ffff83 	ldbu	r3,-2(fp)
   42b38:	18c03fcc 	andi	r3,r3,255
   42b3c:	1808943a 	slli	r4,r3,16
   42b40:	00ffc074 	movhi	r3,65281
   42b44:	18ffffc4 	addi	r3,r3,-1
   42b48:	10c4703a 	and	r2,r2,r3
   42b4c:	1104b03a 	or	r2,r2,r4
}
   42b50:	e037883a 	mov	sp,fp
   42b54:	df000017 	ldw	fp,0(sp)
   42b58:	dec00104 	addi	sp,sp,4
   42b5c:	f800283a 	ret

00042b60 <downClockSecond>:

/*--------- down operations -------*/

// SECONDS
struct time downClockSecond(uint8_t carry_setting) {
   42b60:	defffc04 	addi	sp,sp,-16
   42b64:	dfc00315 	stw	ra,12(sp)
   42b68:	df000215 	stw	fp,8(sp)
   42b6c:	df000204 	addi	fp,sp,8
   42b70:	2005883a 	mov	r2,r4
   42b74:	e0bfff05 	stb	r2,-4(fp)
  if (clock.second == 0) {
   42b78:	d0a0fec3 	ldbu	r2,-31749(gp)
   42b7c:	10803fcc 	andi	r2,r2,255
   42b80:	1000081e 	bne	r2,zero,42ba4 <downClockSecond+0x44>
    clock.second = (ONE_MINUTE-1);
   42b84:	00800ec4 	movi	r2,59
   42b88:	d0a0fec5 	stb	r2,-31749(gp)
    
    if (carry_setting == CARRY_ON) {
   42b8c:	e0bfff03 	ldbu	r2,-4(fp)
   42b90:	10800058 	cmpnei	r2,r2,1
   42b94:	1000061e 	bne	r2,zero,42bb0 <downClockSecond+0x50>
      downClockMinute(CARRY_ON);
   42b98:	01000044 	movi	r4,1
   42b9c:	0042c2c0 	call	42c2c <downClockMinute>
   42ba0:	00000306 	br	42bb0 <downClockSecond+0x50>
    }
  }
  else {
    clock.second--;
   42ba4:	d0a0fec3 	ldbu	r2,-31749(gp)
   42ba8:	10bfffc4 	addi	r2,r2,-1
   42bac:	d0a0fec5 	stb	r2,-31749(gp)
  }
  return clock;
   42bb0:	d0a0fe43 	ldbu	r2,-31751(gp)
   42bb4:	e0bffe05 	stb	r2,-8(fp)
   42bb8:	d0a0fe83 	ldbu	r2,-31750(gp)
   42bbc:	e0bffe45 	stb	r2,-7(fp)
   42bc0:	d0a0fec3 	ldbu	r2,-31749(gp)
   42bc4:	e0bffe85 	stb	r2,-6(fp)
   42bc8:	0005883a 	mov	r2,zero
   42bcc:	e0fffe03 	ldbu	r3,-8(fp)
   42bd0:	18c03fcc 	andi	r3,r3,255
   42bd4:	013fc004 	movi	r4,-256
   42bd8:	1104703a 	and	r2,r2,r4
   42bdc:	10c4b03a 	or	r2,r2,r3
   42be0:	e0fffe43 	ldbu	r3,-7(fp)
   42be4:	18c03fcc 	andi	r3,r3,255
   42be8:	1808923a 	slli	r4,r3,8
   42bec:	00fffff4 	movhi	r3,65535
   42bf0:	18c03fc4 	addi	r3,r3,255
   42bf4:	10c4703a 	and	r2,r2,r3
   42bf8:	1104b03a 	or	r2,r2,r4
   42bfc:	e0fffe83 	ldbu	r3,-6(fp)
   42c00:	18c03fcc 	andi	r3,r3,255
   42c04:	1808943a 	slli	r4,r3,16
   42c08:	00ffc074 	movhi	r3,65281
   42c0c:	18ffffc4 	addi	r3,r3,-1
   42c10:	10c4703a 	and	r2,r2,r3
   42c14:	1104b03a 	or	r2,r2,r4
}
   42c18:	e037883a 	mov	sp,fp
   42c1c:	dfc00117 	ldw	ra,4(sp)
   42c20:	df000017 	ldw	fp,0(sp)
   42c24:	dec00204 	addi	sp,sp,8
   42c28:	f800283a 	ret

00042c2c <downClockMinute>:

// MINUTES
struct time downClockMinute(uint8_t carry_setting) {
   42c2c:	defffc04 	addi	sp,sp,-16
   42c30:	dfc00315 	stw	ra,12(sp)
   42c34:	df000215 	stw	fp,8(sp)
   42c38:	df000204 	addi	fp,sp,8
   42c3c:	2005883a 	mov	r2,r4
   42c40:	e0bfff05 	stb	r2,-4(fp)
  if (clock.minute == 0) {
   42c44:	d0a0fe83 	ldbu	r2,-31750(gp)
   42c48:	10803fcc 	andi	r2,r2,255
   42c4c:	1000071e 	bne	r2,zero,42c6c <downClockMinute+0x40>
    clock.minute = (ONE_HOUR-1);
   42c50:	00800ec4 	movi	r2,59
   42c54:	d0a0fe85 	stb	r2,-31750(gp)
    
    if (carry_setting == CARRY_ON) {
   42c58:	e0bfff03 	ldbu	r2,-4(fp)
   42c5c:	10800058 	cmpnei	r2,r2,1
   42c60:	1000051e 	bne	r2,zero,42c78 <downClockMinute+0x4c>
      downClockHour();
   42c64:	0042cf40 	call	42cf4 <downClockHour>
   42c68:	00000306 	br	42c78 <downClockMinute+0x4c>
    }
  }
  else {
    clock.minute--;
   42c6c:	d0a0fe83 	ldbu	r2,-31750(gp)
   42c70:	10bfffc4 	addi	r2,r2,-1
   42c74:	d0a0fe85 	stb	r2,-31750(gp)
  }
  return clock;
   42c78:	d0a0fe43 	ldbu	r2,-31751(gp)
   42c7c:	e0bffe05 	stb	r2,-8(fp)
   42c80:	d0a0fe83 	ldbu	r2,-31750(gp)
   42c84:	e0bffe45 	stb	r2,-7(fp)
   42c88:	d0a0fec3 	ldbu	r2,-31749(gp)
   42c8c:	e0bffe85 	stb	r2,-6(fp)
   42c90:	0005883a 	mov	r2,zero
   42c94:	e0fffe03 	ldbu	r3,-8(fp)
   42c98:	18c03fcc 	andi	r3,r3,255
   42c9c:	013fc004 	movi	r4,-256
   42ca0:	1104703a 	and	r2,r2,r4
   42ca4:	10c4b03a 	or	r2,r2,r3
   42ca8:	e0fffe43 	ldbu	r3,-7(fp)
   42cac:	18c03fcc 	andi	r3,r3,255
   42cb0:	1808923a 	slli	r4,r3,8
   42cb4:	00fffff4 	movhi	r3,65535
   42cb8:	18c03fc4 	addi	r3,r3,255
   42cbc:	10c4703a 	and	r2,r2,r3
   42cc0:	1104b03a 	or	r2,r2,r4
   42cc4:	e0fffe83 	ldbu	r3,-6(fp)
   42cc8:	18c03fcc 	andi	r3,r3,255
   42ccc:	1808943a 	slli	r4,r3,16
   42cd0:	00ffc074 	movhi	r3,65281
   42cd4:	18ffffc4 	addi	r3,r3,-1
   42cd8:	10c4703a 	and	r2,r2,r3
   42cdc:	1104b03a 	or	r2,r2,r4
}
   42ce0:	e037883a 	mov	sp,fp
   42ce4:	dfc00117 	ldw	ra,4(sp)
   42ce8:	df000017 	ldw	fp,0(sp)
   42cec:	dec00204 	addi	sp,sp,8
   42cf0:	f800283a 	ret

00042cf4 <downClockHour>:

// HOURS
struct time downClockHour(void) {
   42cf4:	defffe04 	addi	sp,sp,-8
   42cf8:	df000115 	stw	fp,4(sp)
   42cfc:	df000104 	addi	fp,sp,4
  if (clock.hour == 0) {
   42d00:	d0a0fe43 	ldbu	r2,-31751(gp)
   42d04:	10803fcc 	andi	r2,r2,255
   42d08:	1000041e 	bne	r2,zero,42d1c <downClockHour+0x28>
    clock.hour = (time_format-1);
   42d0c:	d0a00643 	ldbu	r2,-32743(gp)
   42d10:	10bfffc4 	addi	r2,r2,-1
   42d14:	d0a0fe45 	stb	r2,-31751(gp)
   42d18:	00000306 	br	42d28 <downClockHour+0x34>
  }
  else {
    clock.hour--;
   42d1c:	d0a0fe43 	ldbu	r2,-31751(gp)
   42d20:	10bfffc4 	addi	r2,r2,-1
   42d24:	d0a0fe45 	stb	r2,-31751(gp)
  }
  return clock;
   42d28:	d0a0fe43 	ldbu	r2,-31751(gp)
   42d2c:	e0bfff05 	stb	r2,-4(fp)
   42d30:	d0a0fe83 	ldbu	r2,-31750(gp)
   42d34:	e0bfff45 	stb	r2,-3(fp)
   42d38:	d0a0fec3 	ldbu	r2,-31749(gp)
   42d3c:	e0bfff85 	stb	r2,-2(fp)
   42d40:	0005883a 	mov	r2,zero
   42d44:	e0ffff03 	ldbu	r3,-4(fp)
   42d48:	18c03fcc 	andi	r3,r3,255
   42d4c:	013fc004 	movi	r4,-256
   42d50:	1104703a 	and	r2,r2,r4
   42d54:	10c4b03a 	or	r2,r2,r3
   42d58:	e0ffff43 	ldbu	r3,-3(fp)
   42d5c:	18c03fcc 	andi	r3,r3,255
   42d60:	1808923a 	slli	r4,r3,8
   42d64:	00fffff4 	movhi	r3,65535
   42d68:	18c03fc4 	addi	r3,r3,255
   42d6c:	10c4703a 	and	r2,r2,r3
   42d70:	1104b03a 	or	r2,r2,r4
   42d74:	e0ffff83 	ldbu	r3,-2(fp)
   42d78:	18c03fcc 	andi	r3,r3,255
   42d7c:	1808943a 	slli	r4,r3,16
   42d80:	00ffc074 	movhi	r3,65281
   42d84:	18ffffc4 	addi	r3,r3,-1
   42d88:	10c4703a 	and	r2,r2,r3
   42d8c:	1104b03a 	or	r2,r2,r4
}
   42d90:	e037883a 	mov	sp,fp
   42d94:	df000017 	ldw	fp,0(sp)
   42d98:	dec00104 	addi	sp,sp,4
   42d9c:	f800283a 	ret

00042da0 <resetAlarmTime>:


/* ------------------------ ALARM functions ---------------------- */

// initialize alarm time to 00:00 (seconds are turned off)
void resetAlarmTime(void) {
   42da0:	deffff04 	addi	sp,sp,-4
   42da4:	df000015 	stw	fp,0(sp)
   42da8:	d839883a 	mov	fp,sp
  // necessary to cast to a time struct, otherwise the 
  // value assignment won't work
  alarm =  (struct time){0};
   42dac:	d020fd85 	stb	zero,-31754(gp)
   42db0:	d020fdc5 	stb	zero,-31753(gp)
   42db4:	d020fe05 	stb	zero,-31752(gp)

  // we explicitly request that the seconds are not displayed
  alarm.second = DONT_DISPLAY;
   42db8:	00801904 	movi	r2,100
   42dbc:	d0a0fe05 	stb	r2,-31752(gp)
}
   42dc0:	0001883a 	nop
   42dc4:	e037883a 	mov	sp,fp
   42dc8:	df000017 	ldw	fp,0(sp)
   42dcc:	dec00104 	addi	sp,sp,4
   42dd0:	f800283a 	ret

00042dd4 <getAlarmTime>:

struct time getAlarmTime(void) {
   42dd4:	defffe04 	addi	sp,sp,-8
   42dd8:	df000115 	stw	fp,4(sp)
   42ddc:	df000104 	addi	fp,sp,4
  return alarm;
   42de0:	d0a0fd83 	ldbu	r2,-31754(gp)
   42de4:	e0bfff05 	stb	r2,-4(fp)
   42de8:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42dec:	e0bfff45 	stb	r2,-3(fp)
   42df0:	d0a0fe03 	ldbu	r2,-31752(gp)
   42df4:	e0bfff85 	stb	r2,-2(fp)
   42df8:	0005883a 	mov	r2,zero
   42dfc:	e0ffff03 	ldbu	r3,-4(fp)
   42e00:	18c03fcc 	andi	r3,r3,255
   42e04:	013fc004 	movi	r4,-256
   42e08:	1104703a 	and	r2,r2,r4
   42e0c:	10c4b03a 	or	r2,r2,r3
   42e10:	e0ffff43 	ldbu	r3,-3(fp)
   42e14:	18c03fcc 	andi	r3,r3,255
   42e18:	1808923a 	slli	r4,r3,8
   42e1c:	00fffff4 	movhi	r3,65535
   42e20:	18c03fc4 	addi	r3,r3,255
   42e24:	10c4703a 	and	r2,r2,r3
   42e28:	1104b03a 	or	r2,r2,r4
   42e2c:	e0ffff83 	ldbu	r3,-2(fp)
   42e30:	18c03fcc 	andi	r3,r3,255
   42e34:	1808943a 	slli	r4,r3,16
   42e38:	00ffc074 	movhi	r3,65281
   42e3c:	18ffffc4 	addi	r3,r3,-1
   42e40:	10c4703a 	and	r2,r2,r3
   42e44:	1104b03a 	or	r2,r2,r4
}
   42e48:	e037883a 	mov	sp,fp
   42e4c:	df000017 	ldw	fp,0(sp)
   42e50:	dec00104 	addi	sp,sp,4
   42e54:	f800283a 	ret

00042e58 <upAlarmMinute>:

/*--------- up operations -------*/

// MINUTES
struct time upAlarmMinute(void) {
   42e58:	defffe04 	addi	sp,sp,-8
   42e5c:	df000115 	stw	fp,4(sp)
   42e60:	df000104 	addi	fp,sp,4
  if (alarm.minute == (ONE_HOUR-1)) {
   42e64:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42e68:	10803fcc 	andi	r2,r2,255
   42e6c:	10800ed8 	cmpnei	r2,r2,59
   42e70:	1000021e 	bne	r2,zero,42e7c <upAlarmMinute+0x24>
    alarm.minute = 0;
   42e74:	d020fdc5 	stb	zero,-31753(gp)
   42e78:	00000306 	br	42e88 <upAlarmMinute+0x30>
  }
  else {
    alarm.minute++;
   42e7c:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42e80:	10800044 	addi	r2,r2,1
   42e84:	d0a0fdc5 	stb	r2,-31753(gp)
  }
  return alarm;
   42e88:	d0a0fd83 	ldbu	r2,-31754(gp)
   42e8c:	e0bfff05 	stb	r2,-4(fp)
   42e90:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42e94:	e0bfff45 	stb	r2,-3(fp)
   42e98:	d0a0fe03 	ldbu	r2,-31752(gp)
   42e9c:	e0bfff85 	stb	r2,-2(fp)
   42ea0:	0005883a 	mov	r2,zero
   42ea4:	e0ffff03 	ldbu	r3,-4(fp)
   42ea8:	18c03fcc 	andi	r3,r3,255
   42eac:	013fc004 	movi	r4,-256
   42eb0:	1104703a 	and	r2,r2,r4
   42eb4:	10c4b03a 	or	r2,r2,r3
   42eb8:	e0ffff43 	ldbu	r3,-3(fp)
   42ebc:	18c03fcc 	andi	r3,r3,255
   42ec0:	1808923a 	slli	r4,r3,8
   42ec4:	00fffff4 	movhi	r3,65535
   42ec8:	18c03fc4 	addi	r3,r3,255
   42ecc:	10c4703a 	and	r2,r2,r3
   42ed0:	1104b03a 	or	r2,r2,r4
   42ed4:	e0ffff83 	ldbu	r3,-2(fp)
   42ed8:	18c03fcc 	andi	r3,r3,255
   42edc:	1808943a 	slli	r4,r3,16
   42ee0:	00ffc074 	movhi	r3,65281
   42ee4:	18ffffc4 	addi	r3,r3,-1
   42ee8:	10c4703a 	and	r2,r2,r3
   42eec:	1104b03a 	or	r2,r2,r4
}
   42ef0:	e037883a 	mov	sp,fp
   42ef4:	df000017 	ldw	fp,0(sp)
   42ef8:	dec00104 	addi	sp,sp,4
   42efc:	f800283a 	ret

00042f00 <upAlarmHour>:

// HOURS
struct time upAlarmHour(void) {
   42f00:	defffe04 	addi	sp,sp,-8
   42f04:	df000115 	stw	fp,4(sp)
   42f08:	df000104 	addi	fp,sp,4
  if (alarm.hour == (time_format-1)) {
   42f0c:	d0a0fd83 	ldbu	r2,-31754(gp)
   42f10:	10c03fcc 	andi	r3,r2,255
   42f14:	d0a00643 	ldbu	r2,-32743(gp)
   42f18:	10803fcc 	andi	r2,r2,255
   42f1c:	10bfffc4 	addi	r2,r2,-1
   42f20:	1880021e 	bne	r3,r2,42f2c <upAlarmHour+0x2c>
    alarm.hour = 0;
   42f24:	d020fd85 	stb	zero,-31754(gp)
   42f28:	00000306 	br	42f38 <upAlarmHour+0x38>
  }
  else {
    alarm.hour++;
   42f2c:	d0a0fd83 	ldbu	r2,-31754(gp)
   42f30:	10800044 	addi	r2,r2,1
   42f34:	d0a0fd85 	stb	r2,-31754(gp)
  }
  return alarm;
   42f38:	d0a0fd83 	ldbu	r2,-31754(gp)
   42f3c:	e0bfff05 	stb	r2,-4(fp)
   42f40:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42f44:	e0bfff45 	stb	r2,-3(fp)
   42f48:	d0a0fe03 	ldbu	r2,-31752(gp)
   42f4c:	e0bfff85 	stb	r2,-2(fp)
   42f50:	0005883a 	mov	r2,zero
   42f54:	e0ffff03 	ldbu	r3,-4(fp)
   42f58:	18c03fcc 	andi	r3,r3,255
   42f5c:	013fc004 	movi	r4,-256
   42f60:	1104703a 	and	r2,r2,r4
   42f64:	10c4b03a 	or	r2,r2,r3
   42f68:	e0ffff43 	ldbu	r3,-3(fp)
   42f6c:	18c03fcc 	andi	r3,r3,255
   42f70:	1808923a 	slli	r4,r3,8
   42f74:	00fffff4 	movhi	r3,65535
   42f78:	18c03fc4 	addi	r3,r3,255
   42f7c:	10c4703a 	and	r2,r2,r3
   42f80:	1104b03a 	or	r2,r2,r4
   42f84:	e0ffff83 	ldbu	r3,-2(fp)
   42f88:	18c03fcc 	andi	r3,r3,255
   42f8c:	1808943a 	slli	r4,r3,16
   42f90:	00ffc074 	movhi	r3,65281
   42f94:	18ffffc4 	addi	r3,r3,-1
   42f98:	10c4703a 	and	r2,r2,r3
   42f9c:	1104b03a 	or	r2,r2,r4
}
   42fa0:	e037883a 	mov	sp,fp
   42fa4:	df000017 	ldw	fp,0(sp)
   42fa8:	dec00104 	addi	sp,sp,4
   42fac:	f800283a 	ret

00042fb0 <downAlarmMinute>:

/*--------- down operations -------*/

// MINUTES
struct time downAlarmMinute(void) {
   42fb0:	defffe04 	addi	sp,sp,-8
   42fb4:	df000115 	stw	fp,4(sp)
   42fb8:	df000104 	addi	fp,sp,4
  if (alarm.minute == 0) {
   42fbc:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42fc0:	10803fcc 	andi	r2,r2,255
   42fc4:	1000031e 	bne	r2,zero,42fd4 <downAlarmMinute+0x24>
    alarm.minute = (ONE_HOUR-1);
   42fc8:	00800ec4 	movi	r2,59
   42fcc:	d0a0fdc5 	stb	r2,-31753(gp)
   42fd0:	00000306 	br	42fe0 <downAlarmMinute+0x30>
  }
  else {
    alarm.minute--;
   42fd4:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42fd8:	10bfffc4 	addi	r2,r2,-1
   42fdc:	d0a0fdc5 	stb	r2,-31753(gp)
  }
  return alarm;
   42fe0:	d0a0fd83 	ldbu	r2,-31754(gp)
   42fe4:	e0bfff05 	stb	r2,-4(fp)
   42fe8:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42fec:	e0bfff45 	stb	r2,-3(fp)
   42ff0:	d0a0fe03 	ldbu	r2,-31752(gp)
   42ff4:	e0bfff85 	stb	r2,-2(fp)
   42ff8:	0005883a 	mov	r2,zero
   42ffc:	e0ffff03 	ldbu	r3,-4(fp)
   43000:	18c03fcc 	andi	r3,r3,255
   43004:	013fc004 	movi	r4,-256
   43008:	1104703a 	and	r2,r2,r4
   4300c:	10c4b03a 	or	r2,r2,r3
   43010:	e0ffff43 	ldbu	r3,-3(fp)
   43014:	18c03fcc 	andi	r3,r3,255
   43018:	1808923a 	slli	r4,r3,8
   4301c:	00fffff4 	movhi	r3,65535
   43020:	18c03fc4 	addi	r3,r3,255
   43024:	10c4703a 	and	r2,r2,r3
   43028:	1104b03a 	or	r2,r2,r4
   4302c:	e0ffff83 	ldbu	r3,-2(fp)
   43030:	18c03fcc 	andi	r3,r3,255
   43034:	1808943a 	slli	r4,r3,16
   43038:	00ffc074 	movhi	r3,65281
   4303c:	18ffffc4 	addi	r3,r3,-1
   43040:	10c4703a 	and	r2,r2,r3
   43044:	1104b03a 	or	r2,r2,r4
}
   43048:	e037883a 	mov	sp,fp
   4304c:	df000017 	ldw	fp,0(sp)
   43050:	dec00104 	addi	sp,sp,4
   43054:	f800283a 	ret

00043058 <downAlarmHour>:

// HOURS
struct time downAlarmHour(void) {
   43058:	defffe04 	addi	sp,sp,-8
   4305c:	df000115 	stw	fp,4(sp)
   43060:	df000104 	addi	fp,sp,4
  if (alarm.hour == 0) {
   43064:	d0a0fd83 	ldbu	r2,-31754(gp)
   43068:	10803fcc 	andi	r2,r2,255
   4306c:	1000041e 	bne	r2,zero,43080 <downAlarmHour+0x28>
    alarm.hour = (time_format-1);
   43070:	d0a00643 	ldbu	r2,-32743(gp)
   43074:	10bfffc4 	addi	r2,r2,-1
   43078:	d0a0fd85 	stb	r2,-31754(gp)
   4307c:	00000306 	br	4308c <downAlarmHour+0x34>
  }
  else {
    alarm.hour--;
   43080:	d0a0fd83 	ldbu	r2,-31754(gp)
   43084:	10bfffc4 	addi	r2,r2,-1
   43088:	d0a0fd85 	stb	r2,-31754(gp)
  }
  return alarm;
   4308c:	d0a0fd83 	ldbu	r2,-31754(gp)
   43090:	e0bfff05 	stb	r2,-4(fp)
   43094:	d0a0fdc3 	ldbu	r2,-31753(gp)
   43098:	e0bfff45 	stb	r2,-3(fp)
   4309c:	d0a0fe03 	ldbu	r2,-31752(gp)
   430a0:	e0bfff85 	stb	r2,-2(fp)
   430a4:	0005883a 	mov	r2,zero
   430a8:	e0ffff03 	ldbu	r3,-4(fp)
   430ac:	18c03fcc 	andi	r3,r3,255
   430b0:	013fc004 	movi	r4,-256
   430b4:	1104703a 	and	r2,r2,r4
   430b8:	10c4b03a 	or	r2,r2,r3
   430bc:	e0ffff43 	ldbu	r3,-3(fp)
   430c0:	18c03fcc 	andi	r3,r3,255
   430c4:	1808923a 	slli	r4,r3,8
   430c8:	00fffff4 	movhi	r3,65535
   430cc:	18c03fc4 	addi	r3,r3,255
   430d0:	10c4703a 	and	r2,r2,r3
   430d4:	1104b03a 	or	r2,r2,r4
   430d8:	e0ffff83 	ldbu	r3,-2(fp)
   430dc:	18c03fcc 	andi	r3,r3,255
   430e0:	1808943a 	slli	r4,r3,16
   430e4:	00ffc074 	movhi	r3,65281
   430e8:	18ffffc4 	addi	r3,r3,-1
   430ec:	10c4703a 	and	r2,r2,r3
   430f0:	1104b03a 	or	r2,r2,r4
}
   430f4:	e037883a 	mov	sp,fp
   430f8:	df000017 	ldw	fp,0(sp)
   430fc:	dec00104 	addi	sp,sp,4
   43100:	f800283a 	ret

00043104 <__fixunssfsi>:
   43104:	defffd04 	addi	sp,sp,-12
   43108:	dc000015 	stw	r16,0(sp)
   4310c:	0413c034 	movhi	r16,20224
   43110:	800b883a 	mov	r5,r16
   43114:	dc400115 	stw	r17,4(sp)
   43118:	dfc00215 	stw	ra,8(sp)
   4311c:	2023883a 	mov	r17,r4
   43120:	00433180 	call	43318 <__gesf2>
   43124:	1000070e 	bge	r2,zero,43144 <__fixunssfsi+0x40>
   43128:	8809883a 	mov	r4,r17
   4312c:	0043cb40 	call	43cb4 <__fixsfsi>
   43130:	dfc00217 	ldw	ra,8(sp)
   43134:	dc400117 	ldw	r17,4(sp)
   43138:	dc000017 	ldw	r16,0(sp)
   4313c:	dec00304 	addi	sp,sp,12
   43140:	f800283a 	ret
   43144:	800b883a 	mov	r5,r16
   43148:	8809883a 	mov	r4,r17
   4314c:	00437d00 	call	437d0 <__subsf3>
   43150:	1009883a 	mov	r4,r2
   43154:	0043cb40 	call	43cb4 <__fixsfsi>
   43158:	00e00034 	movhi	r3,32768
   4315c:	10c5883a 	add	r2,r2,r3
   43160:	003ff306 	br	43130 <__alt_data_end+0xfffdb130>

00043164 <__divsi3>:
   43164:	20001b16 	blt	r4,zero,431d4 <__divsi3+0x70>
   43168:	000f883a 	mov	r7,zero
   4316c:	28001616 	blt	r5,zero,431c8 <__divsi3+0x64>
   43170:	200d883a 	mov	r6,r4
   43174:	29001a2e 	bgeu	r5,r4,431e0 <__divsi3+0x7c>
   43178:	00800804 	movi	r2,32
   4317c:	00c00044 	movi	r3,1
   43180:	00000106 	br	43188 <__divsi3+0x24>
   43184:	10000d26 	beq	r2,zero,431bc <__divsi3+0x58>
   43188:	294b883a 	add	r5,r5,r5
   4318c:	10bfffc4 	addi	r2,r2,-1
   43190:	18c7883a 	add	r3,r3,r3
   43194:	293ffb36 	bltu	r5,r4,43184 <__alt_data_end+0xfffdb184>
   43198:	0005883a 	mov	r2,zero
   4319c:	18000726 	beq	r3,zero,431bc <__divsi3+0x58>
   431a0:	0005883a 	mov	r2,zero
   431a4:	31400236 	bltu	r6,r5,431b0 <__divsi3+0x4c>
   431a8:	314dc83a 	sub	r6,r6,r5
   431ac:	10c4b03a 	or	r2,r2,r3
   431b0:	1806d07a 	srli	r3,r3,1
   431b4:	280ad07a 	srli	r5,r5,1
   431b8:	183ffa1e 	bne	r3,zero,431a4 <__alt_data_end+0xfffdb1a4>
   431bc:	38000126 	beq	r7,zero,431c4 <__divsi3+0x60>
   431c0:	0085c83a 	sub	r2,zero,r2
   431c4:	f800283a 	ret
   431c8:	014bc83a 	sub	r5,zero,r5
   431cc:	39c0005c 	xori	r7,r7,1
   431d0:	003fe706 	br	43170 <__alt_data_end+0xfffdb170>
   431d4:	0109c83a 	sub	r4,zero,r4
   431d8:	01c00044 	movi	r7,1
   431dc:	003fe306 	br	4316c <__alt_data_end+0xfffdb16c>
   431e0:	00c00044 	movi	r3,1
   431e4:	003fee06 	br	431a0 <__alt_data_end+0xfffdb1a0>

000431e8 <__modsi3>:
   431e8:	20001716 	blt	r4,zero,43248 <__modsi3+0x60>
   431ec:	000f883a 	mov	r7,zero
   431f0:	2005883a 	mov	r2,r4
   431f4:	28001216 	blt	r5,zero,43240 <__modsi3+0x58>
   431f8:	2900162e 	bgeu	r5,r4,43254 <__modsi3+0x6c>
   431fc:	01800804 	movi	r6,32
   43200:	00c00044 	movi	r3,1
   43204:	00000106 	br	4320c <__modsi3+0x24>
   43208:	30000a26 	beq	r6,zero,43234 <__modsi3+0x4c>
   4320c:	294b883a 	add	r5,r5,r5
   43210:	31bfffc4 	addi	r6,r6,-1
   43214:	18c7883a 	add	r3,r3,r3
   43218:	293ffb36 	bltu	r5,r4,43208 <__alt_data_end+0xfffdb208>
   4321c:	18000526 	beq	r3,zero,43234 <__modsi3+0x4c>
   43220:	1806d07a 	srli	r3,r3,1
   43224:	11400136 	bltu	r2,r5,4322c <__modsi3+0x44>
   43228:	1145c83a 	sub	r2,r2,r5
   4322c:	280ad07a 	srli	r5,r5,1
   43230:	183ffb1e 	bne	r3,zero,43220 <__alt_data_end+0xfffdb220>
   43234:	38000126 	beq	r7,zero,4323c <__modsi3+0x54>
   43238:	0085c83a 	sub	r2,zero,r2
   4323c:	f800283a 	ret
   43240:	014bc83a 	sub	r5,zero,r5
   43244:	003fec06 	br	431f8 <__alt_data_end+0xfffdb1f8>
   43248:	0109c83a 	sub	r4,zero,r4
   4324c:	01c00044 	movi	r7,1
   43250:	003fe706 	br	431f0 <__alt_data_end+0xfffdb1f0>
   43254:	00c00044 	movi	r3,1
   43258:	003ff106 	br	43220 <__alt_data_end+0xfffdb220>

0004325c <__udivsi3>:
   4325c:	200d883a 	mov	r6,r4
   43260:	2900152e 	bgeu	r5,r4,432b8 <__udivsi3+0x5c>
   43264:	28001416 	blt	r5,zero,432b8 <__udivsi3+0x5c>
   43268:	00800804 	movi	r2,32
   4326c:	00c00044 	movi	r3,1
   43270:	00000206 	br	4327c <__udivsi3+0x20>
   43274:	10000e26 	beq	r2,zero,432b0 <__udivsi3+0x54>
   43278:	28000516 	blt	r5,zero,43290 <__udivsi3+0x34>
   4327c:	294b883a 	add	r5,r5,r5
   43280:	10bfffc4 	addi	r2,r2,-1
   43284:	18c7883a 	add	r3,r3,r3
   43288:	293ffa36 	bltu	r5,r4,43274 <__alt_data_end+0xfffdb274>
   4328c:	18000826 	beq	r3,zero,432b0 <__udivsi3+0x54>
   43290:	0005883a 	mov	r2,zero
   43294:	31400236 	bltu	r6,r5,432a0 <__udivsi3+0x44>
   43298:	314dc83a 	sub	r6,r6,r5
   4329c:	10c4b03a 	or	r2,r2,r3
   432a0:	1806d07a 	srli	r3,r3,1
   432a4:	280ad07a 	srli	r5,r5,1
   432a8:	183ffa1e 	bne	r3,zero,43294 <__alt_data_end+0xfffdb294>
   432ac:	f800283a 	ret
   432b0:	0005883a 	mov	r2,zero
   432b4:	f800283a 	ret
   432b8:	00c00044 	movi	r3,1
   432bc:	003ff406 	br	43290 <__alt_data_end+0xfffdb290>

000432c0 <__umodsi3>:
   432c0:	2005883a 	mov	r2,r4
   432c4:	2900122e 	bgeu	r5,r4,43310 <__umodsi3+0x50>
   432c8:	28001116 	blt	r5,zero,43310 <__umodsi3+0x50>
   432cc:	01800804 	movi	r6,32
   432d0:	00c00044 	movi	r3,1
   432d4:	00000206 	br	432e0 <__umodsi3+0x20>
   432d8:	30000c26 	beq	r6,zero,4330c <__umodsi3+0x4c>
   432dc:	28000516 	blt	r5,zero,432f4 <__umodsi3+0x34>
   432e0:	294b883a 	add	r5,r5,r5
   432e4:	31bfffc4 	addi	r6,r6,-1
   432e8:	18c7883a 	add	r3,r3,r3
   432ec:	293ffa36 	bltu	r5,r4,432d8 <__alt_data_end+0xfffdb2d8>
   432f0:	18000626 	beq	r3,zero,4330c <__umodsi3+0x4c>
   432f4:	1806d07a 	srli	r3,r3,1
   432f8:	11400136 	bltu	r2,r5,43300 <__umodsi3+0x40>
   432fc:	1145c83a 	sub	r2,r2,r5
   43300:	280ad07a 	srli	r5,r5,1
   43304:	183ffb1e 	bne	r3,zero,432f4 <__alt_data_end+0xfffdb2f4>
   43308:	f800283a 	ret
   4330c:	f800283a 	ret
   43310:	00c00044 	movi	r3,1
   43314:	003ff706 	br	432f4 <__alt_data_end+0xfffdb2f4>

00043318 <__gesf2>:
   43318:	2004d5fa 	srli	r2,r4,23
   4331c:	2806d5fa 	srli	r3,r5,23
   43320:	01802034 	movhi	r6,128
   43324:	31bfffc4 	addi	r6,r6,-1
   43328:	10803fcc 	andi	r2,r2,255
   4332c:	01c03fc4 	movi	r7,255
   43330:	3110703a 	and	r8,r6,r4
   43334:	18c03fcc 	andi	r3,r3,255
   43338:	314c703a 	and	r6,r6,r5
   4333c:	2008d7fa 	srli	r4,r4,31
   43340:	280ad7fa 	srli	r5,r5,31
   43344:	11c01926 	beq	r2,r7,433ac <__gesf2+0x94>
   43348:	01c03fc4 	movi	r7,255
   4334c:	19c00f26 	beq	r3,r7,4338c <__gesf2+0x74>
   43350:	1000061e 	bne	r2,zero,4336c <__gesf2+0x54>
   43354:	400f003a 	cmpeq	r7,r8,zero
   43358:	1800071e 	bne	r3,zero,43378 <__gesf2+0x60>
   4335c:	3000061e 	bne	r6,zero,43378 <__gesf2+0x60>
   43360:	0005883a 	mov	r2,zero
   43364:	40000e1e 	bne	r8,zero,433a0 <__gesf2+0x88>
   43368:	f800283a 	ret
   4336c:	18000a1e 	bne	r3,zero,43398 <__gesf2+0x80>
   43370:	30000b26 	beq	r6,zero,433a0 <__gesf2+0x88>
   43374:	000f883a 	mov	r7,zero
   43378:	29403fcc 	andi	r5,r5,255
   4337c:	38000726 	beq	r7,zero,4339c <__gesf2+0x84>
   43380:	28000826 	beq	r5,zero,433a4 <__gesf2+0x8c>
   43384:	00800044 	movi	r2,1
   43388:	f800283a 	ret
   4338c:	303ff026 	beq	r6,zero,43350 <__alt_data_end+0xfffdb350>
   43390:	00bfff84 	movi	r2,-2
   43394:	f800283a 	ret
   43398:	29403fcc 	andi	r5,r5,255
   4339c:	21400526 	beq	r4,r5,433b4 <__gesf2+0x9c>
   433a0:	203ff826 	beq	r4,zero,43384 <__alt_data_end+0xfffdb384>
   433a4:	00bfffc4 	movi	r2,-1
   433a8:	f800283a 	ret
   433ac:	403fe626 	beq	r8,zero,43348 <__alt_data_end+0xfffdb348>
   433b0:	003ff706 	br	43390 <__alt_data_end+0xfffdb390>
   433b4:	18bffa16 	blt	r3,r2,433a0 <__alt_data_end+0xfffdb3a0>
   433b8:	10c00216 	blt	r2,r3,433c4 <__gesf2+0xac>
   433bc:	323ff836 	bltu	r6,r8,433a0 <__alt_data_end+0xfffdb3a0>
   433c0:	4180022e 	bgeu	r8,r6,433cc <__gesf2+0xb4>
   433c4:	203fef1e 	bne	r4,zero,43384 <__alt_data_end+0xfffdb384>
   433c8:	003ff606 	br	433a4 <__alt_data_end+0xfffdb3a4>
   433cc:	0005883a 	mov	r2,zero
   433d0:	f800283a 	ret

000433d4 <__mulsf3>:
   433d4:	defff504 	addi	sp,sp,-44
   433d8:	dc000115 	stw	r16,4(sp)
   433dc:	2020d5fa 	srli	r16,r4,23
   433e0:	dd400615 	stw	r21,24(sp)
   433e4:	202ad7fa 	srli	r21,r4,31
   433e8:	dc800315 	stw	r18,12(sp)
   433ec:	04802034 	movhi	r18,128
   433f0:	df000915 	stw	fp,36(sp)
   433f4:	dd000515 	stw	r20,20(sp)
   433f8:	94bfffc4 	addi	r18,r18,-1
   433fc:	dfc00a15 	stw	ra,40(sp)
   43400:	ddc00815 	stw	r23,32(sp)
   43404:	dd800715 	stw	r22,28(sp)
   43408:	dcc00415 	stw	r19,16(sp)
   4340c:	dc400215 	stw	r17,8(sp)
   43410:	84003fcc 	andi	r16,r16,255
   43414:	9124703a 	and	r18,r18,r4
   43418:	a829883a 	mov	r20,r21
   4341c:	af003fcc 	andi	fp,r21,255
   43420:	80005426 	beq	r16,zero,43574 <__mulsf3+0x1a0>
   43424:	00803fc4 	movi	r2,255
   43428:	80802f26 	beq	r16,r2,434e8 <__mulsf3+0x114>
   4342c:	91002034 	orhi	r4,r18,128
   43430:	202490fa 	slli	r18,r4,3
   43434:	843fe044 	addi	r16,r16,-127
   43438:	0023883a 	mov	r17,zero
   4343c:	002f883a 	mov	r23,zero
   43440:	2804d5fa 	srli	r2,r5,23
   43444:	282cd7fa 	srli	r22,r5,31
   43448:	01002034 	movhi	r4,128
   4344c:	213fffc4 	addi	r4,r4,-1
   43450:	10803fcc 	andi	r2,r2,255
   43454:	2166703a 	and	r19,r4,r5
   43458:	b1803fcc 	andi	r6,r22,255
   4345c:	10004c26 	beq	r2,zero,43590 <__mulsf3+0x1bc>
   43460:	00c03fc4 	movi	r3,255
   43464:	10c04726 	beq	r2,r3,43584 <__mulsf3+0x1b0>
   43468:	99002034 	orhi	r4,r19,128
   4346c:	202690fa 	slli	r19,r4,3
   43470:	10bfe044 	addi	r2,r2,-127
   43474:	0007883a 	mov	r3,zero
   43478:	80a1883a 	add	r16,r16,r2
   4347c:	010003c4 	movi	r4,15
   43480:	1c44b03a 	or	r2,r3,r17
   43484:	b56af03a 	xor	r21,r22,r21
   43488:	81c00044 	addi	r7,r16,1
   4348c:	20806b36 	bltu	r4,r2,4363c <__mulsf3+0x268>
   43490:	100490ba 	slli	r2,r2,2
   43494:	01000134 	movhi	r4,4
   43498:	210d2a04 	addi	r4,r4,13480
   4349c:	1105883a 	add	r2,r2,r4
   434a0:	10800017 	ldw	r2,0(r2)
   434a4:	1000683a 	jmp	r2
   434a8:	0004363c 	xorhi	zero,zero,4312
   434ac:	000434fc 	xorhi	zero,zero,4307
   434b0:	000434fc 	xorhi	zero,zero,4307
   434b4:	000434f8 	rdprs	zero,zero,4307
   434b8:	00043620 	cmpeqi	zero,zero,4312
   434bc:	00043620 	cmpeqi	zero,zero,4312
   434c0:	0004360c 	andi	zero,zero,4312
   434c4:	000434f8 	rdprs	zero,zero,4307
   434c8:	00043620 	cmpeqi	zero,zero,4312
   434cc:	0004360c 	andi	zero,zero,4312
   434d0:	00043620 	cmpeqi	zero,zero,4312
   434d4:	000434f8 	rdprs	zero,zero,4307
   434d8:	0004362c 	andhi	zero,zero,4312
   434dc:	0004362c 	andhi	zero,zero,4312
   434e0:	0004362c 	andhi	zero,zero,4312
   434e4:	00043708 	cmpgei	zero,zero,4316
   434e8:	90003b1e 	bne	r18,zero,435d8 <__mulsf3+0x204>
   434ec:	04400204 	movi	r17,8
   434f0:	05c00084 	movi	r23,2
   434f4:	003fd206 	br	43440 <__alt_data_end+0xfffdb440>
   434f8:	302b883a 	mov	r21,r6
   434fc:	00800084 	movi	r2,2
   43500:	18802626 	beq	r3,r2,4359c <__mulsf3+0x1c8>
   43504:	008000c4 	movi	r2,3
   43508:	1880ab26 	beq	r3,r2,437b8 <__mulsf3+0x3e4>
   4350c:	00800044 	movi	r2,1
   43510:	1880a21e 	bne	r3,r2,4379c <__mulsf3+0x3c8>
   43514:	a829883a 	mov	r20,r21
   43518:	0007883a 	mov	r3,zero
   4351c:	0009883a 	mov	r4,zero
   43520:	18803fcc 	andi	r2,r3,255
   43524:	100695fa 	slli	r3,r2,23
   43528:	a0803fcc 	andi	r2,r20,255
   4352c:	100a97fa 	slli	r5,r2,31
   43530:	00802034 	movhi	r2,128
   43534:	10bfffc4 	addi	r2,r2,-1
   43538:	2084703a 	and	r2,r4,r2
   4353c:	10c4b03a 	or	r2,r2,r3
   43540:	1144b03a 	or	r2,r2,r5
   43544:	dfc00a17 	ldw	ra,40(sp)
   43548:	df000917 	ldw	fp,36(sp)
   4354c:	ddc00817 	ldw	r23,32(sp)
   43550:	dd800717 	ldw	r22,28(sp)
   43554:	dd400617 	ldw	r21,24(sp)
   43558:	dd000517 	ldw	r20,20(sp)
   4355c:	dcc00417 	ldw	r19,16(sp)
   43560:	dc800317 	ldw	r18,12(sp)
   43564:	dc400217 	ldw	r17,8(sp)
   43568:	dc000117 	ldw	r16,4(sp)
   4356c:	dec00b04 	addi	sp,sp,44
   43570:	f800283a 	ret
   43574:	90000d1e 	bne	r18,zero,435ac <__mulsf3+0x1d8>
   43578:	04400104 	movi	r17,4
   4357c:	05c00044 	movi	r23,1
   43580:	003faf06 	br	43440 <__alt_data_end+0xfffdb440>
   43584:	9806c03a 	cmpne	r3,r19,zero
   43588:	18c00084 	addi	r3,r3,2
   4358c:	003fba06 	br	43478 <__alt_data_end+0xfffdb478>
   43590:	9800141e 	bne	r19,zero,435e4 <__mulsf3+0x210>
   43594:	00c00044 	movi	r3,1
   43598:	003fb706 	br	43478 <__alt_data_end+0xfffdb478>
   4359c:	a829883a 	mov	r20,r21
   435a0:	00ffffc4 	movi	r3,-1
   435a4:	0009883a 	mov	r4,zero
   435a8:	003fdd06 	br	43520 <__alt_data_end+0xfffdb520>
   435ac:	9009883a 	mov	r4,r18
   435b0:	d9400015 	stw	r5,0(sp)
   435b4:	0043e140 	call	43e14 <__clzsi2>
   435b8:	10fffec4 	addi	r3,r2,-5
   435bc:	10801d84 	addi	r2,r2,118
   435c0:	90e4983a 	sll	r18,r18,r3
   435c4:	00a1c83a 	sub	r16,zero,r2
   435c8:	0023883a 	mov	r17,zero
   435cc:	002f883a 	mov	r23,zero
   435d0:	d9400017 	ldw	r5,0(sp)
   435d4:	003f9a06 	br	43440 <__alt_data_end+0xfffdb440>
   435d8:	04400304 	movi	r17,12
   435dc:	05c000c4 	movi	r23,3
   435e0:	003f9706 	br	43440 <__alt_data_end+0xfffdb440>
   435e4:	9809883a 	mov	r4,r19
   435e8:	d9800015 	stw	r6,0(sp)
   435ec:	0043e140 	call	43e14 <__clzsi2>
   435f0:	10fffec4 	addi	r3,r2,-5
   435f4:	10801d84 	addi	r2,r2,118
   435f8:	98e6983a 	sll	r19,r19,r3
   435fc:	0085c83a 	sub	r2,zero,r2
   43600:	0007883a 	mov	r3,zero
   43604:	d9800017 	ldw	r6,0(sp)
   43608:	003f9b06 	br	43478 <__alt_data_end+0xfffdb478>
   4360c:	01002034 	movhi	r4,128
   43610:	0029883a 	mov	r20,zero
   43614:	213fffc4 	addi	r4,r4,-1
   43618:	00ffffc4 	movi	r3,-1
   4361c:	003fc006 	br	43520 <__alt_data_end+0xfffdb520>
   43620:	9027883a 	mov	r19,r18
   43624:	b807883a 	mov	r3,r23
   43628:	003fb406 	br	434fc <__alt_data_end+0xfffdb4fc>
   4362c:	9027883a 	mov	r19,r18
   43630:	e02b883a 	mov	r21,fp
   43634:	b807883a 	mov	r3,r23
   43638:	003fb006 	br	434fc <__alt_data_end+0xfffdb4fc>
   4363c:	9004d43a 	srli	r2,r18,16
   43640:	9810d43a 	srli	r8,r19,16
   43644:	94bfffcc 	andi	r18,r18,65535
   43648:	993fffcc 	andi	r4,r19,65535
   4364c:	910d383a 	mul	r6,r18,r4
   43650:	20a7383a 	mul	r19,r4,r2
   43654:	9225383a 	mul	r18,r18,r8
   43658:	3006d43a 	srli	r3,r6,16
   4365c:	1211383a 	mul	r8,r2,r8
   43660:	94e5883a 	add	r18,r18,r19
   43664:	1c87883a 	add	r3,r3,r18
   43668:	1cc0022e 	bgeu	r3,r19,43674 <__mulsf3+0x2a0>
   4366c:	00800074 	movhi	r2,1
   43670:	4091883a 	add	r8,r8,r2
   43674:	1804943a 	slli	r2,r3,16
   43678:	31bfffcc 	andi	r6,r6,65535
   4367c:	1806d43a 	srli	r3,r3,16
   43680:	1185883a 	add	r2,r2,r6
   43684:	102691ba 	slli	r19,r2,6
   43688:	1a07883a 	add	r3,r3,r8
   4368c:	1004d6ba 	srli	r2,r2,26
   43690:	180891ba 	slli	r4,r3,6
   43694:	9826c03a 	cmpne	r19,r19,zero
   43698:	9884b03a 	or	r2,r19,r2
   4369c:	1126b03a 	or	r19,r2,r4
   436a0:	9882002c 	andhi	r2,r19,2048
   436a4:	10000426 	beq	r2,zero,436b8 <__mulsf3+0x2e4>
   436a8:	9804d07a 	srli	r2,r19,1
   436ac:	9900004c 	andi	r4,r19,1
   436b0:	3821883a 	mov	r16,r7
   436b4:	1126b03a 	or	r19,r2,r4
   436b8:	80c01fc4 	addi	r3,r16,127
   436bc:	00c0210e 	bge	zero,r3,43744 <__mulsf3+0x370>
   436c0:	988001cc 	andi	r2,r19,7
   436c4:	10000426 	beq	r2,zero,436d8 <__mulsf3+0x304>
   436c8:	988003cc 	andi	r2,r19,15
   436cc:	01000104 	movi	r4,4
   436d0:	11000126 	beq	r2,r4,436d8 <__mulsf3+0x304>
   436d4:	9927883a 	add	r19,r19,r4
   436d8:	9882002c 	andhi	r2,r19,2048
   436dc:	10000426 	beq	r2,zero,436f0 <__mulsf3+0x31c>
   436e0:	00be0034 	movhi	r2,63488
   436e4:	10bfffc4 	addi	r2,r2,-1
   436e8:	80c02004 	addi	r3,r16,128
   436ec:	98a6703a 	and	r19,r19,r2
   436f0:	00803f84 	movi	r2,254
   436f4:	10ffa916 	blt	r2,r3,4359c <__alt_data_end+0xfffdb59c>
   436f8:	980891ba 	slli	r4,r19,6
   436fc:	a829883a 	mov	r20,r21
   43700:	2008d27a 	srli	r4,r4,9
   43704:	003f8606 	br	43520 <__alt_data_end+0xfffdb520>
   43708:	9080102c 	andhi	r2,r18,64
   4370c:	10000826 	beq	r2,zero,43730 <__mulsf3+0x35c>
   43710:	9880102c 	andhi	r2,r19,64
   43714:	1000061e 	bne	r2,zero,43730 <__mulsf3+0x35c>
   43718:	00802034 	movhi	r2,128
   4371c:	99001034 	orhi	r4,r19,64
   43720:	10bfffc4 	addi	r2,r2,-1
   43724:	b029883a 	mov	r20,r22
   43728:	2088703a 	and	r4,r4,r2
   4372c:	003fba06 	br	43618 <__alt_data_end+0xfffdb618>
   43730:	00802034 	movhi	r2,128
   43734:	91001034 	orhi	r4,r18,64
   43738:	10bfffc4 	addi	r2,r2,-1
   4373c:	2088703a 	and	r4,r4,r2
   43740:	003fb506 	br	43618 <__alt_data_end+0xfffdb618>
   43744:	00800044 	movi	r2,1
   43748:	10c7c83a 	sub	r3,r2,r3
   4374c:	008006c4 	movi	r2,27
   43750:	10ff7016 	blt	r2,r3,43514 <__alt_data_end+0xfffdb514>
   43754:	00800804 	movi	r2,32
   43758:	10c5c83a 	sub	r2,r2,r3
   4375c:	9884983a 	sll	r2,r19,r2
   43760:	98c6d83a 	srl	r3,r19,r3
   43764:	1004c03a 	cmpne	r2,r2,zero
   43768:	1884b03a 	or	r2,r3,r2
   4376c:	10c001cc 	andi	r3,r2,7
   43770:	18000426 	beq	r3,zero,43784 <__mulsf3+0x3b0>
   43774:	10c003cc 	andi	r3,r2,15
   43778:	01000104 	movi	r4,4
   4377c:	19000126 	beq	r3,r4,43784 <__mulsf3+0x3b0>
   43780:	1105883a 	add	r2,r2,r4
   43784:	10c1002c 	andhi	r3,r2,1024
   43788:	18000626 	beq	r3,zero,437a4 <__mulsf3+0x3d0>
   4378c:	a829883a 	mov	r20,r21
   43790:	00c00044 	movi	r3,1
   43794:	0009883a 	mov	r4,zero
   43798:	003f6106 	br	43520 <__alt_data_end+0xfffdb520>
   4379c:	3821883a 	mov	r16,r7
   437a0:	003fc506 	br	436b8 <__alt_data_end+0xfffdb6b8>
   437a4:	100491ba 	slli	r2,r2,6
   437a8:	a829883a 	mov	r20,r21
   437ac:	0007883a 	mov	r3,zero
   437b0:	1008d27a 	srli	r4,r2,9
   437b4:	003f5a06 	br	43520 <__alt_data_end+0xfffdb520>
   437b8:	00802034 	movhi	r2,128
   437bc:	99001034 	orhi	r4,r19,64
   437c0:	10bfffc4 	addi	r2,r2,-1
   437c4:	a829883a 	mov	r20,r21
   437c8:	2088703a 	and	r4,r4,r2
   437cc:	003f9206 	br	43618 <__alt_data_end+0xfffdb618>

000437d0 <__subsf3>:
   437d0:	defffc04 	addi	sp,sp,-16
   437d4:	280cd5fa 	srli	r6,r5,23
   437d8:	dc000015 	stw	r16,0(sp)
   437dc:	01c02034 	movhi	r7,128
   437e0:	2020d5fa 	srli	r16,r4,23
   437e4:	39ffffc4 	addi	r7,r7,-1
   437e8:	3906703a 	and	r3,r7,r4
   437ec:	dc400115 	stw	r17,4(sp)
   437f0:	394e703a 	and	r7,r7,r5
   437f4:	2022d7fa 	srli	r17,r4,31
   437f8:	dfc00315 	stw	ra,12(sp)
   437fc:	dc800215 	stw	r18,8(sp)
   43800:	31803fcc 	andi	r6,r6,255
   43804:	01003fc4 	movi	r4,255
   43808:	84003fcc 	andi	r16,r16,255
   4380c:	180690fa 	slli	r3,r3,3
   43810:	2804d7fa 	srli	r2,r5,31
   43814:	380e90fa 	slli	r7,r7,3
   43818:	31006d26 	beq	r6,r4,439d0 <__subsf3+0x200>
   4381c:	1080005c 	xori	r2,r2,1
   43820:	8189c83a 	sub	r4,r16,r6
   43824:	14404f26 	beq	r2,r17,43964 <__subsf3+0x194>
   43828:	0100770e 	bge	zero,r4,43a08 <__subsf3+0x238>
   4382c:	30001e1e 	bne	r6,zero,438a8 <__subsf3+0xd8>
   43830:	38006a1e 	bne	r7,zero,439dc <__subsf3+0x20c>
   43834:	188001cc 	andi	r2,r3,7
   43838:	10000426 	beq	r2,zero,4384c <__subsf3+0x7c>
   4383c:	188003cc 	andi	r2,r3,15
   43840:	01000104 	movi	r4,4
   43844:	11000126 	beq	r2,r4,4384c <__subsf3+0x7c>
   43848:	1907883a 	add	r3,r3,r4
   4384c:	1881002c 	andhi	r2,r3,1024
   43850:	10003926 	beq	r2,zero,43938 <__subsf3+0x168>
   43854:	84000044 	addi	r16,r16,1
   43858:	00803fc4 	movi	r2,255
   4385c:	80807526 	beq	r16,r2,43a34 <__subsf3+0x264>
   43860:	180691ba 	slli	r3,r3,6
   43864:	8880004c 	andi	r2,r17,1
   43868:	180ad27a 	srli	r5,r3,9
   4386c:	84003fcc 	andi	r16,r16,255
   43870:	800695fa 	slli	r3,r16,23
   43874:	10803fcc 	andi	r2,r2,255
   43878:	01002034 	movhi	r4,128
   4387c:	213fffc4 	addi	r4,r4,-1
   43880:	100497fa 	slli	r2,r2,31
   43884:	2920703a 	and	r16,r5,r4
   43888:	80e0b03a 	or	r16,r16,r3
   4388c:	8084b03a 	or	r2,r16,r2
   43890:	dfc00317 	ldw	ra,12(sp)
   43894:	dc800217 	ldw	r18,8(sp)
   43898:	dc400117 	ldw	r17,4(sp)
   4389c:	dc000017 	ldw	r16,0(sp)
   438a0:	dec00404 	addi	sp,sp,16
   438a4:	f800283a 	ret
   438a8:	00803fc4 	movi	r2,255
   438ac:	80bfe126 	beq	r16,r2,43834 <__alt_data_end+0xfffdb834>
   438b0:	39c10034 	orhi	r7,r7,1024
   438b4:	008006c4 	movi	r2,27
   438b8:	11007416 	blt	r2,r4,43a8c <__subsf3+0x2bc>
   438bc:	00800804 	movi	r2,32
   438c0:	1105c83a 	sub	r2,r2,r4
   438c4:	3884983a 	sll	r2,r7,r2
   438c8:	390ed83a 	srl	r7,r7,r4
   438cc:	1008c03a 	cmpne	r4,r2,zero
   438d0:	390eb03a 	or	r7,r7,r4
   438d4:	19c7c83a 	sub	r3,r3,r7
   438d8:	1881002c 	andhi	r2,r3,1024
   438dc:	10001426 	beq	r2,zero,43930 <__subsf3+0x160>
   438e0:	04810034 	movhi	r18,1024
   438e4:	94bfffc4 	addi	r18,r18,-1
   438e8:	1ca4703a 	and	r18,r3,r18
   438ec:	9009883a 	mov	r4,r18
   438f0:	0043e140 	call	43e14 <__clzsi2>
   438f4:	10bffec4 	addi	r2,r2,-5
   438f8:	90a4983a 	sll	r18,r18,r2
   438fc:	14005116 	blt	r2,r16,43a44 <__subsf3+0x274>
   43900:	1405c83a 	sub	r2,r2,r16
   43904:	10c00044 	addi	r3,r2,1
   43908:	00800804 	movi	r2,32
   4390c:	10c5c83a 	sub	r2,r2,r3
   43910:	9084983a 	sll	r2,r18,r2
   43914:	90e4d83a 	srl	r18,r18,r3
   43918:	0021883a 	mov	r16,zero
   4391c:	1006c03a 	cmpne	r3,r2,zero
   43920:	90c6b03a 	or	r3,r18,r3
   43924:	003fc306 	br	43834 <__alt_data_end+0xfffdb834>
   43928:	2000e026 	beq	r4,zero,43cac <__subsf3+0x4dc>
   4392c:	2007883a 	mov	r3,r4
   43930:	188001cc 	andi	r2,r3,7
   43934:	103fc11e 	bne	r2,zero,4383c <__alt_data_end+0xfffdb83c>
   43938:	180ad0fa 	srli	r5,r3,3
   4393c:	00c03fc4 	movi	r3,255
   43940:	8880004c 	andi	r2,r17,1
   43944:	80c0031e 	bne	r16,r3,43954 <__subsf3+0x184>
   43948:	28006d26 	beq	r5,zero,43b00 <__subsf3+0x330>
   4394c:	29401034 	orhi	r5,r5,64
   43950:	043fffc4 	movi	r16,-1
   43954:	00c02034 	movhi	r3,128
   43958:	18ffffc4 	addi	r3,r3,-1
   4395c:	28ca703a 	and	r5,r5,r3
   43960:	003fc206 	br	4386c <__alt_data_end+0xfffdb86c>
   43964:	01003c0e 	bge	zero,r4,43a58 <__subsf3+0x288>
   43968:	30002126 	beq	r6,zero,439f0 <__subsf3+0x220>
   4396c:	01403fc4 	movi	r5,255
   43970:	817fb026 	beq	r16,r5,43834 <__alt_data_end+0xfffdb834>
   43974:	39c10034 	orhi	r7,r7,1024
   43978:	014006c4 	movi	r5,27
   4397c:	29007416 	blt	r5,r4,43b50 <__subsf3+0x380>
   43980:	01400804 	movi	r5,32
   43984:	290bc83a 	sub	r5,r5,r4
   43988:	394a983a 	sll	r5,r7,r5
   4398c:	390ed83a 	srl	r7,r7,r4
   43990:	2808c03a 	cmpne	r4,r5,zero
   43994:	390eb03a 	or	r7,r7,r4
   43998:	19c7883a 	add	r3,r3,r7
   4399c:	1901002c 	andhi	r4,r3,1024
   439a0:	20003826 	beq	r4,zero,43a84 <__subsf3+0x2b4>
   439a4:	84000044 	addi	r16,r16,1
   439a8:	01003fc4 	movi	r4,255
   439ac:	81005426 	beq	r16,r4,43b00 <__subsf3+0x330>
   439b0:	1023883a 	mov	r17,r2
   439b4:	00bf0034 	movhi	r2,64512
   439b8:	10bfffc4 	addi	r2,r2,-1
   439bc:	1900004c 	andi	r4,r3,1
   439c0:	1886703a 	and	r3,r3,r2
   439c4:	1806d07a 	srli	r3,r3,1
   439c8:	1906b03a 	or	r3,r3,r4
   439cc:	003f9906 	br	43834 <__alt_data_end+0xfffdb834>
   439d0:	383f9226 	beq	r7,zero,4381c <__alt_data_end+0xfffdb81c>
   439d4:	10803fcc 	andi	r2,r2,255
   439d8:	003f9106 	br	43820 <__alt_data_end+0xfffdb820>
   439dc:	213fffc4 	addi	r4,r4,-1
   439e0:	203fbc26 	beq	r4,zero,438d4 <__alt_data_end+0xfffdb8d4>
   439e4:	00803fc4 	movi	r2,255
   439e8:	80bfb21e 	bne	r16,r2,438b4 <__alt_data_end+0xfffdb8b4>
   439ec:	003f9106 	br	43834 <__alt_data_end+0xfffdb834>
   439f0:	383f9026 	beq	r7,zero,43834 <__alt_data_end+0xfffdb834>
   439f4:	213fffc4 	addi	r4,r4,-1
   439f8:	203fe726 	beq	r4,zero,43998 <__alt_data_end+0xfffdb998>
   439fc:	01403fc4 	movi	r5,255
   43a00:	817fdd1e 	bne	r16,r5,43978 <__alt_data_end+0xfffdb978>
   43a04:	003f8b06 	br	43834 <__alt_data_end+0xfffdb834>
   43a08:	2000221e 	bne	r4,zero,43a94 <__subsf3+0x2c4>
   43a0c:	81000044 	addi	r4,r16,1
   43a10:	21003fcc 	andi	r4,r4,255
   43a14:	01400044 	movi	r5,1
   43a18:	2900470e 	bge	r5,r4,43b38 <__subsf3+0x368>
   43a1c:	19e5c83a 	sub	r18,r3,r7
   43a20:	9141002c 	andhi	r5,r18,1024
   43a24:	28002d26 	beq	r5,zero,43adc <__subsf3+0x30c>
   43a28:	38e5c83a 	sub	r18,r7,r3
   43a2c:	1023883a 	mov	r17,r2
   43a30:	003fae06 	br	438ec <__alt_data_end+0xfffdb8ec>
   43a34:	8880004c 	andi	r2,r17,1
   43a38:	043fffc4 	movi	r16,-1
   43a3c:	000b883a 	mov	r5,zero
   43a40:	003f8a06 	br	4386c <__alt_data_end+0xfffdb86c>
   43a44:	00ff0034 	movhi	r3,64512
   43a48:	18ffffc4 	addi	r3,r3,-1
   43a4c:	80a1c83a 	sub	r16,r16,r2
   43a50:	90c6703a 	and	r3,r18,r3
   43a54:	003f7706 	br	43834 <__alt_data_end+0xfffdb834>
   43a58:	2000431e 	bne	r4,zero,43b68 <__subsf3+0x398>
   43a5c:	81000044 	addi	r4,r16,1
   43a60:	21803fcc 	andi	r6,r4,255
   43a64:	01400044 	movi	r5,1
   43a68:	2980280e 	bge	r5,r6,43b0c <__subsf3+0x33c>
   43a6c:	01403fc4 	movi	r5,255
   43a70:	21402326 	beq	r4,r5,43b00 <__subsf3+0x330>
   43a74:	19c7883a 	add	r3,r3,r7
   43a78:	1806d07a 	srli	r3,r3,1
   43a7c:	2021883a 	mov	r16,r4
   43a80:	003f6c06 	br	43834 <__alt_data_end+0xfffdb834>
   43a84:	1023883a 	mov	r17,r2
   43a88:	003fa906 	br	43930 <__alt_data_end+0xfffdb930>
   43a8c:	01c00044 	movi	r7,1
   43a90:	003f9006 	br	438d4 <__alt_data_end+0xfffdb8d4>
   43a94:	8000151e 	bne	r16,zero,43aec <__subsf3+0x31c>
   43a98:	18002f26 	beq	r3,zero,43b58 <__subsf3+0x388>
   43a9c:	0108303a 	nor	r4,zero,r4
   43aa0:	20000a26 	beq	r4,zero,43acc <__subsf3+0x2fc>
   43aa4:	01403fc4 	movi	r5,255
   43aa8:	31402b26 	beq	r6,r5,43b58 <__subsf3+0x388>
   43aac:	014006c4 	movi	r5,27
   43ab0:	29006e16 	blt	r5,r4,43c6c <__subsf3+0x49c>
   43ab4:	01400804 	movi	r5,32
   43ab8:	290bc83a 	sub	r5,r5,r4
   43abc:	194a983a 	sll	r5,r3,r5
   43ac0:	1908d83a 	srl	r4,r3,r4
   43ac4:	2806c03a 	cmpne	r3,r5,zero
   43ac8:	20c6b03a 	or	r3,r4,r3
   43acc:	38c7c83a 	sub	r3,r7,r3
   43ad0:	3021883a 	mov	r16,r6
   43ad4:	1023883a 	mov	r17,r2
   43ad8:	003f7f06 	br	438d8 <__alt_data_end+0xfffdb8d8>
   43adc:	903f831e 	bne	r18,zero,438ec <__alt_data_end+0xfffdb8ec>
   43ae0:	0005883a 	mov	r2,zero
   43ae4:	0021883a 	mov	r16,zero
   43ae8:	003f9a06 	br	43954 <__alt_data_end+0xfffdb954>
   43aec:	01403fc4 	movi	r5,255
   43af0:	31401926 	beq	r6,r5,43b58 <__subsf3+0x388>
   43af4:	0109c83a 	sub	r4,zero,r4
   43af8:	18c10034 	orhi	r3,r3,1024
   43afc:	003feb06 	br	43aac <__alt_data_end+0xfffdbaac>
   43b00:	043fffc4 	movi	r16,-1
   43b04:	000b883a 	mov	r5,zero
   43b08:	003f5806 	br	4386c <__alt_data_end+0xfffdb86c>
   43b0c:	8000481e 	bne	r16,zero,43c30 <__subsf3+0x460>
   43b10:	18006226 	beq	r3,zero,43c9c <__subsf3+0x4cc>
   43b14:	383f4726 	beq	r7,zero,43834 <__alt_data_end+0xfffdb834>
   43b18:	19c7883a 	add	r3,r3,r7
   43b1c:	1881002c 	andhi	r2,r3,1024
   43b20:	103f8326 	beq	r2,zero,43930 <__alt_data_end+0xfffdb930>
   43b24:	00bf0034 	movhi	r2,64512
   43b28:	10bfffc4 	addi	r2,r2,-1
   43b2c:	2821883a 	mov	r16,r5
   43b30:	1886703a 	and	r3,r3,r2
   43b34:	003f3f06 	br	43834 <__alt_data_end+0xfffdb834>
   43b38:	80001c1e 	bne	r16,zero,43bac <__subsf3+0x3dc>
   43b3c:	1800261e 	bne	r3,zero,43bd8 <__subsf3+0x408>
   43b40:	38004c26 	beq	r7,zero,43c74 <__subsf3+0x4a4>
   43b44:	3807883a 	mov	r3,r7
   43b48:	1023883a 	mov	r17,r2
   43b4c:	003f3906 	br	43834 <__alt_data_end+0xfffdb834>
   43b50:	01c00044 	movi	r7,1
   43b54:	003f9006 	br	43998 <__alt_data_end+0xfffdb998>
   43b58:	3807883a 	mov	r3,r7
   43b5c:	3021883a 	mov	r16,r6
   43b60:	1023883a 	mov	r17,r2
   43b64:	003f3306 	br	43834 <__alt_data_end+0xfffdb834>
   43b68:	8000161e 	bne	r16,zero,43bc4 <__subsf3+0x3f4>
   43b6c:	18002d26 	beq	r3,zero,43c24 <__subsf3+0x454>
   43b70:	0108303a 	nor	r4,zero,r4
   43b74:	20000a26 	beq	r4,zero,43ba0 <__subsf3+0x3d0>
   43b78:	01403fc4 	movi	r5,255
   43b7c:	31402926 	beq	r6,r5,43c24 <__subsf3+0x454>
   43b80:	014006c4 	movi	r5,27
   43b84:	29004716 	blt	r5,r4,43ca4 <__subsf3+0x4d4>
   43b88:	01400804 	movi	r5,32
   43b8c:	290bc83a 	sub	r5,r5,r4
   43b90:	194a983a 	sll	r5,r3,r5
   43b94:	1908d83a 	srl	r4,r3,r4
   43b98:	2806c03a 	cmpne	r3,r5,zero
   43b9c:	20c6b03a 	or	r3,r4,r3
   43ba0:	19c7883a 	add	r3,r3,r7
   43ba4:	3021883a 	mov	r16,r6
   43ba8:	003f7c06 	br	4399c <__alt_data_end+0xfffdb99c>
   43bac:	1800111e 	bne	r3,zero,43bf4 <__subsf3+0x424>
   43bb0:	38003326 	beq	r7,zero,43c80 <__subsf3+0x4b0>
   43bb4:	3807883a 	mov	r3,r7
   43bb8:	1023883a 	mov	r17,r2
   43bbc:	04003fc4 	movi	r16,255
   43bc0:	003f1c06 	br	43834 <__alt_data_end+0xfffdb834>
   43bc4:	01403fc4 	movi	r5,255
   43bc8:	31401626 	beq	r6,r5,43c24 <__subsf3+0x454>
   43bcc:	0109c83a 	sub	r4,zero,r4
   43bd0:	18c10034 	orhi	r3,r3,1024
   43bd4:	003fea06 	br	43b80 <__alt_data_end+0xfffdbb80>
   43bd8:	383f1626 	beq	r7,zero,43834 <__alt_data_end+0xfffdb834>
   43bdc:	19c9c83a 	sub	r4,r3,r7
   43be0:	2141002c 	andhi	r5,r4,1024
   43be4:	283f5026 	beq	r5,zero,43928 <__alt_data_end+0xfffdb928>
   43be8:	38c7c83a 	sub	r3,r7,r3
   43bec:	1023883a 	mov	r17,r2
   43bf0:	003f1006 	br	43834 <__alt_data_end+0xfffdb834>
   43bf4:	38001b26 	beq	r7,zero,43c64 <__subsf3+0x494>
   43bf8:	1806d0fa 	srli	r3,r3,3
   43bfc:	1900102c 	andhi	r4,r3,64
   43c00:	20000526 	beq	r4,zero,43c18 <__subsf3+0x448>
   43c04:	380ed0fa 	srli	r7,r7,3
   43c08:	3900102c 	andhi	r4,r7,64
   43c0c:	2000021e 	bne	r4,zero,43c18 <__subsf3+0x448>
   43c10:	3807883a 	mov	r3,r7
   43c14:	1023883a 	mov	r17,r2
   43c18:	180690fa 	slli	r3,r3,3
   43c1c:	04003fc4 	movi	r16,255
   43c20:	003f0406 	br	43834 <__alt_data_end+0xfffdb834>
   43c24:	3807883a 	mov	r3,r7
   43c28:	3021883a 	mov	r16,r6
   43c2c:	003f0106 	br	43834 <__alt_data_end+0xfffdb834>
   43c30:	18001726 	beq	r3,zero,43c90 <__subsf3+0x4c0>
   43c34:	38000b26 	beq	r7,zero,43c64 <__subsf3+0x494>
   43c38:	1806d0fa 	srli	r3,r3,3
   43c3c:	1900102c 	andhi	r4,r3,64
   43c40:	20000426 	beq	r4,zero,43c54 <__subsf3+0x484>
   43c44:	380ed0fa 	srli	r7,r7,3
   43c48:	3900102c 	andhi	r4,r7,64
   43c4c:	2000011e 	bne	r4,zero,43c54 <__subsf3+0x484>
   43c50:	3807883a 	mov	r3,r7
   43c54:	180690fa 	slli	r3,r3,3
   43c58:	1023883a 	mov	r17,r2
   43c5c:	04003fc4 	movi	r16,255
   43c60:	003ef406 	br	43834 <__alt_data_end+0xfffdb834>
   43c64:	04003fc4 	movi	r16,255
   43c68:	003ef206 	br	43834 <__alt_data_end+0xfffdb834>
   43c6c:	00c00044 	movi	r3,1
   43c70:	003f9606 	br	43acc <__alt_data_end+0xfffdbacc>
   43c74:	000b883a 	mov	r5,zero
   43c78:	0005883a 	mov	r2,zero
   43c7c:	003f3506 	br	43954 <__alt_data_end+0xfffdb954>
   43c80:	01402034 	movhi	r5,128
   43c84:	297fffc4 	addi	r5,r5,-1
   43c88:	0005883a 	mov	r2,zero
   43c8c:	003f2f06 	br	4394c <__alt_data_end+0xfffdb94c>
   43c90:	3807883a 	mov	r3,r7
   43c94:	04003fc4 	movi	r16,255
   43c98:	003ee606 	br	43834 <__alt_data_end+0xfffdb834>
   43c9c:	3807883a 	mov	r3,r7
   43ca0:	003ee406 	br	43834 <__alt_data_end+0xfffdb834>
   43ca4:	00c00044 	movi	r3,1
   43ca8:	003fbd06 	br	43ba0 <__alt_data_end+0xfffdbba0>
   43cac:	0005883a 	mov	r2,zero
   43cb0:	003f2806 	br	43954 <__alt_data_end+0xfffdb954>

00043cb4 <__fixsfsi>:
   43cb4:	200ad5fa 	srli	r5,r4,23
   43cb8:	00c02034 	movhi	r3,128
   43cbc:	18ffffc4 	addi	r3,r3,-1
   43cc0:	29403fcc 	andi	r5,r5,255
   43cc4:	00801f84 	movi	r2,126
   43cc8:	1906703a 	and	r3,r3,r4
   43ccc:	2008d7fa 	srli	r4,r4,31
   43cd0:	11400e0e 	bge	r2,r5,43d0c <__fixsfsi+0x58>
   43cd4:	00802744 	movi	r2,157
   43cd8:	11400816 	blt	r2,r5,43cfc <__fixsfsi+0x48>
   43cdc:	00802544 	movi	r2,149
   43ce0:	18c02034 	orhi	r3,r3,128
   43ce4:	11400b0e 	bge	r2,r5,43d14 <__fixsfsi+0x60>
   43ce8:	28bfda84 	addi	r2,r5,-150
   43cec:	1884983a 	sll	r2,r3,r2
   43cf0:	20000726 	beq	r4,zero,43d10 <__fixsfsi+0x5c>
   43cf4:	0085c83a 	sub	r2,zero,r2
   43cf8:	f800283a 	ret
   43cfc:	00a00034 	movhi	r2,32768
   43d00:	10bfffc4 	addi	r2,r2,-1
   43d04:	2085883a 	add	r2,r4,r2
   43d08:	f800283a 	ret
   43d0c:	0005883a 	mov	r2,zero
   43d10:	f800283a 	ret
   43d14:	00802584 	movi	r2,150
   43d18:	1145c83a 	sub	r2,r2,r5
   43d1c:	1884d83a 	srl	r2,r3,r2
   43d20:	003ff306 	br	43cf0 <__alt_data_end+0xfffdbcf0>

00043d24 <__floatunsisf>:
   43d24:	defffe04 	addi	sp,sp,-8
   43d28:	dfc00115 	stw	ra,4(sp)
   43d2c:	dc000015 	stw	r16,0(sp)
   43d30:	20002c26 	beq	r4,zero,43de4 <__floatunsisf+0xc0>
   43d34:	2021883a 	mov	r16,r4
   43d38:	0043e140 	call	43e14 <__clzsi2>
   43d3c:	00c02784 	movi	r3,158
   43d40:	1887c83a 	sub	r3,r3,r2
   43d44:	01002584 	movi	r4,150
   43d48:	20c00f16 	blt	r4,r3,43d88 <__floatunsisf+0x64>
   43d4c:	20c9c83a 	sub	r4,r4,r3
   43d50:	8108983a 	sll	r4,r16,r4
   43d54:	00802034 	movhi	r2,128
   43d58:	10bfffc4 	addi	r2,r2,-1
   43d5c:	2088703a 	and	r4,r4,r2
   43d60:	18803fcc 	andi	r2,r3,255
   43d64:	100695fa 	slli	r3,r2,23
   43d68:	00802034 	movhi	r2,128
   43d6c:	10bfffc4 	addi	r2,r2,-1
   43d70:	2084703a 	and	r2,r4,r2
   43d74:	10c4b03a 	or	r2,r2,r3
   43d78:	dfc00117 	ldw	ra,4(sp)
   43d7c:	dc000017 	ldw	r16,0(sp)
   43d80:	dec00204 	addi	sp,sp,8
   43d84:	f800283a 	ret
   43d88:	01002644 	movi	r4,153
   43d8c:	20c01816 	blt	r4,r3,43df0 <__floatunsisf+0xcc>
   43d90:	20c9c83a 	sub	r4,r4,r3
   43d94:	8108983a 	sll	r4,r16,r4
   43d98:	017f0034 	movhi	r5,64512
   43d9c:	297fffc4 	addi	r5,r5,-1
   43da0:	218001cc 	andi	r6,r4,7
   43da4:	214a703a 	and	r5,r4,r5
   43da8:	30000426 	beq	r6,zero,43dbc <__floatunsisf+0x98>
   43dac:	210003cc 	andi	r4,r4,15
   43db0:	01800104 	movi	r6,4
   43db4:	21800126 	beq	r4,r6,43dbc <__floatunsisf+0x98>
   43db8:	298b883a 	add	r5,r5,r6
   43dbc:	2901002c 	andhi	r4,r5,1024
   43dc0:	20000526 	beq	r4,zero,43dd8 <__floatunsisf+0xb4>
   43dc4:	00c027c4 	movi	r3,159
   43dc8:	1887c83a 	sub	r3,r3,r2
   43dcc:	00bf0034 	movhi	r2,64512
   43dd0:	10bfffc4 	addi	r2,r2,-1
   43dd4:	288a703a 	and	r5,r5,r2
   43dd8:	280891ba 	slli	r4,r5,6
   43ddc:	2008d27a 	srli	r4,r4,9
   43de0:	003fdf06 	br	43d60 <__alt_data_end+0xfffdbd60>
   43de4:	0007883a 	mov	r3,zero
   43de8:	0009883a 	mov	r4,zero
   43dec:	003fdc06 	br	43d60 <__alt_data_end+0xfffdbd60>
   43df0:	01402e44 	movi	r5,185
   43df4:	28cbc83a 	sub	r5,r5,r3
   43df8:	01000144 	movi	r4,5
   43dfc:	2089c83a 	sub	r4,r4,r2
   43e00:	814a983a 	sll	r5,r16,r5
   43e04:	8108d83a 	srl	r4,r16,r4
   43e08:	2820c03a 	cmpne	r16,r5,zero
   43e0c:	2408b03a 	or	r4,r4,r16
   43e10:	003fe106 	br	43d98 <__alt_data_end+0xfffdbd98>

00043e14 <__clzsi2>:
   43e14:	00bfffd4 	movui	r2,65535
   43e18:	11000536 	bltu	r2,r4,43e30 <__clzsi2+0x1c>
   43e1c:	00803fc4 	movi	r2,255
   43e20:	11000f36 	bltu	r2,r4,43e60 <__clzsi2+0x4c>
   43e24:	00800804 	movi	r2,32
   43e28:	0007883a 	mov	r3,zero
   43e2c:	00000506 	br	43e44 <__clzsi2+0x30>
   43e30:	00804034 	movhi	r2,256
   43e34:	10bfffc4 	addi	r2,r2,-1
   43e38:	11000c2e 	bgeu	r2,r4,43e6c <__clzsi2+0x58>
   43e3c:	00800204 	movi	r2,8
   43e40:	00c00604 	movi	r3,24
   43e44:	20c8d83a 	srl	r4,r4,r3
   43e48:	00c00134 	movhi	r3,4
   43e4c:	18dd1284 	addi	r3,r3,29770
   43e50:	1909883a 	add	r4,r3,r4
   43e54:	20c00003 	ldbu	r3,0(r4)
   43e58:	10c5c83a 	sub	r2,r2,r3
   43e5c:	f800283a 	ret
   43e60:	00800604 	movi	r2,24
   43e64:	00c00204 	movi	r3,8
   43e68:	003ff606 	br	43e44 <__alt_data_end+0xfffdbe44>
   43e6c:	00800404 	movi	r2,16
   43e70:	1007883a 	mov	r3,r2
   43e74:	003ff306 	br	43e44 <__alt_data_end+0xfffdbe44>

00043e78 <_printf_r>:
   43e78:	defffd04 	addi	sp,sp,-12
   43e7c:	dfc00015 	stw	ra,0(sp)
   43e80:	d9800115 	stw	r6,4(sp)
   43e84:	d9c00215 	stw	r7,8(sp)
   43e88:	20c00217 	ldw	r3,8(r4)
   43e8c:	01800134 	movhi	r6,4
   43e90:	31915704 	addi	r6,r6,17756
   43e94:	19800115 	stw	r6,4(r3)
   43e98:	280d883a 	mov	r6,r5
   43e9c:	21400217 	ldw	r5,8(r4)
   43ea0:	d9c00104 	addi	r7,sp,4
   43ea4:	004401c0 	call	4401c <___vfprintf_internal_r>
   43ea8:	dfc00017 	ldw	ra,0(sp)
   43eac:	dec00304 	addi	sp,sp,12
   43eb0:	f800283a 	ret

00043eb4 <printf>:
   43eb4:	defffc04 	addi	sp,sp,-16
   43eb8:	dfc00015 	stw	ra,0(sp)
   43ebc:	d9400115 	stw	r5,4(sp)
   43ec0:	d9800215 	stw	r6,8(sp)
   43ec4:	d9c00315 	stw	r7,12(sp)
   43ec8:	00800134 	movhi	r2,4
   43ecc:	109e4004 	addi	r2,r2,30976
   43ed0:	10800017 	ldw	r2,0(r2)
   43ed4:	01400134 	movhi	r5,4
   43ed8:	29515704 	addi	r5,r5,17756
   43edc:	10c00217 	ldw	r3,8(r2)
   43ee0:	d9800104 	addi	r6,sp,4
   43ee4:	19400115 	stw	r5,4(r3)
   43ee8:	200b883a 	mov	r5,r4
   43eec:	11000217 	ldw	r4,8(r2)
   43ef0:	00445400 	call	44540 <__vfprintf_internal>
   43ef4:	dfc00017 	ldw	ra,0(sp)
   43ef8:	dec00404 	addi	sp,sp,16
   43efc:	f800283a 	ret

00043f00 <_puts_r>:
   43f00:	defffd04 	addi	sp,sp,-12
   43f04:	dc000015 	stw	r16,0(sp)
   43f08:	2021883a 	mov	r16,r4
   43f0c:	2809883a 	mov	r4,r5
   43f10:	dfc00215 	stw	ra,8(sp)
   43f14:	dc400115 	stw	r17,4(sp)
   43f18:	2823883a 	mov	r17,r5
   43f1c:	0043f940 	call	43f94 <strlen>
   43f20:	81400217 	ldw	r5,8(r16)
   43f24:	01000134 	movhi	r4,4
   43f28:	21115704 	addi	r4,r4,17756
   43f2c:	29000115 	stw	r4,4(r5)
   43f30:	100f883a 	mov	r7,r2
   43f34:	880d883a 	mov	r6,r17
   43f38:	8009883a 	mov	r4,r16
   43f3c:	004455c0 	call	4455c <__sfvwrite_small_dev>
   43f40:	00ffffc4 	movi	r3,-1
   43f44:	10c00926 	beq	r2,r3,43f6c <_puts_r+0x6c>
   43f48:	81400217 	ldw	r5,8(r16)
   43f4c:	01800134 	movhi	r6,4
   43f50:	01c00044 	movi	r7,1
   43f54:	28800117 	ldw	r2,4(r5)
   43f58:	319d5304 	addi	r6,r6,30028
   43f5c:	8009883a 	mov	r4,r16
   43f60:	103ee83a 	callr	r2
   43f64:	10bfffe0 	cmpeqi	r2,r2,-1
   43f68:	0085c83a 	sub	r2,zero,r2
   43f6c:	dfc00217 	ldw	ra,8(sp)
   43f70:	dc400117 	ldw	r17,4(sp)
   43f74:	dc000017 	ldw	r16,0(sp)
   43f78:	dec00304 	addi	sp,sp,12
   43f7c:	f800283a 	ret

00043f80 <puts>:
   43f80:	00800134 	movhi	r2,4
   43f84:	109e4004 	addi	r2,r2,30976
   43f88:	200b883a 	mov	r5,r4
   43f8c:	11000017 	ldw	r4,0(r2)
   43f90:	0043f001 	jmpi	43f00 <_puts_r>

00043f94 <strlen>:
   43f94:	2005883a 	mov	r2,r4
   43f98:	10c00007 	ldb	r3,0(r2)
   43f9c:	18000226 	beq	r3,zero,43fa8 <strlen+0x14>
   43fa0:	10800044 	addi	r2,r2,1
   43fa4:	003ffc06 	br	43f98 <__alt_data_end+0xfffdbf98>
   43fa8:	1105c83a 	sub	r2,r2,r4
   43fac:	f800283a 	ret

00043fb0 <print_repeat>:
   43fb0:	defffb04 	addi	sp,sp,-20
   43fb4:	dc800315 	stw	r18,12(sp)
   43fb8:	dc400215 	stw	r17,8(sp)
   43fbc:	dc000115 	stw	r16,4(sp)
   43fc0:	dfc00415 	stw	ra,16(sp)
   43fc4:	2025883a 	mov	r18,r4
   43fc8:	2823883a 	mov	r17,r5
   43fcc:	d9800005 	stb	r6,0(sp)
   43fd0:	3821883a 	mov	r16,r7
   43fd4:	04000a0e 	bge	zero,r16,44000 <print_repeat+0x50>
   43fd8:	88800117 	ldw	r2,4(r17)
   43fdc:	01c00044 	movi	r7,1
   43fe0:	d80d883a 	mov	r6,sp
   43fe4:	880b883a 	mov	r5,r17
   43fe8:	9009883a 	mov	r4,r18
   43fec:	103ee83a 	callr	r2
   43ff0:	843fffc4 	addi	r16,r16,-1
   43ff4:	103ff726 	beq	r2,zero,43fd4 <__alt_data_end+0xfffdbfd4>
   43ff8:	00bfffc4 	movi	r2,-1
   43ffc:	00000106 	br	44004 <print_repeat+0x54>
   44000:	0005883a 	mov	r2,zero
   44004:	dfc00417 	ldw	ra,16(sp)
   44008:	dc800317 	ldw	r18,12(sp)
   4400c:	dc400217 	ldw	r17,8(sp)
   44010:	dc000117 	ldw	r16,4(sp)
   44014:	dec00504 	addi	sp,sp,20
   44018:	f800283a 	ret

0004401c <___vfprintf_internal_r>:
   4401c:	deffe504 	addi	sp,sp,-108
   44020:	d8c00804 	addi	r3,sp,32
   44024:	df001915 	stw	fp,100(sp)
   44028:	ddc01815 	stw	r23,96(sp)
   4402c:	dd801715 	stw	r22,92(sp)
   44030:	dd401615 	stw	r21,88(sp)
   44034:	dd001515 	stw	r20,84(sp)
   44038:	dcc01415 	stw	r19,80(sp)
   4403c:	dc801315 	stw	r18,76(sp)
   44040:	dc401215 	stw	r17,72(sp)
   44044:	dc001115 	stw	r16,68(sp)
   44048:	dfc01a15 	stw	ra,104(sp)
   4404c:	2027883a 	mov	r19,r4
   44050:	2839883a 	mov	fp,r5
   44054:	382d883a 	mov	r22,r7
   44058:	d9800f15 	stw	r6,60(sp)
   4405c:	0021883a 	mov	r16,zero
   44060:	d8000e15 	stw	zero,56(sp)
   44064:	002f883a 	mov	r23,zero
   44068:	002b883a 	mov	r21,zero
   4406c:	0025883a 	mov	r18,zero
   44070:	0023883a 	mov	r17,zero
   44074:	d8000c15 	stw	zero,48(sp)
   44078:	d8000b15 	stw	zero,44(sp)
   4407c:	0029883a 	mov	r20,zero
   44080:	d8c00915 	stw	r3,36(sp)
   44084:	d8c00f17 	ldw	r3,60(sp)
   44088:	19000003 	ldbu	r4,0(r3)
   4408c:	20803fcc 	andi	r2,r4,255
   44090:	1080201c 	xori	r2,r2,128
   44094:	10bfe004 	addi	r2,r2,-128
   44098:	10011c26 	beq	r2,zero,4450c <___vfprintf_internal_r+0x4f0>
   4409c:	00c00044 	movi	r3,1
   440a0:	a0c01426 	beq	r20,r3,440f4 <___vfprintf_internal_r+0xd8>
   440a4:	1d000216 	blt	r3,r20,440b0 <___vfprintf_internal_r+0x94>
   440a8:	a0000626 	beq	r20,zero,440c4 <___vfprintf_internal_r+0xa8>
   440ac:	00011306 	br	444fc <___vfprintf_internal_r+0x4e0>
   440b0:	01400084 	movi	r5,2
   440b4:	a1401d26 	beq	r20,r5,4412c <___vfprintf_internal_r+0x110>
   440b8:	014000c4 	movi	r5,3
   440bc:	a1402926 	beq	r20,r5,44164 <___vfprintf_internal_r+0x148>
   440c0:	00010e06 	br	444fc <___vfprintf_internal_r+0x4e0>
   440c4:	01400944 	movi	r5,37
   440c8:	1140fb26 	beq	r2,r5,444b8 <___vfprintf_internal_r+0x49c>
   440cc:	e0800117 	ldw	r2,4(fp)
   440d0:	d9000005 	stb	r4,0(sp)
   440d4:	01c00044 	movi	r7,1
   440d8:	d80d883a 	mov	r6,sp
   440dc:	e00b883a 	mov	r5,fp
   440e0:	9809883a 	mov	r4,r19
   440e4:	103ee83a 	callr	r2
   440e8:	1000d61e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   440ec:	84000044 	addi	r16,r16,1
   440f0:	00010206 	br	444fc <___vfprintf_internal_r+0x4e0>
   440f4:	01400c04 	movi	r5,48
   440f8:	1140f826 	beq	r2,r5,444dc <___vfprintf_internal_r+0x4c0>
   440fc:	01400944 	movi	r5,37
   44100:	11400a1e 	bne	r2,r5,4412c <___vfprintf_internal_r+0x110>
   44104:	d8800005 	stb	r2,0(sp)
   44108:	e0800117 	ldw	r2,4(fp)
   4410c:	a00f883a 	mov	r7,r20
   44110:	d80d883a 	mov	r6,sp
   44114:	e00b883a 	mov	r5,fp
   44118:	9809883a 	mov	r4,r19
   4411c:	103ee83a 	callr	r2
   44120:	1000c81e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   44124:	84000044 	addi	r16,r16,1
   44128:	0000f306 	br	444f8 <___vfprintf_internal_r+0x4dc>
   4412c:	217ff404 	addi	r5,r4,-48
   44130:	29403fcc 	andi	r5,r5,255
   44134:	00c00244 	movi	r3,9
   44138:	19400736 	bltu	r3,r5,44158 <___vfprintf_internal_r+0x13c>
   4413c:	00bfffc4 	movi	r2,-1
   44140:	88800226 	beq	r17,r2,4414c <___vfprintf_internal_r+0x130>
   44144:	8c4002a4 	muli	r17,r17,10
   44148:	00000106 	br	44150 <___vfprintf_internal_r+0x134>
   4414c:	0023883a 	mov	r17,zero
   44150:	2c63883a 	add	r17,r5,r17
   44154:	0000e206 	br	444e0 <___vfprintf_internal_r+0x4c4>
   44158:	01400b84 	movi	r5,46
   4415c:	1140e426 	beq	r2,r5,444f0 <___vfprintf_internal_r+0x4d4>
   44160:	05000084 	movi	r20,2
   44164:	213ff404 	addi	r4,r4,-48
   44168:	21003fcc 	andi	r4,r4,255
   4416c:	00c00244 	movi	r3,9
   44170:	19000736 	bltu	r3,r4,44190 <___vfprintf_internal_r+0x174>
   44174:	00bfffc4 	movi	r2,-1
   44178:	90800226 	beq	r18,r2,44184 <___vfprintf_internal_r+0x168>
   4417c:	948002a4 	muli	r18,r18,10
   44180:	00000106 	br	44188 <___vfprintf_internal_r+0x16c>
   44184:	0025883a 	mov	r18,zero
   44188:	24a5883a 	add	r18,r4,r18
   4418c:	0000db06 	br	444fc <___vfprintf_internal_r+0x4e0>
   44190:	00c01b04 	movi	r3,108
   44194:	10c0d426 	beq	r2,r3,444e8 <___vfprintf_internal_r+0x4cc>
   44198:	013fffc4 	movi	r4,-1
   4419c:	91000226 	beq	r18,r4,441a8 <___vfprintf_internal_r+0x18c>
   441a0:	d8000b15 	stw	zero,44(sp)
   441a4:	00000106 	br	441ac <___vfprintf_internal_r+0x190>
   441a8:	04800044 	movi	r18,1
   441ac:	01001a44 	movi	r4,105
   441b0:	11001626 	beq	r2,r4,4420c <___vfprintf_internal_r+0x1f0>
   441b4:	20800916 	blt	r4,r2,441dc <___vfprintf_internal_r+0x1c0>
   441b8:	010018c4 	movi	r4,99
   441bc:	11008a26 	beq	r2,r4,443e8 <___vfprintf_internal_r+0x3cc>
   441c0:	01001904 	movi	r4,100
   441c4:	11001126 	beq	r2,r4,4420c <___vfprintf_internal_r+0x1f0>
   441c8:	01001604 	movi	r4,88
   441cc:	1100ca1e 	bne	r2,r4,444f8 <___vfprintf_internal_r+0x4dc>
   441d0:	00c00044 	movi	r3,1
   441d4:	d8c00e15 	stw	r3,56(sp)
   441d8:	00001406 	br	4422c <___vfprintf_internal_r+0x210>
   441dc:	01001cc4 	movi	r4,115
   441e0:	11009a26 	beq	r2,r4,4444c <___vfprintf_internal_r+0x430>
   441e4:	20800416 	blt	r4,r2,441f8 <___vfprintf_internal_r+0x1dc>
   441e8:	01001bc4 	movi	r4,111
   441ec:	1100c21e 	bne	r2,r4,444f8 <___vfprintf_internal_r+0x4dc>
   441f0:	05400204 	movi	r21,8
   441f4:	00000e06 	br	44230 <___vfprintf_internal_r+0x214>
   441f8:	01001d44 	movi	r4,117
   441fc:	11000c26 	beq	r2,r4,44230 <___vfprintf_internal_r+0x214>
   44200:	01001e04 	movi	r4,120
   44204:	11000926 	beq	r2,r4,4422c <___vfprintf_internal_r+0x210>
   44208:	0000bb06 	br	444f8 <___vfprintf_internal_r+0x4dc>
   4420c:	b5000104 	addi	r20,r22,4
   44210:	b8000726 	beq	r23,zero,44230 <___vfprintf_internal_r+0x214>
   44214:	dd000d15 	stw	r20,52(sp)
   44218:	b5800017 	ldw	r22,0(r22)
   4421c:	b000080e 	bge	r22,zero,44240 <___vfprintf_internal_r+0x224>
   44220:	05adc83a 	sub	r22,zero,r22
   44224:	02800044 	movi	r10,1
   44228:	00000606 	br	44244 <___vfprintf_internal_r+0x228>
   4422c:	05400404 	movi	r21,16
   44230:	b0c00104 	addi	r3,r22,4
   44234:	d8c00d15 	stw	r3,52(sp)
   44238:	b5800017 	ldw	r22,0(r22)
   4423c:	002f883a 	mov	r23,zero
   44240:	0015883a 	mov	r10,zero
   44244:	d829883a 	mov	r20,sp
   44248:	b0001426 	beq	r22,zero,4429c <___vfprintf_internal_r+0x280>
   4424c:	b009883a 	mov	r4,r22
   44250:	a80b883a 	mov	r5,r21
   44254:	da801015 	stw	r10,64(sp)
   44258:	004325c0 	call	4325c <__udivsi3>
   4425c:	1549383a 	mul	r4,r2,r21
   44260:	00c00244 	movi	r3,9
   44264:	da801017 	ldw	r10,64(sp)
   44268:	b12dc83a 	sub	r22,r22,r4
   4426c:	1d800216 	blt	r3,r22,44278 <___vfprintf_internal_r+0x25c>
   44270:	b5800c04 	addi	r22,r22,48
   44274:	00000506 	br	4428c <___vfprintf_internal_r+0x270>
   44278:	d8c00e17 	ldw	r3,56(sp)
   4427c:	18000226 	beq	r3,zero,44288 <___vfprintf_internal_r+0x26c>
   44280:	b5800dc4 	addi	r22,r22,55
   44284:	00000106 	br	4428c <___vfprintf_internal_r+0x270>
   44288:	b58015c4 	addi	r22,r22,87
   4428c:	a5800005 	stb	r22,0(r20)
   44290:	a5000044 	addi	r20,r20,1
   44294:	102d883a 	mov	r22,r2
   44298:	003feb06 	br	44248 <__alt_data_end+0xfffdc248>
   4429c:	a6c7c83a 	sub	r3,r20,sp
   442a0:	d8c00a15 	stw	r3,40(sp)
   442a4:	90c5c83a 	sub	r2,r18,r3
   442a8:	00800a0e 	bge	zero,r2,442d4 <___vfprintf_internal_r+0x2b8>
   442ac:	a085883a 	add	r2,r20,r2
   442b0:	01400c04 	movi	r5,48
   442b4:	d8c00917 	ldw	r3,36(sp)
   442b8:	a009883a 	mov	r4,r20
   442bc:	a0c0032e 	bgeu	r20,r3,442cc <___vfprintf_internal_r+0x2b0>
   442c0:	a5000044 	addi	r20,r20,1
   442c4:	21400005 	stb	r5,0(r4)
   442c8:	a0bffa1e 	bne	r20,r2,442b4 <__alt_data_end+0xfffdc2b4>
   442cc:	a6c7c83a 	sub	r3,r20,sp
   442d0:	d8c00a15 	stw	r3,40(sp)
   442d4:	d8c00a17 	ldw	r3,40(sp)
   442d8:	50d3883a 	add	r9,r10,r3
   442dc:	d8c00b17 	ldw	r3,44(sp)
   442e0:	8a6dc83a 	sub	r22,r17,r9
   442e4:	18001726 	beq	r3,zero,44344 <___vfprintf_internal_r+0x328>
   442e8:	50000a26 	beq	r10,zero,44314 <___vfprintf_internal_r+0x2f8>
   442ec:	00800b44 	movi	r2,45
   442f0:	d8800805 	stb	r2,32(sp)
   442f4:	e0800117 	ldw	r2,4(fp)
   442f8:	01c00044 	movi	r7,1
   442fc:	d9800804 	addi	r6,sp,32
   44300:	e00b883a 	mov	r5,fp
   44304:	9809883a 	mov	r4,r19
   44308:	103ee83a 	callr	r2
   4430c:	10004d1e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   44310:	84000044 	addi	r16,r16,1
   44314:	0580070e 	bge	zero,r22,44334 <___vfprintf_internal_r+0x318>
   44318:	b00f883a 	mov	r7,r22
   4431c:	01800c04 	movi	r6,48
   44320:	e00b883a 	mov	r5,fp
   44324:	9809883a 	mov	r4,r19
   44328:	0043fb00 	call	43fb0 <print_repeat>
   4432c:	1000451e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   44330:	85a1883a 	add	r16,r16,r22
   44334:	d8c00a17 	ldw	r3,40(sp)
   44338:	a013883a 	mov	r9,r20
   4433c:	1d2dc83a 	sub	r22,r3,r20
   44340:	00002206 	br	443cc <___vfprintf_internal_r+0x3b0>
   44344:	0580090e 	bge	zero,r22,4436c <___vfprintf_internal_r+0x350>
   44348:	b00f883a 	mov	r7,r22
   4434c:	01800804 	movi	r6,32
   44350:	e00b883a 	mov	r5,fp
   44354:	9809883a 	mov	r4,r19
   44358:	da801015 	stw	r10,64(sp)
   4435c:	0043fb00 	call	43fb0 <print_repeat>
   44360:	da801017 	ldw	r10,64(sp)
   44364:	1000371e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   44368:	85a1883a 	add	r16,r16,r22
   4436c:	503ff126 	beq	r10,zero,44334 <__alt_data_end+0xfffdc334>
   44370:	00800b44 	movi	r2,45
   44374:	d8800805 	stb	r2,32(sp)
   44378:	e0800117 	ldw	r2,4(fp)
   4437c:	01c00044 	movi	r7,1
   44380:	d9800804 	addi	r6,sp,32
   44384:	e00b883a 	mov	r5,fp
   44388:	9809883a 	mov	r4,r19
   4438c:	103ee83a 	callr	r2
   44390:	10002c1e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   44394:	84000044 	addi	r16,r16,1
   44398:	003fe606 	br	44334 <__alt_data_end+0xfffdc334>
   4439c:	4a7fffc4 	addi	r9,r9,-1
   443a0:	48800003 	ldbu	r2,0(r9)
   443a4:	01c00044 	movi	r7,1
   443a8:	d9800804 	addi	r6,sp,32
   443ac:	d8800805 	stb	r2,32(sp)
   443b0:	e0800117 	ldw	r2,4(fp)
   443b4:	e00b883a 	mov	r5,fp
   443b8:	da401015 	stw	r9,64(sp)
   443bc:	9809883a 	mov	r4,r19
   443c0:	103ee83a 	callr	r2
   443c4:	da401017 	ldw	r9,64(sp)
   443c8:	10001e1e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   443cc:	8245c83a 	sub	r2,r16,r9
   443d0:	4d89883a 	add	r4,r9,r22
   443d4:	a085883a 	add	r2,r20,r2
   443d8:	013ff016 	blt	zero,r4,4439c <__alt_data_end+0xfffdc39c>
   443dc:	1021883a 	mov	r16,r2
   443e0:	dd800d17 	ldw	r22,52(sp)
   443e4:	00004406 	br	444f8 <___vfprintf_internal_r+0x4dc>
   443e8:	00800044 	movi	r2,1
   443ec:	1440080e 	bge	r2,r17,44410 <___vfprintf_internal_r+0x3f4>
   443f0:	8d3fffc4 	addi	r20,r17,-1
   443f4:	a00f883a 	mov	r7,r20
   443f8:	01800804 	movi	r6,32
   443fc:	e00b883a 	mov	r5,fp
   44400:	9809883a 	mov	r4,r19
   44404:	0043fb00 	call	43fb0 <print_repeat>
   44408:	10000e1e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   4440c:	8521883a 	add	r16,r16,r20
   44410:	b0800017 	ldw	r2,0(r22)
   44414:	01c00044 	movi	r7,1
   44418:	d80d883a 	mov	r6,sp
   4441c:	d8800005 	stb	r2,0(sp)
   44420:	e0800117 	ldw	r2,4(fp)
   44424:	e00b883a 	mov	r5,fp
   44428:	9809883a 	mov	r4,r19
   4442c:	b5000104 	addi	r20,r22,4
   44430:	103ee83a 	callr	r2
   44434:	1000031e 	bne	r2,zero,44444 <___vfprintf_internal_r+0x428>
   44438:	84000044 	addi	r16,r16,1
   4443c:	a02d883a 	mov	r22,r20
   44440:	00002d06 	br	444f8 <___vfprintf_internal_r+0x4dc>
   44444:	00bfffc4 	movi	r2,-1
   44448:	00003106 	br	44510 <___vfprintf_internal_r+0x4f4>
   4444c:	b5000017 	ldw	r20,0(r22)
   44450:	b0c00104 	addi	r3,r22,4
   44454:	d8c00a15 	stw	r3,40(sp)
   44458:	a009883a 	mov	r4,r20
   4445c:	0043f940 	call	43f94 <strlen>
   44460:	8893c83a 	sub	r9,r17,r2
   44464:	102d883a 	mov	r22,r2
   44468:	0240090e 	bge	zero,r9,44490 <___vfprintf_internal_r+0x474>
   4446c:	480f883a 	mov	r7,r9
   44470:	01800804 	movi	r6,32
   44474:	e00b883a 	mov	r5,fp
   44478:	9809883a 	mov	r4,r19
   4447c:	da401015 	stw	r9,64(sp)
   44480:	0043fb00 	call	43fb0 <print_repeat>
   44484:	da401017 	ldw	r9,64(sp)
   44488:	103fee1e 	bne	r2,zero,44444 <__alt_data_end+0xfffdc444>
   4448c:	8261883a 	add	r16,r16,r9
   44490:	e0800117 	ldw	r2,4(fp)
   44494:	b00f883a 	mov	r7,r22
   44498:	a00d883a 	mov	r6,r20
   4449c:	e00b883a 	mov	r5,fp
   444a0:	9809883a 	mov	r4,r19
   444a4:	103ee83a 	callr	r2
   444a8:	103fe61e 	bne	r2,zero,44444 <__alt_data_end+0xfffdc444>
   444ac:	85a1883a 	add	r16,r16,r22
   444b0:	dd800a17 	ldw	r22,40(sp)
   444b4:	00001006 	br	444f8 <___vfprintf_internal_r+0x4dc>
   444b8:	05c00044 	movi	r23,1
   444bc:	04bfffc4 	movi	r18,-1
   444c0:	d8000e15 	stw	zero,56(sp)
   444c4:	05400284 	movi	r21,10
   444c8:	9023883a 	mov	r17,r18
   444cc:	d8000c15 	stw	zero,48(sp)
   444d0:	d8000b15 	stw	zero,44(sp)
   444d4:	b829883a 	mov	r20,r23
   444d8:	00000806 	br	444fc <___vfprintf_internal_r+0x4e0>
   444dc:	dd000b15 	stw	r20,44(sp)
   444e0:	05000084 	movi	r20,2
   444e4:	00000506 	br	444fc <___vfprintf_internal_r+0x4e0>
   444e8:	00c00044 	movi	r3,1
   444ec:	d8c00c15 	stw	r3,48(sp)
   444f0:	050000c4 	movi	r20,3
   444f4:	00000106 	br	444fc <___vfprintf_internal_r+0x4e0>
   444f8:	0029883a 	mov	r20,zero
   444fc:	d8c00f17 	ldw	r3,60(sp)
   44500:	18c00044 	addi	r3,r3,1
   44504:	d8c00f15 	stw	r3,60(sp)
   44508:	003ede06 	br	44084 <__alt_data_end+0xfffdc084>
   4450c:	8005883a 	mov	r2,r16
   44510:	dfc01a17 	ldw	ra,104(sp)
   44514:	df001917 	ldw	fp,100(sp)
   44518:	ddc01817 	ldw	r23,96(sp)
   4451c:	dd801717 	ldw	r22,92(sp)
   44520:	dd401617 	ldw	r21,88(sp)
   44524:	dd001517 	ldw	r20,84(sp)
   44528:	dcc01417 	ldw	r19,80(sp)
   4452c:	dc801317 	ldw	r18,76(sp)
   44530:	dc401217 	ldw	r17,72(sp)
   44534:	dc001117 	ldw	r16,68(sp)
   44538:	dec01b04 	addi	sp,sp,108
   4453c:	f800283a 	ret

00044540 <__vfprintf_internal>:
   44540:	00800134 	movhi	r2,4
   44544:	109e4004 	addi	r2,r2,30976
   44548:	300f883a 	mov	r7,r6
   4454c:	280d883a 	mov	r6,r5
   44550:	200b883a 	mov	r5,r4
   44554:	11000017 	ldw	r4,0(r2)
   44558:	004401c1 	jmpi	4401c <___vfprintf_internal_r>

0004455c <__sfvwrite_small_dev>:
   4455c:	2880000b 	ldhu	r2,0(r5)
   44560:	1080020c 	andi	r2,r2,8
   44564:	10002126 	beq	r2,zero,445ec <__sfvwrite_small_dev+0x90>
   44568:	2880008f 	ldh	r2,2(r5)
   4456c:	defffa04 	addi	sp,sp,-24
   44570:	dc000015 	stw	r16,0(sp)
   44574:	dfc00515 	stw	ra,20(sp)
   44578:	dd000415 	stw	r20,16(sp)
   4457c:	dcc00315 	stw	r19,12(sp)
   44580:	dc800215 	stw	r18,8(sp)
   44584:	dc400115 	stw	r17,4(sp)
   44588:	2821883a 	mov	r16,r5
   4458c:	10001216 	blt	r2,zero,445d8 <__sfvwrite_small_dev+0x7c>
   44590:	2027883a 	mov	r19,r4
   44594:	3025883a 	mov	r18,r6
   44598:	3823883a 	mov	r17,r7
   4459c:	05010004 	movi	r20,1024
   445a0:	04400b0e 	bge	zero,r17,445d0 <__sfvwrite_small_dev+0x74>
   445a4:	880f883a 	mov	r7,r17
   445a8:	a440010e 	bge	r20,r17,445b0 <__sfvwrite_small_dev+0x54>
   445ac:	01c10004 	movi	r7,1024
   445b0:	8140008f 	ldh	r5,2(r16)
   445b4:	900d883a 	mov	r6,r18
   445b8:	9809883a 	mov	r4,r19
   445bc:	00446140 	call	44614 <_write_r>
   445c0:	0080050e 	bge	zero,r2,445d8 <__sfvwrite_small_dev+0x7c>
   445c4:	88a3c83a 	sub	r17,r17,r2
   445c8:	90a5883a 	add	r18,r18,r2
   445cc:	003ff406 	br	445a0 <__alt_data_end+0xfffdc5a0>
   445d0:	0005883a 	mov	r2,zero
   445d4:	00000706 	br	445f4 <__sfvwrite_small_dev+0x98>
   445d8:	8080000b 	ldhu	r2,0(r16)
   445dc:	10801014 	ori	r2,r2,64
   445e0:	8080000d 	sth	r2,0(r16)
   445e4:	00bfffc4 	movi	r2,-1
   445e8:	00000206 	br	445f4 <__sfvwrite_small_dev+0x98>
   445ec:	00bfffc4 	movi	r2,-1
   445f0:	f800283a 	ret
   445f4:	dfc00517 	ldw	ra,20(sp)
   445f8:	dd000417 	ldw	r20,16(sp)
   445fc:	dcc00317 	ldw	r19,12(sp)
   44600:	dc800217 	ldw	r18,8(sp)
   44604:	dc400117 	ldw	r17,4(sp)
   44608:	dc000017 	ldw	r16,0(sp)
   4460c:	dec00604 	addi	sp,sp,24
   44610:	f800283a 	ret

00044614 <_write_r>:
   44614:	defffd04 	addi	sp,sp,-12
   44618:	dc000015 	stw	r16,0(sp)
   4461c:	04000134 	movhi	r16,4
   44620:	dc400115 	stw	r17,4(sp)
   44624:	841f3704 	addi	r16,r16,31964
   44628:	2023883a 	mov	r17,r4
   4462c:	2809883a 	mov	r4,r5
   44630:	300b883a 	mov	r5,r6
   44634:	380d883a 	mov	r6,r7
   44638:	dfc00215 	stw	ra,8(sp)
   4463c:	80000015 	stw	zero,0(r16)
   44640:	0044aa00 	call	44aa0 <write>
   44644:	00ffffc4 	movi	r3,-1
   44648:	10c0031e 	bne	r2,r3,44658 <_write_r+0x44>
   4464c:	80c00017 	ldw	r3,0(r16)
   44650:	18000126 	beq	r3,zero,44658 <_write_r+0x44>
   44654:	88c00015 	stw	r3,0(r17)
   44658:	dfc00217 	ldw	ra,8(sp)
   4465c:	dc400117 	ldw	r17,4(sp)
   44660:	dc000017 	ldw	r16,0(sp)
   44664:	dec00304 	addi	sp,sp,12
   44668:	f800283a 	ret

0004466c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   4466c:	defff904 	addi	sp,sp,-28
   44670:	dfc00615 	stw	ra,24(sp)
   44674:	df000515 	stw	fp,20(sp)
   44678:	df000504 	addi	fp,sp,20
   4467c:	e13ffc15 	stw	r4,-16(fp)
   44680:	e17ffd15 	stw	r5,-12(fp)
   44684:	e1bffe15 	stw	r6,-8(fp)
   44688:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   4468c:	e0800217 	ldw	r2,8(fp)
   44690:	d8800015 	stw	r2,0(sp)
   44694:	e1ffff17 	ldw	r7,-4(fp)
   44698:	e1bffe17 	ldw	r6,-8(fp)
   4469c:	e17ffd17 	ldw	r5,-12(fp)
   446a0:	e13ffc17 	ldw	r4,-16(fp)
   446a4:	004481c0 	call	4481c <alt_iic_isr_register>
}  
   446a8:	e037883a 	mov	sp,fp
   446ac:	dfc00117 	ldw	ra,4(sp)
   446b0:	df000017 	ldw	fp,0(sp)
   446b4:	dec00204 	addi	sp,sp,8
   446b8:	f800283a 	ret

000446bc <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
   446bc:	defff904 	addi	sp,sp,-28
   446c0:	df000615 	stw	fp,24(sp)
   446c4:	df000604 	addi	fp,sp,24
   446c8:	e13ffe15 	stw	r4,-8(fp)
   446cc:	e17fff15 	stw	r5,-4(fp)
   446d0:	e0bfff17 	ldw	r2,-4(fp)
   446d4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   446d8:	0005303a 	rdctl	r2,status
   446dc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   446e0:	e0fffb17 	ldw	r3,-20(fp)
   446e4:	00bfff84 	movi	r2,-2
   446e8:	1884703a 	and	r2,r3,r2
   446ec:	1001703a 	wrctl	status,r2
  
  return context;
   446f0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   446f4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
   446f8:	00c00044 	movi	r3,1
   446fc:	e0bffa17 	ldw	r2,-24(fp)
   44700:	1884983a 	sll	r2,r3,r2
   44704:	1007883a 	mov	r3,r2
   44708:	d0a10017 	ldw	r2,-31744(gp)
   4470c:	1884b03a 	or	r2,r3,r2
   44710:	d0a10015 	stw	r2,-31744(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   44714:	d0a10017 	ldw	r2,-31744(gp)
   44718:	100170fa 	wrctl	ienable,r2
   4471c:	e0bffc17 	ldw	r2,-16(fp)
   44720:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   44724:	e0bffd17 	ldw	r2,-12(fp)
   44728:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   4472c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
   44730:	0001883a 	nop
}
   44734:	e037883a 	mov	sp,fp
   44738:	df000017 	ldw	fp,0(sp)
   4473c:	dec00104 	addi	sp,sp,4
   44740:	f800283a 	ret

00044744 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
   44744:	defff904 	addi	sp,sp,-28
   44748:	df000615 	stw	fp,24(sp)
   4474c:	df000604 	addi	fp,sp,24
   44750:	e13ffe15 	stw	r4,-8(fp)
   44754:	e17fff15 	stw	r5,-4(fp)
   44758:	e0bfff17 	ldw	r2,-4(fp)
   4475c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   44760:	0005303a 	rdctl	r2,status
   44764:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   44768:	e0fffb17 	ldw	r3,-20(fp)
   4476c:	00bfff84 	movi	r2,-2
   44770:	1884703a 	and	r2,r3,r2
   44774:	1001703a 	wrctl	status,r2
  
  return context;
   44778:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   4477c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
   44780:	00c00044 	movi	r3,1
   44784:	e0bffa17 	ldw	r2,-24(fp)
   44788:	1884983a 	sll	r2,r3,r2
   4478c:	0084303a 	nor	r2,zero,r2
   44790:	1007883a 	mov	r3,r2
   44794:	d0a10017 	ldw	r2,-31744(gp)
   44798:	1884703a 	and	r2,r3,r2
   4479c:	d0a10015 	stw	r2,-31744(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   447a0:	d0a10017 	ldw	r2,-31744(gp)
   447a4:	100170fa 	wrctl	ienable,r2
   447a8:	e0bffc17 	ldw	r2,-16(fp)
   447ac:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   447b0:	e0bffd17 	ldw	r2,-12(fp)
   447b4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   447b8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
   447bc:	0001883a 	nop
}
   447c0:	e037883a 	mov	sp,fp
   447c4:	df000017 	ldw	fp,0(sp)
   447c8:	dec00104 	addi	sp,sp,4
   447cc:	f800283a 	ret

000447d0 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
   447d0:	defffc04 	addi	sp,sp,-16
   447d4:	df000315 	stw	fp,12(sp)
   447d8:	df000304 	addi	fp,sp,12
   447dc:	e13ffe15 	stw	r4,-8(fp)
   447e0:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   447e4:	000530fa 	rdctl	r2,ienable
   447e8:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
   447ec:	00c00044 	movi	r3,1
   447f0:	e0bfff17 	ldw	r2,-4(fp)
   447f4:	1884983a 	sll	r2,r3,r2
   447f8:	1007883a 	mov	r3,r2
   447fc:	e0bffd17 	ldw	r2,-12(fp)
   44800:	1884703a 	and	r2,r3,r2
   44804:	1004c03a 	cmpne	r2,r2,zero
   44808:	10803fcc 	andi	r2,r2,255
}
   4480c:	e037883a 	mov	sp,fp
   44810:	df000017 	ldw	fp,0(sp)
   44814:	dec00104 	addi	sp,sp,4
   44818:	f800283a 	ret

0004481c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   4481c:	defff504 	addi	sp,sp,-44
   44820:	dfc00a15 	stw	ra,40(sp)
   44824:	df000915 	stw	fp,36(sp)
   44828:	df000904 	addi	fp,sp,36
   4482c:	e13ffc15 	stw	r4,-16(fp)
   44830:	e17ffd15 	stw	r5,-12(fp)
   44834:	e1bffe15 	stw	r6,-8(fp)
   44838:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
   4483c:	00bffa84 	movi	r2,-22
   44840:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
   44844:	e0bffd17 	ldw	r2,-12(fp)
   44848:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   4484c:	e0bff817 	ldw	r2,-32(fp)
   44850:	10800808 	cmpgei	r2,r2,32
   44854:	1000271e 	bne	r2,zero,448f4 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   44858:	0005303a 	rdctl	r2,status
   4485c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   44860:	e0fffb17 	ldw	r3,-20(fp)
   44864:	00bfff84 	movi	r2,-2
   44868:	1884703a 	and	r2,r3,r2
   4486c:	1001703a 	wrctl	status,r2
  
  return context;
   44870:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
   44874:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
   44878:	00800134 	movhi	r2,4
   4487c:	109f3d04 	addi	r2,r2,31988
   44880:	e0fff817 	ldw	r3,-32(fp)
   44884:	180690fa 	slli	r3,r3,3
   44888:	10c5883a 	add	r2,r2,r3
   4488c:	e0fffe17 	ldw	r3,-8(fp)
   44890:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
   44894:	00800134 	movhi	r2,4
   44898:	109f3d04 	addi	r2,r2,31988
   4489c:	e0fff817 	ldw	r3,-32(fp)
   448a0:	180690fa 	slli	r3,r3,3
   448a4:	10c5883a 	add	r2,r2,r3
   448a8:	10800104 	addi	r2,r2,4
   448ac:	e0ffff17 	ldw	r3,-4(fp)
   448b0:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   448b4:	e0bffe17 	ldw	r2,-8(fp)
   448b8:	10000526 	beq	r2,zero,448d0 <alt_iic_isr_register+0xb4>
   448bc:	e0bff817 	ldw	r2,-32(fp)
   448c0:	100b883a 	mov	r5,r2
   448c4:	e13ffc17 	ldw	r4,-16(fp)
   448c8:	00446bc0 	call	446bc <alt_ic_irq_enable>
   448cc:	00000406 	br	448e0 <alt_iic_isr_register+0xc4>
   448d0:	e0bff817 	ldw	r2,-32(fp)
   448d4:	100b883a 	mov	r5,r2
   448d8:	e13ffc17 	ldw	r4,-16(fp)
   448dc:	00447440 	call	44744 <alt_ic_irq_disable>
   448e0:	e0bff715 	stw	r2,-36(fp)
   448e4:	e0bffa17 	ldw	r2,-24(fp)
   448e8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   448ec:	e0bff917 	ldw	r2,-28(fp)
   448f0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
   448f4:	e0bff717 	ldw	r2,-36(fp)
}
   448f8:	e037883a 	mov	sp,fp
   448fc:	dfc00117 	ldw	ra,4(sp)
   44900:	df000017 	ldw	fp,0(sp)
   44904:	dec00204 	addi	sp,sp,8
   44908:	f800283a 	ret

0004490c <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   4490c:	defffc04 	addi	sp,sp,-16
   44910:	df000315 	stw	fp,12(sp)
   44914:	df000304 	addi	fp,sp,12
   44918:	e13ffd15 	stw	r4,-12(fp)
   4491c:	e17ffe15 	stw	r5,-8(fp)
   44920:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   44924:	e0fffe17 	ldw	r3,-8(fp)
   44928:	e0bffd17 	ldw	r2,-12(fp)
   4492c:	18800c26 	beq	r3,r2,44960 <alt_load_section+0x54>
  {
    while( to != end )
   44930:	00000806 	br	44954 <alt_load_section+0x48>
    {
      *to++ = *from++;
   44934:	e0bffe17 	ldw	r2,-8(fp)
   44938:	10c00104 	addi	r3,r2,4
   4493c:	e0fffe15 	stw	r3,-8(fp)
   44940:	e0fffd17 	ldw	r3,-12(fp)
   44944:	19000104 	addi	r4,r3,4
   44948:	e13ffd15 	stw	r4,-12(fp)
   4494c:	18c00017 	ldw	r3,0(r3)
   44950:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   44954:	e0fffe17 	ldw	r3,-8(fp)
   44958:	e0bfff17 	ldw	r2,-4(fp)
   4495c:	18bff51e 	bne	r3,r2,44934 <__alt_data_end+0xfffdc934>
    {
      *to++ = *from++;
    }
  }
}
   44960:	0001883a 	nop
   44964:	e037883a 	mov	sp,fp
   44968:	df000017 	ldw	fp,0(sp)
   4496c:	dec00104 	addi	sp,sp,4
   44970:	f800283a 	ret

00044974 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   44974:	defffe04 	addi	sp,sp,-8
   44978:	dfc00115 	stw	ra,4(sp)
   4497c:	df000015 	stw	fp,0(sp)
   44980:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   44984:	01800134 	movhi	r6,4
   44988:	319e4804 	addi	r6,r6,31008
   4498c:	01400134 	movhi	r5,4
   44990:	295d6104 	addi	r5,r5,30084
   44994:	01000134 	movhi	r4,4
   44998:	211e4804 	addi	r4,r4,31008
   4499c:	004490c0 	call	4490c <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   449a0:	01800134 	movhi	r6,4
   449a4:	31809104 	addi	r6,r6,580
   449a8:	01400134 	movhi	r5,4
   449ac:	29400804 	addi	r5,r5,32
   449b0:	01000134 	movhi	r4,4
   449b4:	21000804 	addi	r4,r4,32
   449b8:	004490c0 	call	4490c <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   449bc:	01800134 	movhi	r6,4
   449c0:	319d6104 	addi	r6,r6,30084
   449c4:	01400134 	movhi	r5,4
   449c8:	2956a004 	addi	r5,r5,23168
   449cc:	01000134 	movhi	r4,4
   449d0:	2116a004 	addi	r4,r4,23168
   449d4:	004490c0 	call	4490c <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   449d8:	0044f880 	call	44f88 <alt_dcache_flush_all>
  alt_icache_flush_all();
   449dc:	00450b40 	call	450b4 <alt_icache_flush_all>
}
   449e0:	0001883a 	nop
   449e4:	e037883a 	mov	sp,fp
   449e8:	dfc00117 	ldw	ra,4(sp)
   449ec:	df000017 	ldw	fp,0(sp)
   449f0:	dec00204 	addi	sp,sp,8
   449f4:	f800283a 	ret

000449f8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   449f8:	defffd04 	addi	sp,sp,-12
   449fc:	dfc00215 	stw	ra,8(sp)
   44a00:	df000115 	stw	fp,4(sp)
   44a04:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   44a08:	0009883a 	mov	r4,zero
   44a0c:	0044bcc0 	call	44bcc <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   44a10:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   44a14:	0044c040 	call	44c04 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   44a18:	01800134 	movhi	r6,4
   44a1c:	319d5404 	addi	r6,r6,30032
   44a20:	01400134 	movhi	r5,4
   44a24:	295d5404 	addi	r5,r5,30032
   44a28:	01000134 	movhi	r4,4
   44a2c:	211d5404 	addi	r4,r4,30032
   44a30:	00452480 	call	45248 <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   44a34:	d0a10117 	ldw	r2,-31740(gp)
   44a38:	d0e10217 	ldw	r3,-31736(gp)
   44a3c:	d1210317 	ldw	r4,-31732(gp)
   44a40:	200d883a 	mov	r6,r4
   44a44:	180b883a 	mov	r5,r3
   44a48:	1009883a 	mov	r4,r2
   44a4c:	0040c700 	call	40c70 <main>
   44a50:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   44a54:	01000044 	movi	r4,1
   44a58:	0044eb80 	call	44eb8 <close>
  exit (result);
   44a5c:	e13fff17 	ldw	r4,-4(fp)
   44a60:	004586c0 	call	4586c <exit>

00044a64 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   44a64:	defffe04 	addi	sp,sp,-8
   44a68:	dfc00115 	stw	ra,4(sp)
   44a6c:	df000015 	stw	fp,0(sp)
   44a70:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   44a74:	d0a00f17 	ldw	r2,-32708(gp)
   44a78:	10000326 	beq	r2,zero,44a88 <alt_get_errno+0x24>
   44a7c:	d0a00f17 	ldw	r2,-32708(gp)
   44a80:	103ee83a 	callr	r2
   44a84:	00000106 	br	44a8c <alt_get_errno+0x28>
   44a88:	d0a0ff04 	addi	r2,gp,-31748
}
   44a8c:	e037883a 	mov	sp,fp
   44a90:	dfc00117 	ldw	ra,4(sp)
   44a94:	df000017 	ldw	fp,0(sp)
   44a98:	dec00204 	addi	sp,sp,8
   44a9c:	f800283a 	ret

00044aa0 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   44aa0:	defff904 	addi	sp,sp,-28
   44aa4:	dfc00615 	stw	ra,24(sp)
   44aa8:	df000515 	stw	fp,20(sp)
   44aac:	df000504 	addi	fp,sp,20
   44ab0:	e13ffd15 	stw	r4,-12(fp)
   44ab4:	e17ffe15 	stw	r5,-8(fp)
   44ab8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   44abc:	e0bffd17 	ldw	r2,-12(fp)
   44ac0:	10000616 	blt	r2,zero,44adc <write+0x3c>
   44ac4:	e0bffd17 	ldw	r2,-12(fp)
   44ac8:	10c00324 	muli	r3,r2,12
   44acc:	00800134 	movhi	r2,4
   44ad0:	109dd804 	addi	r2,r2,30560
   44ad4:	1885883a 	add	r2,r3,r2
   44ad8:	00000106 	br	44ae0 <write+0x40>
   44adc:	0005883a 	mov	r2,zero
   44ae0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   44ae4:	e0bffb17 	ldw	r2,-20(fp)
   44ae8:	10002126 	beq	r2,zero,44b70 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   44aec:	e0bffb17 	ldw	r2,-20(fp)
   44af0:	10800217 	ldw	r2,8(r2)
   44af4:	108000cc 	andi	r2,r2,3
   44af8:	10001826 	beq	r2,zero,44b5c <write+0xbc>
   44afc:	e0bffb17 	ldw	r2,-20(fp)
   44b00:	10800017 	ldw	r2,0(r2)
   44b04:	10800617 	ldw	r2,24(r2)
   44b08:	10001426 	beq	r2,zero,44b5c <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   44b0c:	e0bffb17 	ldw	r2,-20(fp)
   44b10:	10800017 	ldw	r2,0(r2)
   44b14:	10800617 	ldw	r2,24(r2)
   44b18:	e0ffff17 	ldw	r3,-4(fp)
   44b1c:	180d883a 	mov	r6,r3
   44b20:	e17ffe17 	ldw	r5,-8(fp)
   44b24:	e13ffb17 	ldw	r4,-20(fp)
   44b28:	103ee83a 	callr	r2
   44b2c:	e0bffc15 	stw	r2,-16(fp)
   44b30:	e0bffc17 	ldw	r2,-16(fp)
   44b34:	1000070e 	bge	r2,zero,44b54 <write+0xb4>
      {
        ALT_ERRNO = -rval;
   44b38:	0044a640 	call	44a64 <alt_get_errno>
   44b3c:	1007883a 	mov	r3,r2
   44b40:	e0bffc17 	ldw	r2,-16(fp)
   44b44:	0085c83a 	sub	r2,zero,r2
   44b48:	18800015 	stw	r2,0(r3)
        return -1;
   44b4c:	00bfffc4 	movi	r2,-1
   44b50:	00000c06 	br	44b84 <write+0xe4>
      }
      return rval;
   44b54:	e0bffc17 	ldw	r2,-16(fp)
   44b58:	00000a06 	br	44b84 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
   44b5c:	0044a640 	call	44a64 <alt_get_errno>
   44b60:	1007883a 	mov	r3,r2
   44b64:	00800344 	movi	r2,13
   44b68:	18800015 	stw	r2,0(r3)
   44b6c:	00000406 	br	44b80 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   44b70:	0044a640 	call	44a64 <alt_get_errno>
   44b74:	1007883a 	mov	r3,r2
   44b78:	00801444 	movi	r2,81
   44b7c:	18800015 	stw	r2,0(r3)
  }
  return -1;
   44b80:	00bfffc4 	movi	r2,-1
}
   44b84:	e037883a 	mov	sp,fp
   44b88:	dfc00117 	ldw	ra,4(sp)
   44b8c:	df000017 	ldw	fp,0(sp)
   44b90:	dec00204 	addi	sp,sp,8
   44b94:	f800283a 	ret

00044b98 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   44b98:	defffd04 	addi	sp,sp,-12
   44b9c:	dfc00215 	stw	ra,8(sp)
   44ba0:	df000115 	stw	fp,4(sp)
   44ba4:	df000104 	addi	fp,sp,4
   44ba8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   44bac:	d1600c04 	addi	r5,gp,-32720
   44bb0:	e13fff17 	ldw	r4,-4(fp)
   44bb4:	00450100 	call	45010 <alt_dev_llist_insert>
}
   44bb8:	e037883a 	mov	sp,fp
   44bbc:	dfc00117 	ldw	ra,4(sp)
   44bc0:	df000017 	ldw	fp,0(sp)
   44bc4:	dec00204 	addi	sp,sp,8
   44bc8:	f800283a 	ret

00044bcc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   44bcc:	defffd04 	addi	sp,sp,-12
   44bd0:	dfc00215 	stw	ra,8(sp)
   44bd4:	df000115 	stw	fp,4(sp)
   44bd8:	df000104 	addi	fp,sp,4
   44bdc:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOSII_CPU, NiosII_CPU);
   44be0:	004557c0 	call	4557c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   44be4:	00800044 	movi	r2,1
   44be8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   44bec:	0001883a 	nop
   44bf0:	e037883a 	mov	sp,fp
   44bf4:	dfc00117 	ldw	ra,4(sp)
   44bf8:	df000017 	ldw	fp,0(sp)
   44bfc:	dec00204 	addi	sp,sp,8
   44c00:	f800283a 	ret

00044c04 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   44c04:	defffe04 	addi	sp,sp,-8
   44c08:	dfc00115 	stw	ra,4(sp)
   44c0c:	df000015 	stw	fp,0(sp)
   44c10:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_PWM, timer_pwm);
    ALTERA_AVALON_TIMER_INIT ( TIMER_SECOND, timer_second);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
   44c14:	01000134 	movhi	r4,4
   44c18:	211dc304 	addi	r4,r4,30476
   44c1c:	0044b980 	call	44b98 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
   44c20:	0001883a 	nop
}
   44c24:	0001883a 	nop
   44c28:	e037883a 	mov	sp,fp
   44c2c:	dfc00117 	ldw	ra,4(sp)
   44c30:	df000017 	ldw	fp,0(sp)
   44c34:	dec00204 	addi	sp,sp,8
   44c38:	f800283a 	ret

00044c3c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   44c3c:	defffa04 	addi	sp,sp,-24
   44c40:	dfc00515 	stw	ra,20(sp)
   44c44:	df000415 	stw	fp,16(sp)
   44c48:	df000404 	addi	fp,sp,16
   44c4c:	e13ffd15 	stw	r4,-12(fp)
   44c50:	e17ffe15 	stw	r5,-8(fp)
   44c54:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   44c58:	e0bffd17 	ldw	r2,-12(fp)
   44c5c:	10800017 	ldw	r2,0(r2)
   44c60:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   44c64:	e0bffc17 	ldw	r2,-16(fp)
   44c68:	10c00a04 	addi	r3,r2,40
   44c6c:	e0bffd17 	ldw	r2,-12(fp)
   44c70:	10800217 	ldw	r2,8(r2)
   44c74:	100f883a 	mov	r7,r2
   44c78:	e1bfff17 	ldw	r6,-4(fp)
   44c7c:	e17ffe17 	ldw	r5,-8(fp)
   44c80:	1809883a 	mov	r4,r3
   44c84:	0044cfc0 	call	44cfc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   44c88:	e037883a 	mov	sp,fp
   44c8c:	dfc00117 	ldw	ra,4(sp)
   44c90:	df000017 	ldw	fp,0(sp)
   44c94:	dec00204 	addi	sp,sp,8
   44c98:	f800283a 	ret

00044c9c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   44c9c:	defffa04 	addi	sp,sp,-24
   44ca0:	dfc00515 	stw	ra,20(sp)
   44ca4:	df000415 	stw	fp,16(sp)
   44ca8:	df000404 	addi	fp,sp,16
   44cac:	e13ffd15 	stw	r4,-12(fp)
   44cb0:	e17ffe15 	stw	r5,-8(fp)
   44cb4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   44cb8:	e0bffd17 	ldw	r2,-12(fp)
   44cbc:	10800017 	ldw	r2,0(r2)
   44cc0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   44cc4:	e0bffc17 	ldw	r2,-16(fp)
   44cc8:	10c00a04 	addi	r3,r2,40
   44ccc:	e0bffd17 	ldw	r2,-12(fp)
   44cd0:	10800217 	ldw	r2,8(r2)
   44cd4:	100f883a 	mov	r7,r2
   44cd8:	e1bfff17 	ldw	r6,-4(fp)
   44cdc:	e17ffe17 	ldw	r5,-8(fp)
   44ce0:	1809883a 	mov	r4,r3
   44ce4:	0044de80 	call	44de8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   44ce8:	e037883a 	mov	sp,fp
   44cec:	dfc00117 	ldw	ra,4(sp)
   44cf0:	df000017 	ldw	fp,0(sp)
   44cf4:	dec00204 	addi	sp,sp,8
   44cf8:	f800283a 	ret

00044cfc <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
   44cfc:	defff704 	addi	sp,sp,-36
   44d00:	df000815 	stw	fp,32(sp)
   44d04:	df000804 	addi	fp,sp,32
   44d08:	e13ffc15 	stw	r4,-16(fp)
   44d0c:	e17ffd15 	stw	r5,-12(fp)
   44d10:	e1bffe15 	stw	r6,-8(fp)
   44d14:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   44d18:	e0bffc17 	ldw	r2,-16(fp)
   44d1c:	10800017 	ldw	r2,0(r2)
   44d20:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
   44d24:	e0bffd17 	ldw	r2,-12(fp)
   44d28:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
   44d2c:	e0bffe17 	ldw	r2,-8(fp)
   44d30:	e0fffd17 	ldw	r3,-12(fp)
   44d34:	1885883a 	add	r2,r3,r2
   44d38:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
   44d3c:	00001206 	br	44d88 <altera_avalon_jtag_uart_read+0x8c>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   44d40:	e0bff917 	ldw	r2,-28(fp)
   44d44:	10800037 	ldwio	r2,0(r2)
   44d48:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
   44d4c:	e0bffb17 	ldw	r2,-20(fp)
   44d50:	10a0000c 	andi	r2,r2,32768
   44d54:	10000626 	beq	r2,zero,44d70 <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   44d58:	e0bff817 	ldw	r2,-32(fp)
   44d5c:	10c00044 	addi	r3,r2,1
   44d60:	e0fff815 	stw	r3,-32(fp)
   44d64:	e0fffb17 	ldw	r3,-20(fp)
   44d68:	10c00005 	stb	r3,0(r2)
   44d6c:	00000606 	br	44d88 <altera_avalon_jtag_uart_read+0x8c>
    else if (ptr != buffer)
   44d70:	e0fff817 	ldw	r3,-32(fp)
   44d74:	e0bffd17 	ldw	r2,-12(fp)
   44d78:	1880071e 	bne	r3,r2,44d98 <altera_avalon_jtag_uart_read+0x9c>
      break;
    else if(flags & O_NONBLOCK)
   44d7c:	e0bfff17 	ldw	r2,-4(fp)
   44d80:	1090000c 	andi	r2,r2,16384
   44d84:	1000061e 	bne	r2,zero,44da0 <altera_avalon_jtag_uart_read+0xa4>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
   44d88:	e0fff817 	ldw	r3,-32(fp)
   44d8c:	e0bffa17 	ldw	r2,-24(fp)
   44d90:	18bfeb36 	bltu	r3,r2,44d40 <__alt_data_end+0xfffdcd40>
   44d94:	00000306 	br	44da4 <altera_avalon_jtag_uart_read+0xa8>
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
   44d98:	0001883a 	nop
   44d9c:	00000106 	br	44da4 <altera_avalon_jtag_uart_read+0xa8>
    else if(flags & O_NONBLOCK)
      break;   
   44da0:	0001883a 	nop
    
  }

  if (ptr != buffer)
   44da4:	e0fff817 	ldw	r3,-32(fp)
   44da8:	e0bffd17 	ldw	r2,-12(fp)
   44dac:	18800426 	beq	r3,r2,44dc0 <altera_avalon_jtag_uart_read+0xc4>
    return ptr - buffer;
   44db0:	e0fff817 	ldw	r3,-32(fp)
   44db4:	e0bffd17 	ldw	r2,-12(fp)
   44db8:	1885c83a 	sub	r2,r3,r2
   44dbc:	00000606 	br	44dd8 <altera_avalon_jtag_uart_read+0xdc>
  else if (flags & O_NONBLOCK)
   44dc0:	e0bfff17 	ldw	r2,-4(fp)
   44dc4:	1090000c 	andi	r2,r2,16384
   44dc8:	10000226 	beq	r2,zero,44dd4 <altera_avalon_jtag_uart_read+0xd8>
    return -EWOULDBLOCK;
   44dcc:	00bffd44 	movi	r2,-11
   44dd0:	00000106 	br	44dd8 <altera_avalon_jtag_uart_read+0xdc>
  else
    return -EIO;
   44dd4:	00bffec4 	movi	r2,-5
}
   44dd8:	e037883a 	mov	sp,fp
   44ddc:	df000017 	ldw	fp,0(sp)
   44de0:	dec00104 	addi	sp,sp,4
   44de4:	f800283a 	ret

00044de8 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   44de8:	defff904 	addi	sp,sp,-28
   44dec:	df000615 	stw	fp,24(sp)
   44df0:	df000604 	addi	fp,sp,24
   44df4:	e13ffc15 	stw	r4,-16(fp)
   44df8:	e17ffd15 	stw	r5,-12(fp)
   44dfc:	e1bffe15 	stw	r6,-8(fp)
   44e00:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   44e04:	e0bffc17 	ldw	r2,-16(fp)
   44e08:	10800017 	ldw	r2,0(r2)
   44e0c:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
   44e10:	e0bffe17 	ldw	r2,-8(fp)
   44e14:	e0fffd17 	ldw	r3,-12(fp)
   44e18:	1885883a 	add	r2,r3,r2
   44e1c:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
   44e20:	00000e06 	br	44e5c <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   44e24:	e0bffa17 	ldw	r2,-24(fp)
   44e28:	10800104 	addi	r2,r2,4
   44e2c:	10800037 	ldwio	r2,0(r2)
   44e30:	10bfffec 	andhi	r2,r2,65535
   44e34:	10000926 	beq	r2,zero,44e5c <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   44e38:	e0fffa17 	ldw	r3,-24(fp)
   44e3c:	e0bffd17 	ldw	r2,-12(fp)
   44e40:	11000044 	addi	r4,r2,1
   44e44:	e13ffd15 	stw	r4,-12(fp)
   44e48:	10800003 	ldbu	r2,0(r2)
   44e4c:	10803fcc 	andi	r2,r2,255
   44e50:	1080201c 	xori	r2,r2,128
   44e54:	10bfe004 	addi	r2,r2,-128
   44e58:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   44e5c:	e0fffd17 	ldw	r3,-12(fp)
   44e60:	e0bffb17 	ldw	r2,-20(fp)
   44e64:	18bfef36 	bltu	r3,r2,44e24 <__alt_data_end+0xfffdce24>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
   44e68:	e0bffe17 	ldw	r2,-8(fp)
}
   44e6c:	e037883a 	mov	sp,fp
   44e70:	df000017 	ldw	fp,0(sp)
   44e74:	dec00104 	addi	sp,sp,4
   44e78:	f800283a 	ret

00044e7c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   44e7c:	defffe04 	addi	sp,sp,-8
   44e80:	dfc00115 	stw	ra,4(sp)
   44e84:	df000015 	stw	fp,0(sp)
   44e88:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   44e8c:	d0a00f17 	ldw	r2,-32708(gp)
   44e90:	10000326 	beq	r2,zero,44ea0 <alt_get_errno+0x24>
   44e94:	d0a00f17 	ldw	r2,-32708(gp)
   44e98:	103ee83a 	callr	r2
   44e9c:	00000106 	br	44ea4 <alt_get_errno+0x28>
   44ea0:	d0a0ff04 	addi	r2,gp,-31748
}
   44ea4:	e037883a 	mov	sp,fp
   44ea8:	dfc00117 	ldw	ra,4(sp)
   44eac:	df000017 	ldw	fp,0(sp)
   44eb0:	dec00204 	addi	sp,sp,8
   44eb4:	f800283a 	ret

00044eb8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   44eb8:	defffb04 	addi	sp,sp,-20
   44ebc:	dfc00415 	stw	ra,16(sp)
   44ec0:	df000315 	stw	fp,12(sp)
   44ec4:	df000304 	addi	fp,sp,12
   44ec8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   44ecc:	e0bfff17 	ldw	r2,-4(fp)
   44ed0:	10000616 	blt	r2,zero,44eec <close+0x34>
   44ed4:	e0bfff17 	ldw	r2,-4(fp)
   44ed8:	10c00324 	muli	r3,r2,12
   44edc:	00800134 	movhi	r2,4
   44ee0:	109dd804 	addi	r2,r2,30560
   44ee4:	1885883a 	add	r2,r3,r2
   44ee8:	00000106 	br	44ef0 <close+0x38>
   44eec:	0005883a 	mov	r2,zero
   44ef0:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   44ef4:	e0bffd17 	ldw	r2,-12(fp)
   44ef8:	10001926 	beq	r2,zero,44f60 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   44efc:	e0bffd17 	ldw	r2,-12(fp)
   44f00:	10800017 	ldw	r2,0(r2)
   44f04:	10800417 	ldw	r2,16(r2)
   44f08:	10000626 	beq	r2,zero,44f24 <close+0x6c>
   44f0c:	e0bffd17 	ldw	r2,-12(fp)
   44f10:	10800017 	ldw	r2,0(r2)
   44f14:	10800417 	ldw	r2,16(r2)
   44f18:	e13ffd17 	ldw	r4,-12(fp)
   44f1c:	103ee83a 	callr	r2
   44f20:	00000106 	br	44f28 <close+0x70>
   44f24:	0005883a 	mov	r2,zero
   44f28:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   44f2c:	e13fff17 	ldw	r4,-4(fp)
   44f30:	00455180 	call	45518 <alt_release_fd>
    if (rval < 0)
   44f34:	e0bffe17 	ldw	r2,-8(fp)
   44f38:	1000070e 	bge	r2,zero,44f58 <close+0xa0>
    {
      ALT_ERRNO = -rval;
   44f3c:	0044e7c0 	call	44e7c <alt_get_errno>
   44f40:	1007883a 	mov	r3,r2
   44f44:	e0bffe17 	ldw	r2,-8(fp)
   44f48:	0085c83a 	sub	r2,zero,r2
   44f4c:	18800015 	stw	r2,0(r3)
      return -1;
   44f50:	00bfffc4 	movi	r2,-1
   44f54:	00000706 	br	44f74 <close+0xbc>
    }
    return 0;
   44f58:	0005883a 	mov	r2,zero
   44f5c:	00000506 	br	44f74 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   44f60:	0044e7c0 	call	44e7c <alt_get_errno>
   44f64:	1007883a 	mov	r3,r2
   44f68:	00801444 	movi	r2,81
   44f6c:	18800015 	stw	r2,0(r3)
    return -1;
   44f70:	00bfffc4 	movi	r2,-1
  }
}
   44f74:	e037883a 	mov	sp,fp
   44f78:	dfc00117 	ldw	ra,4(sp)
   44f7c:	df000017 	ldw	fp,0(sp)
   44f80:	dec00204 	addi	sp,sp,8
   44f84:	f800283a 	ret

00044f88 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   44f88:	deffff04 	addi	sp,sp,-4
   44f8c:	df000015 	stw	fp,0(sp)
   44f90:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   44f94:	0001883a 	nop
   44f98:	e037883a 	mov	sp,fp
   44f9c:	df000017 	ldw	fp,0(sp)
   44fa0:	dec00104 	addi	sp,sp,4
   44fa4:	f800283a 	ret

00044fa8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   44fa8:	defffc04 	addi	sp,sp,-16
   44fac:	df000315 	stw	fp,12(sp)
   44fb0:	df000304 	addi	fp,sp,12
   44fb4:	e13ffd15 	stw	r4,-12(fp)
   44fb8:	e17ffe15 	stw	r5,-8(fp)
   44fbc:	e1bfff15 	stw	r6,-4(fp)
  return len;
   44fc0:	e0bfff17 	ldw	r2,-4(fp)
}
   44fc4:	e037883a 	mov	sp,fp
   44fc8:	df000017 	ldw	fp,0(sp)
   44fcc:	dec00104 	addi	sp,sp,4
   44fd0:	f800283a 	ret

00044fd4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   44fd4:	defffe04 	addi	sp,sp,-8
   44fd8:	dfc00115 	stw	ra,4(sp)
   44fdc:	df000015 	stw	fp,0(sp)
   44fe0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   44fe4:	d0a00f17 	ldw	r2,-32708(gp)
   44fe8:	10000326 	beq	r2,zero,44ff8 <alt_get_errno+0x24>
   44fec:	d0a00f17 	ldw	r2,-32708(gp)
   44ff0:	103ee83a 	callr	r2
   44ff4:	00000106 	br	44ffc <alt_get_errno+0x28>
   44ff8:	d0a0ff04 	addi	r2,gp,-31748
}
   44ffc:	e037883a 	mov	sp,fp
   45000:	dfc00117 	ldw	ra,4(sp)
   45004:	df000017 	ldw	fp,0(sp)
   45008:	dec00204 	addi	sp,sp,8
   4500c:	f800283a 	ret

00045010 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   45010:	defffa04 	addi	sp,sp,-24
   45014:	dfc00515 	stw	ra,20(sp)
   45018:	df000415 	stw	fp,16(sp)
   4501c:	df000404 	addi	fp,sp,16
   45020:	e13ffe15 	stw	r4,-8(fp)
   45024:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   45028:	e0bffe17 	ldw	r2,-8(fp)
   4502c:	10000326 	beq	r2,zero,4503c <alt_dev_llist_insert+0x2c>
   45030:	e0bffe17 	ldw	r2,-8(fp)
   45034:	10800217 	ldw	r2,8(r2)
   45038:	1000061e 	bne	r2,zero,45054 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
   4503c:	0044fd40 	call	44fd4 <alt_get_errno>
   45040:	1007883a 	mov	r3,r2
   45044:	00800584 	movi	r2,22
   45048:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   4504c:	00bffa84 	movi	r2,-22
   45050:	00001306 	br	450a0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   45054:	e0bffe17 	ldw	r2,-8(fp)
   45058:	e0ffff17 	ldw	r3,-4(fp)
   4505c:	e0fffc15 	stw	r3,-16(fp)
   45060:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   45064:	e0bffd17 	ldw	r2,-12(fp)
   45068:	e0fffc17 	ldw	r3,-16(fp)
   4506c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   45070:	e0bffc17 	ldw	r2,-16(fp)
   45074:	10c00017 	ldw	r3,0(r2)
   45078:	e0bffd17 	ldw	r2,-12(fp)
   4507c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   45080:	e0bffc17 	ldw	r2,-16(fp)
   45084:	10800017 	ldw	r2,0(r2)
   45088:	e0fffd17 	ldw	r3,-12(fp)
   4508c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   45090:	e0bffc17 	ldw	r2,-16(fp)
   45094:	e0fffd17 	ldw	r3,-12(fp)
   45098:	10c00015 	stw	r3,0(r2)

  return 0;  
   4509c:	0005883a 	mov	r2,zero
}
   450a0:	e037883a 	mov	sp,fp
   450a4:	dfc00117 	ldw	ra,4(sp)
   450a8:	df000017 	ldw	fp,0(sp)
   450ac:	dec00204 	addi	sp,sp,8
   450b0:	f800283a 	ret

000450b4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   450b4:	defffe04 	addi	sp,sp,-8
   450b8:	dfc00115 	stw	ra,4(sp)
   450bc:	df000015 	stw	fp,0(sp)
   450c0:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   450c4:	01420004 	movi	r5,2048
   450c8:	0009883a 	mov	r4,zero
   450cc:	00457dc0 	call	457dc <alt_icache_flush>
#endif
}
   450d0:	0001883a 	nop
   450d4:	e037883a 	mov	sp,fp
   450d8:	dfc00117 	ldw	ra,4(sp)
   450dc:	df000017 	ldw	fp,0(sp)
   450e0:	dec00204 	addi	sp,sp,8
   450e4:	f800283a 	ret

000450e8 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
   450e8:	defffe04 	addi	sp,sp,-8
   450ec:	df000115 	stw	fp,4(sp)
   450f0:	df000104 	addi	fp,sp,4
   450f4:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
   450f8:	e0bfff17 	ldw	r2,-4(fp)
   450fc:	10bffe84 	addi	r2,r2,-6
   45100:	10c00428 	cmpgeui	r3,r2,16
   45104:	18001a1e 	bne	r3,zero,45170 <alt_exception_cause_generated_bad_addr+0x88>
   45108:	100690ba 	slli	r3,r2,2
   4510c:	00800134 	movhi	r2,4
   45110:	10944804 	addi	r2,r2,20768
   45114:	1885883a 	add	r2,r3,r2
   45118:	10800017 	ldw	r2,0(r2)
   4511c:	1000683a 	jmp	r2
   45120:	00045160 	cmpeqi	zero,zero,4421
   45124:	00045160 	cmpeqi	zero,zero,4421
   45128:	00045170 	cmpltui	zero,zero,4421
   4512c:	00045170 	cmpltui	zero,zero,4421
   45130:	00045170 	cmpltui	zero,zero,4421
   45134:	00045160 	cmpeqi	zero,zero,4421
   45138:	00045168 	cmpgeui	zero,zero,4421
   4513c:	00045170 	cmpltui	zero,zero,4421
   45140:	00045160 	cmpeqi	zero,zero,4421
   45144:	00045160 	cmpeqi	zero,zero,4421
   45148:	00045170 	cmpltui	zero,zero,4421
   4514c:	00045160 	cmpeqi	zero,zero,4421
   45150:	00045168 	cmpgeui	zero,zero,4421
   45154:	00045170 	cmpltui	zero,zero,4421
   45158:	00045170 	cmpltui	zero,zero,4421
   4515c:	00045160 	cmpeqi	zero,zero,4421
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   45160:	00800044 	movi	r2,1
   45164:	00000306 	br	45174 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   45168:	0005883a 	mov	r2,zero
   4516c:	00000106 	br	45174 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
   45170:	0005883a 	mov	r2,zero
  }
}
   45174:	e037883a 	mov	sp,fp
   45178:	df000017 	ldw	fp,0(sp)
   4517c:	dec00104 	addi	sp,sp,4
   45180:	f800283a 	ret

00045184 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   45184:	defff904 	addi	sp,sp,-28
   45188:	dfc00615 	stw	ra,24(sp)
   4518c:	df000515 	stw	fp,20(sp)
   45190:	df000504 	addi	fp,sp,20
   45194:	e13ffc15 	stw	r4,-16(fp)
   45198:	e17ffd15 	stw	r5,-12(fp)
   4519c:	e1bffe15 	stw	r6,-8(fp)
   451a0:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   451a4:	e1bfff17 	ldw	r6,-4(fp)
   451a8:	e17ffe17 	ldw	r5,-8(fp)
   451ac:	e13ffd17 	ldw	r4,-12(fp)
   451b0:	00453c40 	call	453c4 <open>
   451b4:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   451b8:	e0bffb17 	ldw	r2,-20(fp)
   451bc:	10001c16 	blt	r2,zero,45230 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   451c0:	00800134 	movhi	r2,4
   451c4:	109dd804 	addi	r2,r2,30560
   451c8:	e0fffb17 	ldw	r3,-20(fp)
   451cc:	18c00324 	muli	r3,r3,12
   451d0:	10c5883a 	add	r2,r2,r3
   451d4:	10c00017 	ldw	r3,0(r2)
   451d8:	e0bffc17 	ldw	r2,-16(fp)
   451dc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   451e0:	00800134 	movhi	r2,4
   451e4:	109dd804 	addi	r2,r2,30560
   451e8:	e0fffb17 	ldw	r3,-20(fp)
   451ec:	18c00324 	muli	r3,r3,12
   451f0:	10c5883a 	add	r2,r2,r3
   451f4:	10800104 	addi	r2,r2,4
   451f8:	10c00017 	ldw	r3,0(r2)
   451fc:	e0bffc17 	ldw	r2,-16(fp)
   45200:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   45204:	00800134 	movhi	r2,4
   45208:	109dd804 	addi	r2,r2,30560
   4520c:	e0fffb17 	ldw	r3,-20(fp)
   45210:	18c00324 	muli	r3,r3,12
   45214:	10c5883a 	add	r2,r2,r3
   45218:	10800204 	addi	r2,r2,8
   4521c:	10c00017 	ldw	r3,0(r2)
   45220:	e0bffc17 	ldw	r2,-16(fp)
   45224:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   45228:	e13ffb17 	ldw	r4,-20(fp)
   4522c:	00455180 	call	45518 <alt_release_fd>
  }
} 
   45230:	0001883a 	nop
   45234:	e037883a 	mov	sp,fp
   45238:	dfc00117 	ldw	ra,4(sp)
   4523c:	df000017 	ldw	fp,0(sp)
   45240:	dec00204 	addi	sp,sp,8
   45244:	f800283a 	ret

00045248 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   45248:	defffb04 	addi	sp,sp,-20
   4524c:	dfc00415 	stw	ra,16(sp)
   45250:	df000315 	stw	fp,12(sp)
   45254:	df000304 	addi	fp,sp,12
   45258:	e13ffd15 	stw	r4,-12(fp)
   4525c:	e17ffe15 	stw	r5,-8(fp)
   45260:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   45264:	01c07fc4 	movi	r7,511
   45268:	01800044 	movi	r6,1
   4526c:	e17ffd17 	ldw	r5,-12(fp)
   45270:	01000134 	movhi	r4,4
   45274:	211ddb04 	addi	r4,r4,30572
   45278:	00451840 	call	45184 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   4527c:	01c07fc4 	movi	r7,511
   45280:	000d883a 	mov	r6,zero
   45284:	e17ffe17 	ldw	r5,-8(fp)
   45288:	01000134 	movhi	r4,4
   4528c:	211dd804 	addi	r4,r4,30560
   45290:	00451840 	call	45184 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   45294:	01c07fc4 	movi	r7,511
   45298:	01800044 	movi	r6,1
   4529c:	e17fff17 	ldw	r5,-4(fp)
   452a0:	01000134 	movhi	r4,4
   452a4:	211dde04 	addi	r4,r4,30584
   452a8:	00451840 	call	45184 <alt_open_fd>
}  
   452ac:	0001883a 	nop
   452b0:	e037883a 	mov	sp,fp
   452b4:	dfc00117 	ldw	ra,4(sp)
   452b8:	df000017 	ldw	fp,0(sp)
   452bc:	dec00204 	addi	sp,sp,8
   452c0:	f800283a 	ret

000452c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   452c4:	defffe04 	addi	sp,sp,-8
   452c8:	dfc00115 	stw	ra,4(sp)
   452cc:	df000015 	stw	fp,0(sp)
   452d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   452d4:	d0a00f17 	ldw	r2,-32708(gp)
   452d8:	10000326 	beq	r2,zero,452e8 <alt_get_errno+0x24>
   452dc:	d0a00f17 	ldw	r2,-32708(gp)
   452e0:	103ee83a 	callr	r2
   452e4:	00000106 	br	452ec <alt_get_errno+0x28>
   452e8:	d0a0ff04 	addi	r2,gp,-31748
}
   452ec:	e037883a 	mov	sp,fp
   452f0:	dfc00117 	ldw	ra,4(sp)
   452f4:	df000017 	ldw	fp,0(sp)
   452f8:	dec00204 	addi	sp,sp,8
   452fc:	f800283a 	ret

00045300 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   45300:	defffd04 	addi	sp,sp,-12
   45304:	df000215 	stw	fp,8(sp)
   45308:	df000204 	addi	fp,sp,8
   4530c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   45310:	e0bfff17 	ldw	r2,-4(fp)
   45314:	10800217 	ldw	r2,8(r2)
   45318:	10d00034 	orhi	r3,r2,16384
   4531c:	e0bfff17 	ldw	r2,-4(fp)
   45320:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   45324:	e03ffe15 	stw	zero,-8(fp)
   45328:	00001d06 	br	453a0 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   4532c:	00800134 	movhi	r2,4
   45330:	109dd804 	addi	r2,r2,30560
   45334:	e0fffe17 	ldw	r3,-8(fp)
   45338:	18c00324 	muli	r3,r3,12
   4533c:	10c5883a 	add	r2,r2,r3
   45340:	10c00017 	ldw	r3,0(r2)
   45344:	e0bfff17 	ldw	r2,-4(fp)
   45348:	10800017 	ldw	r2,0(r2)
   4534c:	1880111e 	bne	r3,r2,45394 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   45350:	00800134 	movhi	r2,4
   45354:	109dd804 	addi	r2,r2,30560
   45358:	e0fffe17 	ldw	r3,-8(fp)
   4535c:	18c00324 	muli	r3,r3,12
   45360:	10c5883a 	add	r2,r2,r3
   45364:	10800204 	addi	r2,r2,8
   45368:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   4536c:	1000090e 	bge	r2,zero,45394 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   45370:	e0bffe17 	ldw	r2,-8(fp)
   45374:	10c00324 	muli	r3,r2,12
   45378:	00800134 	movhi	r2,4
   4537c:	109dd804 	addi	r2,r2,30560
   45380:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   45384:	e0bfff17 	ldw	r2,-4(fp)
   45388:	18800226 	beq	r3,r2,45394 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   4538c:	00bffcc4 	movi	r2,-13
   45390:	00000806 	br	453b4 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   45394:	e0bffe17 	ldw	r2,-8(fp)
   45398:	10800044 	addi	r2,r2,1
   4539c:	e0bffe15 	stw	r2,-8(fp)
   453a0:	d0a00e17 	ldw	r2,-32712(gp)
   453a4:	1007883a 	mov	r3,r2
   453a8:	e0bffe17 	ldw	r2,-8(fp)
   453ac:	18bfdf2e 	bgeu	r3,r2,4532c <__alt_data_end+0xfffdd32c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   453b0:	0005883a 	mov	r2,zero
}
   453b4:	e037883a 	mov	sp,fp
   453b8:	df000017 	ldw	fp,0(sp)
   453bc:	dec00104 	addi	sp,sp,4
   453c0:	f800283a 	ret

000453c4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   453c4:	defff604 	addi	sp,sp,-40
   453c8:	dfc00915 	stw	ra,36(sp)
   453cc:	df000815 	stw	fp,32(sp)
   453d0:	df000804 	addi	fp,sp,32
   453d4:	e13ffd15 	stw	r4,-12(fp)
   453d8:	e17ffe15 	stw	r5,-8(fp)
   453dc:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   453e0:	00bfffc4 	movi	r2,-1
   453e4:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   453e8:	00bffb44 	movi	r2,-19
   453ec:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   453f0:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   453f4:	d1600c04 	addi	r5,gp,-32720
   453f8:	e13ffd17 	ldw	r4,-12(fp)
   453fc:	00455a00 	call	455a0 <alt_find_dev>
   45400:	e0bff815 	stw	r2,-32(fp)
   45404:	e0bff817 	ldw	r2,-32(fp)
   45408:	1000051e 	bne	r2,zero,45420 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   4540c:	e13ffd17 	ldw	r4,-12(fp)
   45410:	00456300 	call	45630 <alt_find_file>
   45414:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   45418:	00800044 	movi	r2,1
   4541c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   45420:	e0bff817 	ldw	r2,-32(fp)
   45424:	10002926 	beq	r2,zero,454cc <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
   45428:	e13ff817 	ldw	r4,-32(fp)
   4542c:	00457380 	call	45738 <alt_get_fd>
   45430:	e0bff915 	stw	r2,-28(fp)
   45434:	e0bff917 	ldw	r2,-28(fp)
   45438:	1000030e 	bge	r2,zero,45448 <open+0x84>
    {
      status = index;
   4543c:	e0bff917 	ldw	r2,-28(fp)
   45440:	e0bffa15 	stw	r2,-24(fp)
   45444:	00002306 	br	454d4 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
   45448:	e0bff917 	ldw	r2,-28(fp)
   4544c:	10c00324 	muli	r3,r2,12
   45450:	00800134 	movhi	r2,4
   45454:	109dd804 	addi	r2,r2,30560
   45458:	1885883a 	add	r2,r3,r2
   4545c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   45460:	e0fffe17 	ldw	r3,-8(fp)
   45464:	00900034 	movhi	r2,16384
   45468:	10bfffc4 	addi	r2,r2,-1
   4546c:	1886703a 	and	r3,r3,r2
   45470:	e0bffc17 	ldw	r2,-16(fp)
   45474:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   45478:	e0bffb17 	ldw	r2,-20(fp)
   4547c:	1000051e 	bne	r2,zero,45494 <open+0xd0>
   45480:	e13ffc17 	ldw	r4,-16(fp)
   45484:	00453000 	call	45300 <alt_file_locked>
   45488:	e0bffa15 	stw	r2,-24(fp)
   4548c:	e0bffa17 	ldw	r2,-24(fp)
   45490:	10001016 	blt	r2,zero,454d4 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   45494:	e0bff817 	ldw	r2,-32(fp)
   45498:	10800317 	ldw	r2,12(r2)
   4549c:	10000826 	beq	r2,zero,454c0 <open+0xfc>
   454a0:	e0bff817 	ldw	r2,-32(fp)
   454a4:	10800317 	ldw	r2,12(r2)
   454a8:	e1ffff17 	ldw	r7,-4(fp)
   454ac:	e1bffe17 	ldw	r6,-8(fp)
   454b0:	e17ffd17 	ldw	r5,-12(fp)
   454b4:	e13ffc17 	ldw	r4,-16(fp)
   454b8:	103ee83a 	callr	r2
   454bc:	00000106 	br	454c4 <open+0x100>
   454c0:	0005883a 	mov	r2,zero
   454c4:	e0bffa15 	stw	r2,-24(fp)
   454c8:	00000206 	br	454d4 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
   454cc:	00bffb44 	movi	r2,-19
   454d0:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   454d4:	e0bffa17 	ldw	r2,-24(fp)
   454d8:	1000090e 	bge	r2,zero,45500 <open+0x13c>
  {
    alt_release_fd (index);  
   454dc:	e13ff917 	ldw	r4,-28(fp)
   454e0:	00455180 	call	45518 <alt_release_fd>
    ALT_ERRNO = -status;
   454e4:	00452c40 	call	452c4 <alt_get_errno>
   454e8:	1007883a 	mov	r3,r2
   454ec:	e0bffa17 	ldw	r2,-24(fp)
   454f0:	0085c83a 	sub	r2,zero,r2
   454f4:	18800015 	stw	r2,0(r3)
    return -1;
   454f8:	00bfffc4 	movi	r2,-1
   454fc:	00000106 	br	45504 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   45500:	e0bff917 	ldw	r2,-28(fp)
}
   45504:	e037883a 	mov	sp,fp
   45508:	dfc00117 	ldw	ra,4(sp)
   4550c:	df000017 	ldw	fp,0(sp)
   45510:	dec00204 	addi	sp,sp,8
   45514:	f800283a 	ret

00045518 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   45518:	defffe04 	addi	sp,sp,-8
   4551c:	df000115 	stw	fp,4(sp)
   45520:	df000104 	addi	fp,sp,4
   45524:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   45528:	e0bfff17 	ldw	r2,-4(fp)
   4552c:	108000d0 	cmplti	r2,r2,3
   45530:	10000d1e 	bne	r2,zero,45568 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   45534:	00800134 	movhi	r2,4
   45538:	109dd804 	addi	r2,r2,30560
   4553c:	e0ffff17 	ldw	r3,-4(fp)
   45540:	18c00324 	muli	r3,r3,12
   45544:	10c5883a 	add	r2,r2,r3
   45548:	10800204 	addi	r2,r2,8
   4554c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   45550:	00800134 	movhi	r2,4
   45554:	109dd804 	addi	r2,r2,30560
   45558:	e0ffff17 	ldw	r3,-4(fp)
   4555c:	18c00324 	muli	r3,r3,12
   45560:	10c5883a 	add	r2,r2,r3
   45564:	10000015 	stw	zero,0(r2)
  }
}
   45568:	0001883a 	nop
   4556c:	e037883a 	mov	sp,fp
   45570:	df000017 	ldw	fp,0(sp)
   45574:	dec00104 	addi	sp,sp,4
   45578:	f800283a 	ret

0004557c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
   4557c:	deffff04 	addi	sp,sp,-4
   45580:	df000015 	stw	fp,0(sp)
   45584:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   45588:	000170fa 	wrctl	ienable,zero
}
   4558c:	0001883a 	nop
   45590:	e037883a 	mov	sp,fp
   45594:	df000017 	ldw	fp,0(sp)
   45598:	dec00104 	addi	sp,sp,4
   4559c:	f800283a 	ret

000455a0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   455a0:	defffa04 	addi	sp,sp,-24
   455a4:	dfc00515 	stw	ra,20(sp)
   455a8:	df000415 	stw	fp,16(sp)
   455ac:	df000404 	addi	fp,sp,16
   455b0:	e13ffe15 	stw	r4,-8(fp)
   455b4:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   455b8:	e0bfff17 	ldw	r2,-4(fp)
   455bc:	10800017 	ldw	r2,0(r2)
   455c0:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   455c4:	e13ffe17 	ldw	r4,-8(fp)
   455c8:	0043f940 	call	43f94 <strlen>
   455cc:	10800044 	addi	r2,r2,1
   455d0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   455d4:	00000d06 	br	4560c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   455d8:	e0bffc17 	ldw	r2,-16(fp)
   455dc:	10800217 	ldw	r2,8(r2)
   455e0:	e0fffd17 	ldw	r3,-12(fp)
   455e4:	180d883a 	mov	r6,r3
   455e8:	e17ffe17 	ldw	r5,-8(fp)
   455ec:	1009883a 	mov	r4,r2
   455f0:	004588c0 	call	4588c <memcmp>
   455f4:	1000021e 	bne	r2,zero,45600 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   455f8:	e0bffc17 	ldw	r2,-16(fp)
   455fc:	00000706 	br	4561c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   45600:	e0bffc17 	ldw	r2,-16(fp)
   45604:	10800017 	ldw	r2,0(r2)
   45608:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   4560c:	e0fffc17 	ldw	r3,-16(fp)
   45610:	e0bfff17 	ldw	r2,-4(fp)
   45614:	18bff01e 	bne	r3,r2,455d8 <__alt_data_end+0xfffdd5d8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   45618:	0005883a 	mov	r2,zero
}
   4561c:	e037883a 	mov	sp,fp
   45620:	dfc00117 	ldw	ra,4(sp)
   45624:	df000017 	ldw	fp,0(sp)
   45628:	dec00204 	addi	sp,sp,8
   4562c:	f800283a 	ret

00045630 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   45630:	defffb04 	addi	sp,sp,-20
   45634:	dfc00415 	stw	ra,16(sp)
   45638:	df000315 	stw	fp,12(sp)
   4563c:	df000304 	addi	fp,sp,12
   45640:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   45644:	d0a00a17 	ldw	r2,-32728(gp)
   45648:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   4564c:	00003106 	br	45714 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
   45650:	e0bffd17 	ldw	r2,-12(fp)
   45654:	10800217 	ldw	r2,8(r2)
   45658:	1009883a 	mov	r4,r2
   4565c:	0043f940 	call	43f94 <strlen>
   45660:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   45664:	e0bffd17 	ldw	r2,-12(fp)
   45668:	10c00217 	ldw	r3,8(r2)
   4566c:	e0bffe17 	ldw	r2,-8(fp)
   45670:	10bfffc4 	addi	r2,r2,-1
   45674:	1885883a 	add	r2,r3,r2
   45678:	10800003 	ldbu	r2,0(r2)
   4567c:	10803fcc 	andi	r2,r2,255
   45680:	1080201c 	xori	r2,r2,128
   45684:	10bfe004 	addi	r2,r2,-128
   45688:	10800bd8 	cmpnei	r2,r2,47
   4568c:	1000031e 	bne	r2,zero,4569c <alt_find_file+0x6c>
    {
      len -= 1;
   45690:	e0bffe17 	ldw	r2,-8(fp)
   45694:	10bfffc4 	addi	r2,r2,-1
   45698:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   4569c:	e0bffe17 	ldw	r2,-8(fp)
   456a0:	e0ffff17 	ldw	r3,-4(fp)
   456a4:	1885883a 	add	r2,r3,r2
   456a8:	10800003 	ldbu	r2,0(r2)
   456ac:	10803fcc 	andi	r2,r2,255
   456b0:	1080201c 	xori	r2,r2,128
   456b4:	10bfe004 	addi	r2,r2,-128
   456b8:	10800be0 	cmpeqi	r2,r2,47
   456bc:	1000081e 	bne	r2,zero,456e0 <alt_find_file+0xb0>
   456c0:	e0bffe17 	ldw	r2,-8(fp)
   456c4:	e0ffff17 	ldw	r3,-4(fp)
   456c8:	1885883a 	add	r2,r3,r2
   456cc:	10800003 	ldbu	r2,0(r2)
   456d0:	10803fcc 	andi	r2,r2,255
   456d4:	1080201c 	xori	r2,r2,128
   456d8:	10bfe004 	addi	r2,r2,-128
   456dc:	10000a1e 	bne	r2,zero,45708 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
   456e0:	e0bffd17 	ldw	r2,-12(fp)
   456e4:	10800217 	ldw	r2,8(r2)
   456e8:	e0fffe17 	ldw	r3,-8(fp)
   456ec:	180d883a 	mov	r6,r3
   456f0:	e17fff17 	ldw	r5,-4(fp)
   456f4:	1009883a 	mov	r4,r2
   456f8:	004588c0 	call	4588c <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   456fc:	1000021e 	bne	r2,zero,45708 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   45700:	e0bffd17 	ldw	r2,-12(fp)
   45704:	00000706 	br	45724 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
   45708:	e0bffd17 	ldw	r2,-12(fp)
   4570c:	10800017 	ldw	r2,0(r2)
   45710:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   45714:	e0fffd17 	ldw	r3,-12(fp)
   45718:	d0a00a04 	addi	r2,gp,-32728
   4571c:	18bfcc1e 	bne	r3,r2,45650 <__alt_data_end+0xfffdd650>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   45720:	0005883a 	mov	r2,zero
}
   45724:	e037883a 	mov	sp,fp
   45728:	dfc00117 	ldw	ra,4(sp)
   4572c:	df000017 	ldw	fp,0(sp)
   45730:	dec00204 	addi	sp,sp,8
   45734:	f800283a 	ret

00045738 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   45738:	defffc04 	addi	sp,sp,-16
   4573c:	df000315 	stw	fp,12(sp)
   45740:	df000304 	addi	fp,sp,12
   45744:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   45748:	00bffa04 	movi	r2,-24
   4574c:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   45750:	e03ffd15 	stw	zero,-12(fp)
   45754:	00001906 	br	457bc <alt_get_fd+0x84>
  {
    if (!alt_fd_list[i].dev)
   45758:	00800134 	movhi	r2,4
   4575c:	109dd804 	addi	r2,r2,30560
   45760:	e0fffd17 	ldw	r3,-12(fp)
   45764:	18c00324 	muli	r3,r3,12
   45768:	10c5883a 	add	r2,r2,r3
   4576c:	10800017 	ldw	r2,0(r2)
   45770:	10000f1e 	bne	r2,zero,457b0 <alt_get_fd+0x78>
    {
      alt_fd_list[i].dev = dev;
   45774:	00800134 	movhi	r2,4
   45778:	109dd804 	addi	r2,r2,30560
   4577c:	e0fffd17 	ldw	r3,-12(fp)
   45780:	18c00324 	muli	r3,r3,12
   45784:	10c5883a 	add	r2,r2,r3
   45788:	e0ffff17 	ldw	r3,-4(fp)
   4578c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   45790:	d0e00e17 	ldw	r3,-32712(gp)
   45794:	e0bffd17 	ldw	r2,-12(fp)
   45798:	1880020e 	bge	r3,r2,457a4 <alt_get_fd+0x6c>
      {
        alt_max_fd = i;
   4579c:	e0bffd17 	ldw	r2,-12(fp)
   457a0:	d0a00e15 	stw	r2,-32712(gp)
      }
      rc = i;
   457a4:	e0bffd17 	ldw	r2,-12(fp)
   457a8:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   457ac:	00000606 	br	457c8 <alt_get_fd+0x90>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   457b0:	e0bffd17 	ldw	r2,-12(fp)
   457b4:	10800044 	addi	r2,r2,1
   457b8:	e0bffd15 	stw	r2,-12(fp)
   457bc:	e0bffd17 	ldw	r2,-12(fp)
   457c0:	10800810 	cmplti	r2,r2,32
   457c4:	103fe41e 	bne	r2,zero,45758 <__alt_data_end+0xfffdd758>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   457c8:	e0bffe17 	ldw	r2,-8(fp)
}
   457cc:	e037883a 	mov	sp,fp
   457d0:	df000017 	ldw	fp,0(sp)
   457d4:	dec00104 	addi	sp,sp,4
   457d8:	f800283a 	ret

000457dc <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   457dc:	defffb04 	addi	sp,sp,-20
   457e0:	df000415 	stw	fp,16(sp)
   457e4:	df000404 	addi	fp,sp,16
   457e8:	e13ffe15 	stw	r4,-8(fp)
   457ec:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   457f0:	e0bfff17 	ldw	r2,-4(fp)
   457f4:	10820070 	cmpltui	r2,r2,2049
   457f8:	1000021e 	bne	r2,zero,45804 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   457fc:	00820004 	movi	r2,2048
   45800:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   45804:	e0fffe17 	ldw	r3,-8(fp)
   45808:	e0bfff17 	ldw	r2,-4(fp)
   4580c:	1885883a 	add	r2,r3,r2
   45810:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   45814:	e0bffe17 	ldw	r2,-8(fp)
   45818:	e0bffc15 	stw	r2,-16(fp)
   4581c:	00000506 	br	45834 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   45820:	e0bffc17 	ldw	r2,-16(fp)
   45824:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   45828:	e0bffc17 	ldw	r2,-16(fp)
   4582c:	10800804 	addi	r2,r2,32
   45830:	e0bffc15 	stw	r2,-16(fp)
   45834:	e0fffc17 	ldw	r3,-16(fp)
   45838:	e0bffd17 	ldw	r2,-12(fp)
   4583c:	18bff836 	bltu	r3,r2,45820 <__alt_data_end+0xfffdd820>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   45840:	e0bffe17 	ldw	r2,-8(fp)
   45844:	108007cc 	andi	r2,r2,31
   45848:	10000226 	beq	r2,zero,45854 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   4584c:	e0bffc17 	ldw	r2,-16(fp)
   45850:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   45854:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   45858:	0001883a 	nop
   4585c:	e037883a 	mov	sp,fp
   45860:	df000017 	ldw	fp,0(sp)
   45864:	dec00104 	addi	sp,sp,4
   45868:	f800283a 	ret

0004586c <exit>:
   4586c:	defffe04 	addi	sp,sp,-8
   45870:	000b883a 	mov	r5,zero
   45874:	dc000015 	stw	r16,0(sp)
   45878:	dfc00115 	stw	ra,4(sp)
   4587c:	2021883a 	mov	r16,r4
   45880:	00458bc0 	call	458bc <__call_exitprocs>
   45884:	8009883a 	mov	r4,r16
   45888:	0045a4c0 	call	45a4c <_exit>

0004588c <memcmp>:
   4588c:	218d883a 	add	r6,r4,r6
   45890:	21800826 	beq	r4,r6,458b4 <memcmp+0x28>
   45894:	20800003 	ldbu	r2,0(r4)
   45898:	28c00003 	ldbu	r3,0(r5)
   4589c:	10c00226 	beq	r2,r3,458a8 <memcmp+0x1c>
   458a0:	10c5c83a 	sub	r2,r2,r3
   458a4:	f800283a 	ret
   458a8:	21000044 	addi	r4,r4,1
   458ac:	29400044 	addi	r5,r5,1
   458b0:	003ff706 	br	45890 <__alt_data_end+0xfffdd890>
   458b4:	0005883a 	mov	r2,zero
   458b8:	f800283a 	ret

000458bc <__call_exitprocs>:
   458bc:	defff504 	addi	sp,sp,-44
   458c0:	dd000515 	stw	r20,20(sp)
   458c4:	05000134 	movhi	r20,4
   458c8:	dc800315 	stw	r18,12(sp)
   458cc:	dfc00a15 	stw	ra,40(sp)
   458d0:	df000915 	stw	fp,36(sp)
   458d4:	ddc00815 	stw	r23,32(sp)
   458d8:	dd800715 	stw	r22,28(sp)
   458dc:	dd400615 	stw	r21,24(sp)
   458e0:	dcc00415 	stw	r19,16(sp)
   458e4:	dc400215 	stw	r17,8(sp)
   458e8:	dc000115 	stw	r16,4(sp)
   458ec:	d9000015 	stw	r4,0(sp)
   458f0:	2825883a 	mov	r18,r5
   458f4:	a51e3f04 	addi	r20,r20,30972
   458f8:	a4400017 	ldw	r17,0(r20)
   458fc:	8cc00c17 	ldw	r19,48(r17)
   45900:	8c400c04 	addi	r17,r17,48
   45904:	98004526 	beq	r19,zero,45a1c <__call_exitprocs+0x160>
   45908:	9c000117 	ldw	r16,4(r19)
   4590c:	00900034 	movhi	r2,16384
   45910:	10bfffc4 	addi	r2,r2,-1
   45914:	9d402217 	ldw	r21,136(r19)
   45918:	85bfffc4 	addi	r22,r16,-1
   4591c:	80a1883a 	add	r16,r16,r2
   45920:	8421883a 	add	r16,r16,r16
   45924:	8421883a 	add	r16,r16,r16
   45928:	ac2f883a 	add	r23,r21,r16
   4592c:	84000204 	addi	r16,r16,8
   45930:	9c21883a 	add	r16,r19,r16
   45934:	b0002716 	blt	r22,zero,459d4 <__call_exitprocs+0x118>
   45938:	90000726 	beq	r18,zero,45958 <__call_exitprocs+0x9c>
   4593c:	a800041e 	bne	r21,zero,45950 <__call_exitprocs+0x94>
   45940:	b5bfffc4 	addi	r22,r22,-1
   45944:	bdffff04 	addi	r23,r23,-4
   45948:	843fff04 	addi	r16,r16,-4
   4594c:	003ff906 	br	45934 <__alt_data_end+0xfffdd934>
   45950:	b9002017 	ldw	r4,128(r23)
   45954:	913ffa1e 	bne	r18,r4,45940 <__alt_data_end+0xfffdd940>
   45958:	99000117 	ldw	r4,4(r19)
   4595c:	82000017 	ldw	r8,0(r16)
   45960:	213fffc4 	addi	r4,r4,-1
   45964:	b100021e 	bne	r22,r4,45970 <__call_exitprocs+0xb4>
   45968:	9d800115 	stw	r22,4(r19)
   4596c:	00000106 	br	45974 <__call_exitprocs+0xb8>
   45970:	80000015 	stw	zero,0(r16)
   45974:	403ff226 	beq	r8,zero,45940 <__alt_data_end+0xfffdd940>
   45978:	9f000117 	ldw	fp,4(r19)
   4597c:	a8000526 	beq	r21,zero,45994 <__call_exitprocs+0xd8>
   45980:	00800044 	movi	r2,1
   45984:	1592983a 	sll	r9,r2,r22
   45988:	a9404017 	ldw	r5,256(r21)
   4598c:	494a703a 	and	r5,r9,r5
   45990:	2800021e 	bne	r5,zero,4599c <__call_exitprocs+0xe0>
   45994:	403ee83a 	callr	r8
   45998:	00000906 	br	459c0 <__call_exitprocs+0x104>
   4599c:	a9004117 	ldw	r4,260(r21)
   459a0:	4908703a 	and	r4,r9,r4
   459a4:	2000041e 	bne	r4,zero,459b8 <__call_exitprocs+0xfc>
   459a8:	b9400017 	ldw	r5,0(r23)
   459ac:	d9000017 	ldw	r4,0(sp)
   459b0:	403ee83a 	callr	r8
   459b4:	00000206 	br	459c0 <__call_exitprocs+0x104>
   459b8:	b9000017 	ldw	r4,0(r23)
   459bc:	403ee83a 	callr	r8
   459c0:	99000117 	ldw	r4,4(r19)
   459c4:	e13fcc1e 	bne	fp,r4,458f8 <__alt_data_end+0xfffdd8f8>
   459c8:	89000017 	ldw	r4,0(r17)
   459cc:	993fdc26 	beq	r19,r4,45940 <__alt_data_end+0xfffdd940>
   459d0:	003fc906 	br	458f8 <__alt_data_end+0xfffdd8f8>
   459d4:	00800034 	movhi	r2,0
   459d8:	10800004 	addi	r2,r2,0
   459dc:	10000f26 	beq	r2,zero,45a1c <__call_exitprocs+0x160>
   459e0:	99400117 	ldw	r5,4(r19)
   459e4:	99000017 	ldw	r4,0(r19)
   459e8:	2800091e 	bne	r5,zero,45a10 <__call_exitprocs+0x154>
   459ec:	20000826 	beq	r4,zero,45a10 <__call_exitprocs+0x154>
   459f0:	89000015 	stw	r4,0(r17)
   459f4:	a8000226 	beq	r21,zero,45a00 <__call_exitprocs+0x144>
   459f8:	a809883a 	mov	r4,r21
   459fc:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   45a00:	9809883a 	mov	r4,r19
   45a04:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   45a08:	8cc00017 	ldw	r19,0(r17)
   45a0c:	003fbd06 	br	45904 <__alt_data_end+0xfffdd904>
   45a10:	9823883a 	mov	r17,r19
   45a14:	2027883a 	mov	r19,r4
   45a18:	003fba06 	br	45904 <__alt_data_end+0xfffdd904>
   45a1c:	dfc00a17 	ldw	ra,40(sp)
   45a20:	df000917 	ldw	fp,36(sp)
   45a24:	ddc00817 	ldw	r23,32(sp)
   45a28:	dd800717 	ldw	r22,28(sp)
   45a2c:	dd400617 	ldw	r21,24(sp)
   45a30:	dd000517 	ldw	r20,20(sp)
   45a34:	dcc00417 	ldw	r19,16(sp)
   45a38:	dc800317 	ldw	r18,12(sp)
   45a3c:	dc400217 	ldw	r17,8(sp)
   45a40:	dc000117 	ldw	r16,4(sp)
   45a44:	dec00b04 	addi	sp,sp,44
   45a48:	f800283a 	ret

00045a4c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   45a4c:	defffd04 	addi	sp,sp,-12
   45a50:	df000215 	stw	fp,8(sp)
   45a54:	df000204 	addi	fp,sp,8
   45a58:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   45a5c:	0001883a 	nop
   45a60:	e0bfff17 	ldw	r2,-4(fp)
   45a64:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
   45a68:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   45a6c:	10000226 	beq	r2,zero,45a78 <_exit+0x2c>
    ALT_SIM_FAIL();
   45a70:	002af070 	cmpltui	zero,zero,43969
   45a74:	00000106 	br	45a7c <_exit+0x30>
  } else {
    ALT_SIM_PASS();
   45a78:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   45a7c:	003fff06 	br	45a7c <__alt_data_end+0xfffdda7c>
