
alarm_clock_jukebox.elf:     file format elf32-littlenios2
alarm_clock_jukebox.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00040244

Program Header:
    LOAD off    0x00001000 vaddr 0x00040000 paddr 0x00040000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00040020 paddr 0x00040020 align 2**12
         filesz 0x00003fa0 memsz 0x00003fa0 flags r-x
    LOAD off    0x00004fc0 vaddr 0x00043fc0 paddr 0x000442ac align 2**12
         filesz 0x000002ec memsz 0x000002ec flags rw-
    LOAD off    0x00005598 vaddr 0x00044598 paddr 0x00044598 align 2**12
         filesz 0x00000000 memsz 0x00000134 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00040000  00040000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  00040020  00040020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00003ac4  00040244  00040244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000002b8  00043d08  00043d08  00004d08  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000002ec  00043fc0  000442ac  00004fc0  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000134  00044598  00044598  00005598  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  000446cc  000446cc  000052ac  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000052ac  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000006b8  00000000  00000000  000052d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00008661  00000000  00000000  00005988  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002f57  00000000  00000000  0000dfe9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000382e  00000000  00000000  00010f40  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000010dc  00000000  00000000  00014770  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001ff6  00000000  00000000  0001584c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00001308  00000000  00000000  00017842  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000020  00000000  00000000  00018b4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000002a0  00000000  00000000  00018b70  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0001ae52  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000a  00000000  00000000  0001ae55  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0001ae5f  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0001ae60  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0001ae61  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0001ae65  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0001ae69  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   0000000b  00000000  00000000  0001ae6d  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    0000000b  00000000  00000000  0001ae78  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   0000000b  00000000  00000000  0001ae83  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000b  00000000  00000000  0001ae8e  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000061  00000000  00000000  0001ae99  2**0
                  CONTENTS, READONLY
 29 .jdi          0000599a  00000000  00000000  0001aefa  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00086d2b  00000000  00000000  00020894  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00040000 l    d  .entry	00000000 .entry
00040020 l    d  .exceptions	00000000 .exceptions
00040244 l    d  .text	00000000 .text
00043d08 l    d  .rodata	00000000 .rodata
00043fc0 l    d  .rwdata	00000000 .rwdata
00044598 l    d  .bss	00000000 .bss
000446cc l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../alarm_clock_jukebox_bsp//obj/HAL/src/crt0.o
0004027c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 display.c
00000000 l    df *ABS*	00000000 interrupt.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 pwm.c
00000000 l    df *ABS*	00000000 rtttl.c
00000000 l    df *ABS*	00000000 switches.c
0004459f l     O .bss	00000006 mode.1651
00000000 l    df *ABS*	00000000 time_keeper.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00041f88 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00043fc0 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
000428e4 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00042a3c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00042b70 l     F .text	00000034 alt_dev_reg
000440a0 l     O .rwdata	0000002c jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00042e6c l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_close.c
00042f60 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0004308c l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
000430b8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00043268 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
000433a8 l     F .text	0000003c alt_get_errno
000433e4 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
000445c0 g     O .bss	00000004 alt_instruction_exception_handler
000429d0 g     F .text	0000006c alt_main
00041ed8 g     F .text	00000080 _puts_r
000445cc g     O .bss	00000100 alt_irq
000442ac g       *ABS*	00000000 __flash_rwdata_start
00041e8c g     F .text	0000004c printf
00041430 g     F .text	00000084 getClockTime
00041648 g     F .text	000000b0 upClockHour
000405fc g     F .text	00000048 buttonsRegisterISR
00040ff8 g     F .text	0000002c downVolume
00043804 g     F .text	00000024 altera_nios2_gen2_irq_init
00040000 g     F .entry	0000001c __reset
00040020 g       *ABS*	00000000 __flash_exceptions_start
000445ac g     O .bss	00000004 errno
000445b8 g     O .bss	00000004 alt_argv
0004c274 g       *ABS*	00000000 _gp
0004427f g     O .rwdata	00000001 time_format
000406f4 g     F .text	00000030 alarmLEDon
000440f4 g     O .rwdata	00000180 alt_fd_list
00043828 g     F .text	00000090 alt_find_dev
0004332c g     F .text	0000007c alt_io_redirect
00041f58 g     F .text	00000014 puts
000431cc g     F .text	0000009c alt_exception_cause_generated_bad_addr
00042cec g     F .text	000000ec altera_avalon_jtag_uart_read
00041e50 g     F .text	0000003c _printf_r
00041d94 g     F .text	00000064 .hidden __udivsi3
00043a64 g     F .text	00000090 alt_icache_flush
00044274 g     O .rwdata	00000001 volume
000405b4 g     F .text	00000048 switchesRegisterISR
0004429c g     O .rwdata	00000004 alt_max_fd
00044276 g     O .rwdata	00000006 unused_switches
00041bf0 g     F .text	000000ac downAlarmHour
000417c4 g     F .text	000000c8 downClockMinute
00044280 g     O .rwdata	00000004 _global_impure_ptr
0004196c g     F .text	00000084 getAlarmTime
000446cc g       *ABS*	00000000 __bss_end
000427f4 g     F .text	000000f0 alt_iic_isr_register
000436fc g     F .text	00000108 alt_tick
00040998 g     F .text	00000234 switchesISR
000427a8 g     F .text	0000004c alt_ic_irq_enabled
000445a5 g     O .bss	00000003 alarm
00043660 g     F .text	0000009c alt_alarm_stop
000445b0 g     O .bss	00000004 alt_irq_active
000400fc g     F .exceptions	000000d4 alt_irq_handler
000440cc g     O .rwdata	00000028 alt_dev_null
0004306c g     F .text	00000020 alt_dcache_flush_all
00040848 g     F .text	00000150 timerSecondISR
000442ac g       *ABS*	00000000 __ram_rwdata_end
000419f0 g     F .text	000000a8 upAlarmMinute
00040000 g       *ABS*	00000000 __alt_mem_onchip_memory
00044294 g     O .rwdata	00000008 alt_dev_list
00042a78 g     F .text	000000f8 write
0004188c g     F .text	000000ac downClockHour
00043fc0 g       *ABS*	00000000 __ram_rodata_end
00043d08 g     O .rodata	0000000b COM_ANODE_SEG_TABLE
000414b4 g     F .text	000000cc upClockSecond
00041df8 g     F .text	00000058 .hidden __umodsi3
000406c4 g     F .text	00000030 alarmLEDoff
00040724 g     F .text	0000004c alarmLEDtoggle
000446cc g       *ABS*	00000000 end
00044598 g     O .bss	00000006 mode
000401d0 g     F .exceptions	00000074 alt_instruction_exception_entry
00041b48 g     F .text	000000a8 downAlarmMinute
00068000 g       *ABS*	00000000 __alt_stack_pointer
00042ee4 g     F .text	0000007c alt_avalon_timer_sc_init
00042dd8 g     F .text	00000094 altera_avalon_jtag_uart_write
00041ff4 g     F .text	00000524 ___vfprintf_internal_r
00043b44 g     F .text	00000190 __call_exitprocs
00041044 g     F .text	0000002c upSong
00040244 g     F .text	0000003c _start
000445c4 g     O .bss	00000004 _alt_tick_rate
000445c8 g     O .bss	00000004 _alt_nticks
00042bdc g     F .text	00000050 alt_sys_init
00041318 g     F .text	0000009c checkInvalidMode
00043fc0 g       *ABS*	00000000 __ram_rwdata_start
00043d08 g       *ABS*	00000000 __ram_rodata_start
0004427c g     O .rwdata	00000003 reset_clock_value
00040644 g     F .text	00000040 switchesEnableInterrupt
00040fcc g     F .text	0000002c upVolume
00042c2c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
000439c0 g     F .text	000000a4 alt_get_fd
00043b14 g     F .text	00000030 memcmp
000446cc g       *ABS*	00000000 __alt_stack_base
000413b4 g     F .text	00000044 isPowerOfTwoOrZero
000438b8 g     F .text	00000108 alt_find_file
000430f4 g     F .text	000000a4 alt_dev_llist_insert
000413f8 g     F .text	00000038 resetClockTime
00042534 g     F .text	000000b8 __sfvwrite_small_dev
00044598 g       *ABS*	00000000 __bss_start
00041024 g     F .text	00000020 getSong
00040770 g     F .text	000000d8 main
000445bc g     O .bss	00000004 alt_envp
00042c8c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00040280 g     F .text	00000080 resetDisplay
000442a0 g     O .rwdata	00000004 alt_errno
00041c9c g     F .text	00000084 .hidden __divsi3
000416f8 g     F .text	000000cc downClockSecond
00043d08 g       *ABS*	00000000 __flash_rodata_start
00042ba4 g     F .text	00000038 alt_irq_init
000435fc g     F .text	00000064 alt_release_fd
0004459e g     O .bss	00000001 song_index
000425ec g     F .text	00000058 _write_r
00041580 g     F .text	000000c8 upClockMinute
00044284 g     O .rwdata	00000004 _impure_ptr
000445b4 g     O .bss	00000004 alt_argc
00040020 g       .exceptions	00000000 alt_irq_entry
00040584 g     F .text	00000030 timerSecondEnableInterrupt
0004428c g     O .rwdata	00000008 alt_fs_list
0004109c g     F .text	0000027c determineMode
00040020 g       *ABS*	00000000 __ram_exceptions_start
00042644 g     F .text	00000050 alt_ic_isr_register
000442ac g       *ABS*	00000000 _edata
000446cc g       *ABS*	00000000 _end
00040244 g       *ABS*	00000000 __ram_exceptions_end
00040684 g     F .text	00000040 buttonsEnableInterrupt
0004271c g     F .text	0000008c alt_ic_irq_disable
00043af4 g     F .text	00000020 exit
00041d20 g     F .text	00000074 .hidden __modsi3
00068000 g       *ABS*	00000000 __alt_data_end
00040020 g     F .exceptions	00000000 alt_exception
0004053c g     F .text	00000048 timerSecondRegisterISR
00041a98 g     F .text	000000b0 upAlarmHour
00043cd4 g     F .text	00000034 _exit
00041070 g     F .text	0000002c downSong
00041f6c g     F .text	0000001c strlen
000434a8 g     F .text	00000154 open
000445a8 g     O .bss	00000003 clock
00043f28 g     O .rodata	00000060 mode_lookup_table
00043198 g     F .text	00000034 alt_icache_flush_all
00040bcc g     F .text	000003e0 buttonsISR
00044288 g     O .rwdata	00000004 alt_priority_mask
00042694 g     F .text	00000088 alt_ic_irq_enable
00042518 g     F .text	0000001c __vfprintf_internal
000442a4 g     O .rwdata	00000008 alt_alarm_list
00042f9c g     F .text	000000d0 close
00040fac g     F .text	00000020 getVolume
00041938 g     F .text	00000034 resetAlarmTime
0004294c g     F .text	00000084 alt_load
00040300 g     F .text	0000023c updateDisplay



Disassembly of section .entry:

00040000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   40000:	00820014 	movui	r2,2048
#endif

0:
    initi r2
   40004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   40008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   4000c:	00bffd16 	blt	zero,r2,40004 <__alt_data_end+0xfffd8004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   40010:	00400134 	movhi	at,4
    ori r1, r1, %lo(_start)
   40014:	08409114 	ori	at,at,580
    jmp r1
   40018:	0800683a 	jmp	at
   4001c:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>

Disassembly of section .exceptions:

00040020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   40020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   40024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   40028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   4002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   40030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   40034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   40038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   4003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   40040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   40044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   40048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   4004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   40050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   40054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   40058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   4005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   40060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   40064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   40068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   4006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   40070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   40074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   40078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   4007c:	10000326 	beq	r2,zero,4008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   40080:	20000226 	beq	r4,zero,4008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   40084:	00400fc0 	call	400fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   40088:	00000706 	br	400a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   4008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   40090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
   40094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
   40098:	00401d00 	call	401d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
   4009c:	1000021e 	bne	r2,zero,400a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
   400a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   400a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   400a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   400ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   400b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   400b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   400b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   400bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   400c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   400c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   400c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   400cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   400d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   400d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   400d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   400dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   400e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   400e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   400e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   400ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   400f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   400f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   400f8:	ef80083a 	eret

000400fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   400fc:	defff904 	addi	sp,sp,-28
   40100:	dfc00615 	stw	ra,24(sp)
   40104:	df000515 	stw	fp,20(sp)
   40108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   4010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   40110:	0005313a 	rdctl	r2,ipending
   40114:	e0bffe15 	stw	r2,-8(fp)

  return active;
   40118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   4011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
   40120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   40124:	00800044 	movi	r2,1
   40128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   4012c:	e0fffb17 	ldw	r3,-20(fp)
   40130:	e0bffc17 	ldw	r2,-16(fp)
   40134:	1884703a 	and	r2,r3,r2
   40138:	10001426 	beq	r2,zero,4018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   4013c:	00800134 	movhi	r2,4
   40140:	10917304 	addi	r2,r2,17868
   40144:	e0fffd17 	ldw	r3,-12(fp)
   40148:	180690fa 	slli	r3,r3,3
   4014c:	10c5883a 	add	r2,r2,r3
   40150:	10c00017 	ldw	r3,0(r2)
   40154:	00800134 	movhi	r2,4
   40158:	10917304 	addi	r2,r2,17868
   4015c:	e13ffd17 	ldw	r4,-12(fp)
   40160:	200890fa 	slli	r4,r4,3
   40164:	1105883a 	add	r2,r2,r4
   40168:	10800104 	addi	r2,r2,4
   4016c:	10800017 	ldw	r2,0(r2)
   40170:	1009883a 	mov	r4,r2
   40174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
   40178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   4017c:	0005313a 	rdctl	r2,ipending
   40180:	e0bfff15 	stw	r2,-4(fp)

  return active;
   40184:	e0bfff17 	ldw	r2,-4(fp)
   40188:	00000706 	br	401a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
   4018c:	e0bffc17 	ldw	r2,-16(fp)
   40190:	1085883a 	add	r2,r2,r2
   40194:	e0bffc15 	stw	r2,-16(fp)
      i++;
   40198:	e0bffd17 	ldw	r2,-12(fp)
   4019c:	10800044 	addi	r2,r2,1
   401a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   401a4:	003fe106 	br	4012c <__alt_data_end+0xfffd812c>

    active = alt_irq_pending ();
   401a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
   401ac:	e0bffb17 	ldw	r2,-20(fp)
   401b0:	103fdb1e 	bne	r2,zero,40120 <__alt_data_end+0xfffd8120>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   401b4:	0001883a 	nop
}
   401b8:	0001883a 	nop
   401bc:	e037883a 	mov	sp,fp
   401c0:	dfc00117 	ldw	ra,4(sp)
   401c4:	df000017 	ldw	fp,0(sp)
   401c8:	dec00204 	addi	sp,sp,8
   401cc:	f800283a 	ret

000401d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
   401d0:	defffb04 	addi	sp,sp,-20
   401d4:	dfc00415 	stw	ra,16(sp)
   401d8:	df000315 	stw	fp,12(sp)
   401dc:	df000304 	addi	fp,sp,12
   401e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
   401e4:	000531fa 	rdctl	r2,exception
   401e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
   401ec:	e0bffd17 	ldw	r2,-12(fp)
   401f0:	10801f0c 	andi	r2,r2,124
   401f4:	1004d0ba 	srli	r2,r2,2
   401f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
   401fc:	0005333a 	rdctl	r2,badaddr
   40200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   40204:	d0a0d317 	ldw	r2,-31924(gp)
   40208:	10000726 	beq	r2,zero,40228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   4020c:	d0a0d317 	ldw	r2,-31924(gp)
   40210:	e0fffd17 	ldw	r3,-12(fp)
   40214:	e1bffe17 	ldw	r6,-8(fp)
   40218:	e17fff17 	ldw	r5,-4(fp)
   4021c:	1809883a 	mov	r4,r3
   40220:	103ee83a 	callr	r2
   40224:	00000206 	br	40230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   40228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
   4022c:	0005883a 	mov	r2,zero
}
   40230:	e037883a 	mov	sp,fp
   40234:	dfc00117 	ldw	ra,4(sp)
   40238:	df000017 	ldw	fp,0(sp)
   4023c:	dec00204 	addi	sp,sp,8
   40240:	f800283a 	ret

Disassembly of section .text:

00040244 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   40244:	06c001b4 	movhi	sp,6
    ori sp, sp, %lo(__alt_stack_pointer)
   40248:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
   4024c:	06800134 	movhi	gp,4
    ori gp, gp, %lo(_gp)
   40250:	d6b09d14 	ori	gp,gp,49780
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   40254:	00800134 	movhi	r2,4
    ori r2, r2, %lo(__bss_start)
   40258:	10916614 	ori	r2,r2,17816

    movhi r3, %hi(__bss_end)
   4025c:	00c00134 	movhi	r3,4
    ori r3, r3, %lo(__bss_end)
   40260:	18d1b314 	ori	r3,r3,18124

    beq r2, r3, 1f
   40264:	10c00326 	beq	r2,r3,40274 <_start+0x30>

0:
    stw zero, (r2)
   40268:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   4026c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   40270:	10fffd36 	bltu	r2,r3,40268 <__alt_data_end+0xfffd8268>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   40274:	004294c0 	call	4294c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   40278:	00429d00 	call	429d0 <alt_main>

0004027c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   4027c:	003fff06 	br	4027c <__alt_data_end+0xfffd827c>

00040280 <resetDisplay>:
#include "display.h"

void resetDisplay(void) {
   40280:	deffff04 	addi	sp,sp,-4
   40284:	df000015 	stw	fp,0(sp)
   40288:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR1_BASE, RESET_DISPLAY_VALUE);
   4028c:	00c03004 	movi	r3,192
   40290:	00800234 	movhi	r2,8
   40294:	10841004 	addi	r2,r2,4160
   40298:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR0_BASE, RESET_DISPLAY_VALUE);
   4029c:	00c03004 	movi	r3,192
   402a0:	00800234 	movhi	r2,8
   402a4:	10843404 	addi	r2,r2,4304
   402a8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE1_BASE, RESET_DISPLAY_VALUE);
   402ac:	00c03004 	movi	r3,192
   402b0:	00800234 	movhi	r2,8
   402b4:	10841404 	addi	r2,r2,4176
   402b8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE0_BASE, RESET_DISPLAY_VALUE);
   402bc:	00c03004 	movi	r3,192
   402c0:	00800234 	movhi	r2,8
   402c4:	10843004 	addi	r2,r2,4288
   402c8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND1_BASE, RESET_DISPLAY_VALUE);
   402cc:	00c03004 	movi	r3,192
   402d0:	00800234 	movhi	r2,8
   402d4:	10841804 	addi	r2,r2,4192
   402d8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND0_BASE, RESET_DISPLAY_VALUE);
   402dc:	00c03004 	movi	r3,192
   402e0:	00800234 	movhi	r2,8
   402e4:	10842c04 	addi	r2,r2,4272
   402e8:	10c00035 	stwio	r3,0(r2)
}
   402ec:	0001883a 	nop
   402f0:	e037883a 	mov	sp,fp
   402f4:	df000017 	ldw	fp,0(sp)
   402f8:	dec00104 	addi	sp,sp,4
   402fc:	f800283a 	ret

00040300 <updateDisplay>:
bcd[2] = 512/100 = 5
bcd[1] = (512-5*100)/10 = 12/10 = 1
bcd[0] = (512 - (5*100 + 1*10))/1 = 2
*/
// for the moment, this is hard coded without any for loops
void updateDisplay(struct time time) {
   40300:	defffa04 	addi	sp,sp,-24
   40304:	dfc00515 	stw	ra,20(sp)
   40308:	df000415 	stw	fp,16(sp)
   4030c:	df000404 	addi	fp,sp,16
   40310:	e13fff15 	stw	r4,-4(fp)
  /* determine BCD values for hours, minutes, seconds...
  it's possible that the particular time struct member was set to a predefined
  DIGITS_OFF value, which signifies that the display should CLEAR the associated time unit digits..
  this is a sort of hacky way to check, but for right now it's fine.*/

  if (time.hour == DONT_DISPLAY) {
   40314:	e0bfff03 	ldbu	r2,-4(fp)
   40318:	10803fcc 	andi	r2,r2,255
   4031c:	10801918 	cmpnei	r2,r2,100
   40320:	1000051e 	bne	r2,zero,40338 <updateDisplay+0x38>
    bcd[5] = DIGITS_OFF;
   40324:	00800284 	movi	r2,10
   40328:	e0bffd45 	stb	r2,-11(fp)
    bcd[4] = DIGITS_OFF;
   4032c:	00800284 	movi	r2,10
   40330:	e0bffd05 	stb	r2,-12(fp)
   40334:	00000b06 	br	40364 <updateDisplay+0x64>
  }
  else {
    bcd[5] = time.hour/10;
   40338:	e0bfff03 	ldbu	r2,-4(fp)
   4033c:	10803fcc 	andi	r2,r2,255
   40340:	01400284 	movi	r5,10
   40344:	1009883a 	mov	r4,r2
   40348:	0041d940 	call	41d94 <__udivsi3>
   4034c:	e0bffd45 	stb	r2,-11(fp)
    bcd[4] = time.hour - bcd[5]*10;
   40350:	e0bfff03 	ldbu	r2,-4(fp)
   40354:	e0fffd43 	ldbu	r3,-11(fp)
   40358:	18fffda4 	muli	r3,r3,-10
   4035c:	10c5883a 	add	r2,r2,r3
   40360:	e0bffd05 	stb	r2,-12(fp)
  }
  if (time.minute == DONT_DISPLAY) {
   40364:	e0bfff43 	ldbu	r2,-3(fp)
   40368:	10803fcc 	andi	r2,r2,255
   4036c:	10801918 	cmpnei	r2,r2,100
   40370:	1000051e 	bne	r2,zero,40388 <updateDisplay+0x88>
    bcd[3] = DIGITS_OFF;
   40374:	00800284 	movi	r2,10
   40378:	e0bffcc5 	stb	r2,-13(fp)
    bcd[2] = DIGITS_OFF;
   4037c:	00800284 	movi	r2,10
   40380:	e0bffc85 	stb	r2,-14(fp)
   40384:	00000b06 	br	403b4 <updateDisplay+0xb4>
  }
  else {
    bcd[3] = time.minute/10;
   40388:	e0bfff43 	ldbu	r2,-3(fp)
   4038c:	10803fcc 	andi	r2,r2,255
   40390:	01400284 	movi	r5,10
   40394:	1009883a 	mov	r4,r2
   40398:	0041d940 	call	41d94 <__udivsi3>
   4039c:	e0bffcc5 	stb	r2,-13(fp)
    bcd[2] = time.minute - bcd[3]*10;
   403a0:	e0bfff43 	ldbu	r2,-3(fp)
   403a4:	e0fffcc3 	ldbu	r3,-13(fp)
   403a8:	18fffda4 	muli	r3,r3,-10
   403ac:	10c5883a 	add	r2,r2,r3
   403b0:	e0bffc85 	stb	r2,-14(fp)
  }

  if (time.second == DONT_DISPLAY) {
   403b4:	e0bfff83 	ldbu	r2,-2(fp)
   403b8:	10803fcc 	andi	r2,r2,255
   403bc:	10801918 	cmpnei	r2,r2,100
   403c0:	1000051e 	bne	r2,zero,403d8 <updateDisplay+0xd8>
    bcd[1] = DIGITS_OFF;
   403c4:	00800284 	movi	r2,10
   403c8:	e0bffc45 	stb	r2,-15(fp)
    bcd[0] = DIGITS_OFF;
   403cc:	00800284 	movi	r2,10
   403d0:	e0bffc05 	stb	r2,-16(fp)
   403d4:	00000b06 	br	40404 <updateDisplay+0x104>
  }

  else {
    bcd[1] = time.second/10;
   403d8:	e0bfff83 	ldbu	r2,-2(fp)
   403dc:	10803fcc 	andi	r2,r2,255
   403e0:	01400284 	movi	r5,10
   403e4:	1009883a 	mov	r4,r2
   403e8:	0041d940 	call	41d94 <__udivsi3>
   403ec:	e0bffc45 	stb	r2,-15(fp)
    bcd[0] = time.second - bcd[1]*10;
   403f0:	e0bfff83 	ldbu	r2,-2(fp)
   403f4:	e0fffc43 	ldbu	r3,-15(fp)
   403f8:	18fffda4 	muli	r3,r3,-10
   403fc:	10c5883a 	add	r2,r2,r3
   40400:	e0bffc05 	stb	r2,-16(fp)
  }

  // convert BCD values to LED segment values
  ledseg[5] = COM_ANODE_SEG_TABLE[(bcd[5])];
   40404:	e0bffd43 	ldbu	r2,-11(fp)
   40408:	10c03fcc 	andi	r3,r2,255
   4040c:	00800134 	movhi	r2,4
   40410:	108f4204 	addi	r2,r2,15624
   40414:	10c5883a 	add	r2,r2,r3
   40418:	10800003 	ldbu	r2,0(r2)
   4041c:	e0bffec5 	stb	r2,-5(fp)
  ledseg[4] = COM_ANODE_SEG_TABLE[(bcd[4])];
   40420:	e0bffd03 	ldbu	r2,-12(fp)
   40424:	10c03fcc 	andi	r3,r2,255
   40428:	00800134 	movhi	r2,4
   4042c:	108f4204 	addi	r2,r2,15624
   40430:	10c5883a 	add	r2,r2,r3
   40434:	10800003 	ldbu	r2,0(r2)
   40438:	e0bffe85 	stb	r2,-6(fp)
  ledseg[3] = COM_ANODE_SEG_TABLE[(bcd[3])];
   4043c:	e0bffcc3 	ldbu	r2,-13(fp)
   40440:	10c03fcc 	andi	r3,r2,255
   40444:	00800134 	movhi	r2,4
   40448:	108f4204 	addi	r2,r2,15624
   4044c:	10c5883a 	add	r2,r2,r3
   40450:	10800003 	ldbu	r2,0(r2)
   40454:	e0bffe45 	stb	r2,-7(fp)
  ledseg[2] = COM_ANODE_SEG_TABLE[(bcd[2])];
   40458:	e0bffc83 	ldbu	r2,-14(fp)
   4045c:	10c03fcc 	andi	r3,r2,255
   40460:	00800134 	movhi	r2,4
   40464:	108f4204 	addi	r2,r2,15624
   40468:	10c5883a 	add	r2,r2,r3
   4046c:	10800003 	ldbu	r2,0(r2)
   40470:	e0bffe05 	stb	r2,-8(fp)
  ledseg[1] = COM_ANODE_SEG_TABLE[(bcd[1])];
   40474:	e0bffc43 	ldbu	r2,-15(fp)
   40478:	10c03fcc 	andi	r3,r2,255
   4047c:	00800134 	movhi	r2,4
   40480:	108f4204 	addi	r2,r2,15624
   40484:	10c5883a 	add	r2,r2,r3
   40488:	10800003 	ldbu	r2,0(r2)
   4048c:	e0bffdc5 	stb	r2,-9(fp)
  ledseg[0] = COM_ANODE_SEG_TABLE[(bcd[0])];
   40490:	e0bffc03 	ldbu	r2,-16(fp)
   40494:	10c03fcc 	andi	r3,r2,255
   40498:	00800134 	movhi	r2,4
   4049c:	108f4204 	addi	r2,r2,15624
   404a0:	10c5883a 	add	r2,r2,r3
   404a4:	10800003 	ldbu	r2,0(r2)
   404a8:	e0bffd85 	stb	r2,-10(fp)

  // write to display port
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR1_BASE, ledseg[5]);
   404ac:	e0bffec3 	ldbu	r2,-5(fp)
   404b0:	10c03fcc 	andi	r3,r2,255
   404b4:	00800234 	movhi	r2,8
   404b8:	10841004 	addi	r2,r2,4160
   404bc:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR0_BASE, ledseg[4]);
   404c0:	e0bffe83 	ldbu	r2,-6(fp)
   404c4:	10c03fcc 	andi	r3,r2,255
   404c8:	00800234 	movhi	r2,8
   404cc:	10843404 	addi	r2,r2,4304
   404d0:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE1_BASE, ledseg[3]);
   404d4:	e0bffe43 	ldbu	r2,-7(fp)
   404d8:	10c03fcc 	andi	r3,r2,255
   404dc:	00800234 	movhi	r2,8
   404e0:	10841404 	addi	r2,r2,4176
   404e4:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE0_BASE, ledseg[2]);
   404e8:	e0bffe03 	ldbu	r2,-8(fp)
   404ec:	10c03fcc 	andi	r3,r2,255
   404f0:	00800234 	movhi	r2,8
   404f4:	10843004 	addi	r2,r2,4288
   404f8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND1_BASE, ledseg[1]);
   404fc:	e0bffdc3 	ldbu	r2,-9(fp)
   40500:	10c03fcc 	andi	r3,r2,255
   40504:	00800234 	movhi	r2,8
   40508:	10841804 	addi	r2,r2,4192
   4050c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND0_BASE, ledseg[0]);
   40510:	e0bffd83 	ldbu	r2,-10(fp)
   40514:	10c03fcc 	andi	r3,r2,255
   40518:	00800234 	movhi	r2,8
   4051c:	10842c04 	addi	r2,r2,4272
   40520:	10c00035 	stwio	r3,0(r2)
   40524:	0001883a 	nop
   40528:	e037883a 	mov	sp,fp
   4052c:	dfc00117 	ldw	ra,4(sp)
   40530:	df000017 	ldw	fp,0(sp)
   40534:	dec00204 	addi	sp,sp,8
   40538:	f800283a 	ret

0004053c <timerSecondRegisterISR>:

/* this registration functions receives a pointer to an ISR function which takes
in a pointer to a data structure (isr_context) as a parameter, and does not
return any value (void). ISRFunction() will be called once the timerSecond
interrupt fires, and this ISR resides in main.c */
uint8_t timerSecondRegisterISR(void (*timerSecondISR)(void *isr_context)) {
   4053c:	defffb04 	addi	sp,sp,-20
   40540:	dfc00415 	stw	ra,16(sp)
   40544:	df000315 	stw	fp,12(sp)
   40548:	df000304 	addi	fp,sp,12
   4054c:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(TIMER_SECOND_IRQ_INTERRUPT_CONTROLLER_ID,
   40550:	d8000015 	stw	zero,0(sp)
   40554:	000f883a 	mov	r7,zero
   40558:	e1bfff17 	ldw	r6,-4(fp)
   4055c:	01400044 	movi	r5,1
   40560:	0009883a 	mov	r4,zero
   40564:	00426440 	call	42644 <alt_ic_isr_register>
   40568:	e0bffe05 	stb	r2,-8(fp)
                                            TIMER_SECOND_IRQ,
                                            timerSecondISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   4056c:	e0bffe03 	ldbu	r2,-8(fp)
}
   40570:	e037883a 	mov	sp,fp
   40574:	dfc00117 	ldw	ra,4(sp)
   40578:	df000017 	ldw	fp,0(sp)
   4057c:	dec00204 	addi	sp,sp,8
   40580:	f800283a 	ret

00040584 <timerSecondEnableInterrupt>:

void timerSecondEnableInterrupt(void) {
   40584:	deffff04 	addi	sp,sp,-4
   40588:	df000015 	stw	fp,0(sp)
   4058c:	d839883a 	mov	fp,sp
 IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_SECOND_BASE,
   40590:	00c001c4 	movi	r3,7
   40594:	00800234 	movhi	r2,8
   40598:	10840104 	addi	r2,r2,4100
   4059c:	10c00035 	stwio	r3,0(r2)
                 ALTERA_AVALON_TIMER_CONTROL_CONT_MSK  
               | ALTERA_AVALON_TIMER_CONTROL_START_MSK
               | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
}
   405a0:	0001883a 	nop
   405a4:	e037883a 	mov	sp,fp
   405a8:	df000017 	ldw	fp,0(sp)
   405ac:	dec00104 	addi	sp,sp,4
   405b0:	f800283a 	ret

000405b4 <switchesRegisterISR>:

uint8_t switchesRegisterISR(void (*switchesISR)(void *isr_context)) {
   405b4:	defffb04 	addi	sp,sp,-20
   405b8:	dfc00415 	stw	ra,16(sp)
   405bc:	df000315 	stw	fp,12(sp)
   405c0:	df000304 	addi	fp,sp,12
   405c4:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(SWITCHES_IRQ_INTERRUPT_CONTROLLER_ID,
   405c8:	d8000015 	stw	zero,0(sp)
   405cc:	000f883a 	mov	r7,zero
   405d0:	e1bfff17 	ldw	r6,-4(fp)
   405d4:	01400084 	movi	r5,2
   405d8:	0009883a 	mov	r4,zero
   405dc:	00426440 	call	42644 <alt_ic_isr_register>
   405e0:	e0bffe05 	stb	r2,-8(fp)
                                            SWITCHES_IRQ,
                                            switchesISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   405e4:	e0bffe03 	ldbu	r2,-8(fp)
}
   405e8:	e037883a 	mov	sp,fp
   405ec:	dfc00117 	ldw	ra,4(sp)
   405f0:	df000017 	ldw	fp,0(sp)
   405f4:	dec00204 	addi	sp,sp,8
   405f8:	f800283a 	ret

000405fc <buttonsRegisterISR>:


uint8_t buttonsRegisterISR(void (*buttonsISR)(void *isr_context)) {
   405fc:	defffb04 	addi	sp,sp,-20
   40600:	dfc00415 	stw	ra,16(sp)
   40604:	df000315 	stw	fp,12(sp)
   40608:	df000304 	addi	fp,sp,12
   4060c:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(BUTTONS_IRQ_INTERRUPT_CONTROLLER_ID,
   40610:	d8000015 	stw	zero,0(sp)
   40614:	000f883a 	mov	r7,zero
   40618:	e1bfff17 	ldw	r6,-4(fp)
   4061c:	014000c4 	movi	r5,3
   40620:	0009883a 	mov	r4,zero
   40624:	00426440 	call	42644 <alt_ic_isr_register>
   40628:	e0bffe05 	stb	r2,-8(fp)
                                            BUTTONS_IRQ,
                                            buttonsISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   4062c:	e0bffe03 	ldbu	r2,-8(fp)
}
   40630:	e037883a 	mov	sp,fp
   40634:	dfc00117 	ldw	ra,4(sp)
   40638:	df000017 	ldw	fp,0(sp)
   4063c:	dec00204 	addi	sp,sp,8
   40640:	f800283a 	ret

00040644 <switchesEnableInterrupt>:


void switchesEnableInterrupt(void) {
   40644:	deffff04 	addi	sp,sp,-4
   40648:	df000015 	stw	fp,0(sp)
   4064c:	d839883a 	mov	fp,sp
  // enable all switches to fire interupts
  IOWR_ALTERA_AVALON_PIO_IRQ_MASK(SWITCHES_BASE, SWITCHES_INTERRUPT_MASK);
   40650:	00ffffd4 	movui	r3,65535
   40654:	00800234 	movhi	r2,8
   40658:	10843e04 	addi	r2,r2,4344
   4065c:	10c00035 	stwio	r3,0(r2)
  
  // reset the edge capture register
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(SWITCHES_BASE, 0);
   40660:	0007883a 	mov	r3,zero
   40664:	00800234 	movhi	r2,8
   40668:	10843f04 	addi	r2,r2,4348
   4066c:	10c00035 	stwio	r3,0(r2)
}
   40670:	0001883a 	nop
   40674:	e037883a 	mov	sp,fp
   40678:	df000017 	ldw	fp,0(sp)
   4067c:	dec00104 	addi	sp,sp,4
   40680:	f800283a 	ret

00040684 <buttonsEnableInterrupt>:

void buttonsEnableInterrupt(void) {
   40684:	deffff04 	addi	sp,sp,-4
   40688:	df000015 	stw	fp,0(sp)
   4068c:	d839883a 	mov	fp,sp
  // enable all buttons to fire interupts
  IOWR_ALTERA_AVALON_PIO_IRQ_MASK(BUTTONS_BASE, BUTTONS_INTERRUPT_MASK);
   40690:	00c000c4 	movi	r3,3
   40694:	00800234 	movhi	r2,8
   40698:	10841e04 	addi	r2,r2,4216
   4069c:	10c00035 	stwio	r3,0(r2)
  
  // reset the edge capture register
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   406a0:	0007883a 	mov	r3,zero
   406a4:	00800234 	movhi	r2,8
   406a8:	10841f04 	addi	r2,r2,4220
   406ac:	10c00035 	stwio	r3,0(r2)
}
   406b0:	0001883a 	nop
   406b4:	e037883a 	mov	sp,fp
   406b8:	df000017 	ldw	fp,0(sp)
   406bc:	dec00104 	addi	sp,sp,4
   406c0:	f800283a 	ret

000406c4 <alarmLEDoff>:
#include "led.h"

void alarmLEDoff(void) {
   406c4:	deffff04 	addi	sp,sp,-4
   406c8:	df000015 	stw	fp,0(sp)
   406cc:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, LED_OFF);
   406d0:	0007883a 	mov	r3,zero
   406d4:	00800234 	movhi	r2,8
   406d8:	10842404 	addi	r2,r2,4240
   406dc:	10c00035 	stwio	r3,0(r2)
}
   406e0:	0001883a 	nop
   406e4:	e037883a 	mov	sp,fp
   406e8:	df000017 	ldw	fp,0(sp)
   406ec:	dec00104 	addi	sp,sp,4
   406f0:	f800283a 	ret

000406f4 <alarmLEDon>:

void alarmLEDon(void) {
   406f4:	deffff04 	addi	sp,sp,-4
   406f8:	df000015 	stw	fp,0(sp)
   406fc:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, LED_ON);
   40700:	00c00044 	movi	r3,1
   40704:	00800234 	movhi	r2,8
   40708:	10842404 	addi	r2,r2,4240
   4070c:	10c00035 	stwio	r3,0(r2)
}
   40710:	0001883a 	nop
   40714:	e037883a 	mov	sp,fp
   40718:	df000017 	ldw	fp,0(sp)
   4071c:	dec00104 	addi	sp,sp,4
   40720:	f800283a 	ret

00040724 <alarmLEDtoggle>:

void alarmLEDtoggle(void) {
   40724:	defffe04 	addi	sp,sp,-8
   40728:	df000115 	stw	fp,4(sp)
   4072c:	df000104 	addi	fp,sp,4
  volatile uint8_t led_state;
  led_state = IORD_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE);
   40730:	00800234 	movhi	r2,8
   40734:	10842404 	addi	r2,r2,4240
   40738:	10800037 	ldwio	r2,0(r2)
   4073c:	e0bfff05 	stb	r2,-4(fp)
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, !led_state);
   40740:	e0bfff03 	ldbu	r2,-4(fp)
   40744:	10803fcc 	andi	r2,r2,255
   40748:	1005003a 	cmpeq	r2,r2,zero
   4074c:	10c03fcc 	andi	r3,r2,255
   40750:	00800234 	movhi	r2,8
   40754:	10842404 	addi	r2,r2,4240
   40758:	10c00035 	stwio	r3,0(r2)
   4075c:	0001883a 	nop
   40760:	e037883a 	mov	sp,fp
   40764:	df000017 	ldw	fp,0(sp)
   40768:	dec00104 	addi	sp,sp,4
   4076c:	f800283a 	ret

00040770 <main>:
/* the mode struct is global so that the callback functions 
in main.c can access it and determine the appropiate courses
of action */
struct mode mode;

int main(void) {
   40770:	defffe04 	addi	sp,sp,-8
   40774:	dfc00115 	stw	ra,4(sp)
   40778:	df000015 	stw	fp,0(sp)
   4077c:	d839883a 	mov	fp,sp

  // initialization to "CLOCK" mode
  mode.invalid = FALSE;
   40780:	d020c905 	stb	zero,-31964(gp)
  mode.display = DISP_CLOCK;
   40784:	d020c945 	stb	zero,-31963(gp)
  mode.alarm = OFF;
   40788:	d020c985 	stb	zero,-31962(gp)
  mode.config.on = FALSE;
   4078c:	d020c9c5 	stb	zero,-31961(gp)
  mode.config.hour = FALSE;
   40790:	d020ca05 	stb	zero,-31960(gp)
  mode.config.minute = FALSE;
   40794:	d020ca45 	stb	zero,-31959(gp)

  alarmLEDoff();
   40798:	00406c40 	call	406c4 <alarmLEDoff>
  resetClockTime();
   4079c:	00413f80 	call	413f8 <resetClockTime>
  resetAlarmTime();
   407a0:	00419380 	call	41938 <resetAlarmTime>
  resetDisplay();
   407a4:	00402800 	call	40280 <resetDisplay>

  /* the callback ISR is passed in for the registration. When the timer peripheral
  fires its interrupt, timerSecondISR() will be called
  timerSecondISR can be preceded with or without & (both pass in the function address); 
  because a functionâ€™s name can also be used to get function's address */
  if (timerSecondRegisterISR(&timerSecondISR) == ISR_REGISTRATION_SUCCESS) {
   407a8:	01000134 	movhi	r4,4
   407ac:	21021204 	addi	r4,r4,2120
   407b0:	004053c0 	call	4053c <timerSecondRegisterISR>
   407b4:	10803fcc 	andi	r2,r2,255
   407b8:	1000051e 	bne	r2,zero,407d0 <main+0x60>
    printf("timerSecondISR successively registered!\n");
   407bc:	01000134 	movhi	r4,4
   407c0:	210f4504 	addi	r4,r4,15636
   407c4:	0041f580 	call	41f58 <puts>
    timerSecondEnableInterrupt();
   407c8:	00405840 	call	40584 <timerSecondEnableInterrupt>
   407cc:	00000306 	br	407dc <main+0x6c>
  }
  else {
   printf("ERROR: timerSecondISR unsuccessively registered!\n");
   407d0:	01000134 	movhi	r4,4
   407d4:	210f4f04 	addi	r4,r4,15676
   407d8:	0041f580 	call	41f58 <puts>
  }

  if (switchesRegisterISR(&switchesISR) == ISR_REGISTRATION_SUCCESS) {
   407dc:	01000134 	movhi	r4,4
   407e0:	21026604 	addi	r4,r4,2456
   407e4:	00405b40 	call	405b4 <switchesRegisterISR>
   407e8:	10803fcc 	andi	r2,r2,255
   407ec:	1000051e 	bne	r2,zero,40804 <main+0x94>
    printf("switchesISR successively registered!\n");
   407f0:	01000134 	movhi	r4,4
   407f4:	210f5c04 	addi	r4,r4,15728
   407f8:	0041f580 	call	41f58 <puts>
    switchesEnableInterrupt();
   407fc:	00406440 	call	40644 <switchesEnableInterrupt>
   40800:	00000306 	br	40810 <main+0xa0>
  }
  else {
   printf("ERROR: switchesISR unsuccessively registered!\n");
   40804:	01000134 	movhi	r4,4
   40808:	210f6604 	addi	r4,r4,15768
   4080c:	0041f580 	call	41f58 <puts>
  }

  if (buttonsRegisterISR(&buttonsISR) == ISR_REGISTRATION_SUCCESS) {
   40810:	01000134 	movhi	r4,4
   40814:	2102f304 	addi	r4,r4,3020
   40818:	00405fc0 	call	405fc <buttonsRegisterISR>
   4081c:	10803fcc 	andi	r2,r2,255
   40820:	1000051e 	bne	r2,zero,40838 <main+0xc8>
    printf("buttonsISR successively registered!\n");
   40824:	01000134 	movhi	r4,4
   40828:	210f7204 	addi	r4,r4,15816
   4082c:	0041f580 	call	41f58 <puts>
    buttonsEnableInterrupt();
   40830:	00406840 	call	40684 <buttonsEnableInterrupt>
   40834:	00000306 	br	40844 <main+0xd4>
  }
  else {
   printf("ERROR: buttonsISR unsuccessively registered!\n");
   40838:	01000134 	movhi	r4,4
   4083c:	210f7b04 	addi	r4,r4,15852
   40840:	0041f580 	call	41f58 <puts>





  while(1) {}  
   40844:	003fff06 	br	40844 <__alt_data_end+0xfffd8844>

00040848 <timerSecondISR>:


/* This is the main ISR that is called whenever the second timer fires its interrupt. 
This ISR lets us update the time of the clock and depending on whether or not the user
is in config mode, carry the time digits. */
void timerSecondISR(void* isr_context) {
   40848:	defffc04 	addi	sp,sp,-16
   4084c:	dfc00315 	stw	ra,12(sp)
   40850:	df000215 	stw	fp,8(sp)
   40854:	df000204 	addi	fp,sp,8
   40858:	e13fff15 	stw	r4,-4(fp)

  /* The TO (timeout) bit is set to 1 when the internal counter reaches zero. Once set by a
  timeout event, the TO bit stays set until explicitly cleared by a master peripheral. 
  The TO bit is cleared by writing 0 to the status register. */
  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_SECOND_BASE, 0);
   4085c:	0007883a 	mov	r3,zero
   40860:	00800234 	movhi	r2,8
   40864:	10840004 	addi	r2,r2,4096
   40868:	10c00035 	stwio	r3,0(r2)

  // temporary time struct for data transfer between modules and printf debugging
  struct time clock;
 
  if (mode.display == DISP_CLOCK) {
   4086c:	d0a0c943 	ldbu	r2,-31963(gp)
   40870:	10803fcc 	andi	r2,r2,255
   40874:	1000291e 	bne	r2,zero,4091c <timerSecondISR+0xd4>
    if (mode.config.on == TRUE) {
   40878:	d0a0c9c3 	ldbu	r2,-31961(gp)
   4087c:	10803fcc 	andi	r2,r2,255
   40880:	10800058 	cmpnei	r2,r2,1
   40884:	10000e1e 	bne	r2,zero,408c0 <timerSecondISR+0x78>
      // since we're in config, we don't want to carry the digits
      clock = upClockSecond(CARRY_OFF);
   40888:	0009883a 	mov	r4,zero
   4088c:	00414b40 	call	414b4 <upClockSecond>
   40890:	e0bffe05 	stb	r2,-8(fp)
   40894:	1006d23a 	srli	r3,r2,8
   40898:	1809883a 	mov	r4,r3
   4089c:	00ffffc4 	movi	r3,-1
   408a0:	20c6703a 	and	r3,r4,r3
   408a4:	e0fffe45 	stb	r3,-7(fp)
   408a8:	1004d43a 	srli	r2,r2,16
   408ac:	1007883a 	mov	r3,r2
   408b0:	00bfffc4 	movi	r2,-1
   408b4:	1884703a 	and	r2,r3,r2
   408b8:	e0bffe85 	stb	r2,-6(fp)
   408bc:	00001406 	br	40910 <timerSecondISR+0xc8>
    }
    else if (mode.config.on == FALSE) {
   408c0:	d0a0c9c3 	ldbu	r2,-31961(gp)
   408c4:	10803fcc 	andi	r2,r2,255
   408c8:	10000e1e 	bne	r2,zero,40904 <timerSecondISR+0xbc>

      // since we're not in config, the time should normally count and carry
      clock = upClockSecond(CARRY_ON);
   408cc:	01000044 	movi	r4,1
   408d0:	00414b40 	call	414b4 <upClockSecond>
   408d4:	e0bffe05 	stb	r2,-8(fp)
   408d8:	1006d23a 	srli	r3,r2,8
   408dc:	1809883a 	mov	r4,r3
   408e0:	00ffffc4 	movi	r3,-1
   408e4:	20c6703a 	and	r3,r4,r3
   408e8:	e0fffe45 	stb	r3,-7(fp)
   408ec:	1004d43a 	srli	r2,r2,16
   408f0:	1007883a 	mov	r3,r2
   408f4:	00bfffc4 	movi	r2,-1
   408f8:	1884703a 	and	r2,r3,r2
   408fc:	e0bffe85 	stb	r2,-6(fp)
   40900:	00000306 	br	40910 <timerSecondISR+0xc8>
    }
    else {
      printf("ERROR: mode.config.on is invalid\n");
   40904:	01000134 	movhi	r4,4
   40908:	210f8704 	addi	r4,r4,15900
   4090c:	0041f580 	call	41f58 <puts>
    }

    // since the time is being displayed, we'll have to update the display
    updateDisplay(clock);
   40910:	e13ffe17 	ldw	r4,-8(fp)
   40914:	00403000 	call	40300 <updateDisplay>
   40918:	00000d06 	br	40950 <timerSecondISR+0x108>


  }
  else {
    // since the current time is not being displayed, we don't update the display
    clock = upClockSecond(CARRY_ON);
   4091c:	01000044 	movi	r4,1
   40920:	00414b40 	call	414b4 <upClockSecond>
   40924:	e0bffe05 	stb	r2,-8(fp)
   40928:	1006d23a 	srli	r3,r2,8
   4092c:	1809883a 	mov	r4,r3
   40930:	00ffffc4 	movi	r3,-1
   40934:	20c6703a 	and	r3,r4,r3
   40938:	e0fffe45 	stb	r3,-7(fp)
   4093c:	1004d43a 	srli	r2,r2,16
   40940:	1007883a 	mov	r3,r2
   40944:	00bfffc4 	movi	r2,-1
   40948:	1884703a 	and	r2,r3,r2
   4094c:	e0bffe85 	stb	r2,-6(fp)
  }

  // for debugging purposes:
  printf("The clock time is currently: %d:%d:%d\n",clock.hour,clock.minute,clock.second);
   40950:	e0bffe03 	ldbu	r2,-8(fp)
   40954:	10803fcc 	andi	r2,r2,255
   40958:	e0fffe43 	ldbu	r3,-7(fp)
   4095c:	18c03fcc 	andi	r3,r3,255
   40960:	e13ffe83 	ldbu	r4,-6(fp)
   40964:	21003fcc 	andi	r4,r4,255
   40968:	200f883a 	mov	r7,r4
   4096c:	180d883a 	mov	r6,r3
   40970:	100b883a 	mov	r5,r2
   40974:	01000134 	movhi	r4,4
   40978:	210f9004 	addi	r4,r4,15936
   4097c:	0041e8c0 	call	41e8c <printf>
}
   40980:	0001883a 	nop
   40984:	e037883a 	mov	sp,fp
   40988:	dfc00117 	ldw	ra,4(sp)
   4098c:	df000017 	ldw	fp,0(sp)
   40990:	dec00204 	addi	sp,sp,8
   40994:	f800283a 	ret

00040998 <switchesISR>:


/* This ISR lets us determine what mode the user is currently requesting.
Once this mode is determined, the system will update the display to match what was requested,
and perform other actions such as turn on/off the alarm and on/off a song*/
void switchesISR(void* isr_context) {
   40998:	defffa04 	addi	sp,sp,-24
   4099c:	dfc00515 	stw	ra,20(sp)
   409a0:	df000415 	stw	fp,16(sp)
   409a4:	df000404 	addi	fp,sp,16
   409a8:	e13fff15 	stw	r4,-4(fp)

  // reset edge capture register by writing to it 
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(SWITCHES_BASE, 0);
   409ac:	0007883a 	mov	r3,zero
   409b0:	00800234 	movhi	r2,8
   409b4:	10843f04 	addi	r2,r2,4348
   409b8:	10c00035 	stwio	r3,0(r2)

  /* temporary mode struct for data transfer between modules and for testing
  the requested mode based on the switches state */
  struct mode mode_request;

  mode_request = determineMode();
   409bc:	004109c0 	call	4109c <determineMode>
   409c0:	1009883a 	mov	r4,r2
   409c4:	180b883a 	mov	r5,r3
   409c8:	e13ffc05 	stb	r4,-16(fp)
   409cc:	2004d23a 	srli	r2,r4,8
   409d0:	1007883a 	mov	r3,r2
   409d4:	00bfffc4 	movi	r2,-1
   409d8:	1884703a 	and	r2,r3,r2
   409dc:	e0bffc45 	stb	r2,-15(fp)
   409e0:	2004d43a 	srli	r2,r4,16
   409e4:	1007883a 	mov	r3,r2
   409e8:	00bfffc4 	movi	r2,-1
   409ec:	1884703a 	and	r2,r3,r2
   409f0:	e0bffc85 	stb	r2,-14(fp)
   409f4:	2004d63a 	srli	r2,r4,24
   409f8:	e0bffcc5 	stb	r2,-13(fp)
   409fc:	e17ffd05 	stb	r5,-12(fp)
   40a00:	2804d23a 	srli	r2,r5,8
   40a04:	1007883a 	mov	r3,r2
   40a08:	00bfffc4 	movi	r2,-1
   40a0c:	1884703a 	and	r2,r3,r2
   40a10:	e0bffd45 	stb	r2,-11(fp)

  /* if an invalid mode is requested, nothing needs to change except for the mode struct
  if however a valid mode is requested, we have to determine what display to change to
  and/or if the alarm needs to be turned on/off */
  if (mode_request.invalid == FALSE) {
   40a14:	e0bffc03 	ldbu	r2,-16(fp)
   40a18:	10803fcc 	andi	r2,r2,255
   40a1c:	1000561e 	bne	r2,zero,40b78 <switchesISR+0x1e0>

    /* if we're already displaying the same mode that was requested, we don't need 
    need to update the display. Thus we can skip the following if statement*/
    if (mode_request.display != mode.display) {
   40a20:	e0fffc43 	ldbu	r3,-15(fp)
   40a24:	d0a0c943 	ldbu	r2,-31963(gp)
   40a28:	18c03fcc 	andi	r3,r3,255
   40a2c:	10803fcc 	andi	r2,r2,255
   40a30:	18804726 	beq	r3,r2,40b50 <switchesISR+0x1b8>
      although the struct's name is time, the information located 
      in this struct is not necessarily time data. This struct could contain
      volume or song information as well. */
      struct time display;

      switch(mode_request.display) {
   40a34:	e0bffc43 	ldbu	r2,-15(fp)
   40a38:	10803fcc 	andi	r2,r2,255
   40a3c:	10c00060 	cmpeqi	r3,r2,1
   40a40:	1800161e 	bne	r3,zero,40a9c <switchesISR+0x104>
   40a44:	10c00088 	cmpgei	r3,r2,2
   40a48:	1800021e 	bne	r3,zero,40a54 <switchesISR+0xbc>
   40a4c:	10000626 	beq	r2,zero,40a68 <switchesISR+0xd0>
   40a50:	00002d06 	br	40b08 <switchesISR+0x170>
   40a54:	10c000a0 	cmpeqi	r3,r2,2
   40a58:	18001d1e 	bne	r3,zero,40ad0 <switchesISR+0x138>
   40a5c:	108000e0 	cmpeqi	r2,r2,3
   40a60:	1000221e 	bne	r2,zero,40aec <switchesISR+0x154>
   40a64:	00002806 	br	40b08 <switchesISR+0x170>
        case DISP_CLOCK: 
          display = getClockTime();
   40a68:	00414300 	call	41430 <getClockTime>
   40a6c:	e0bffd85 	stb	r2,-10(fp)
   40a70:	1006d23a 	srli	r3,r2,8
   40a74:	1809883a 	mov	r4,r3
   40a78:	00ffffc4 	movi	r3,-1
   40a7c:	20c6703a 	and	r3,r4,r3
   40a80:	e0fffdc5 	stb	r3,-9(fp)
   40a84:	1004d43a 	srli	r2,r2,16
   40a88:	1007883a 	mov	r3,r2
   40a8c:	00bfffc4 	movi	r2,-1
   40a90:	1884703a 	and	r2,r3,r2
   40a94:	e0bffe05 	stb	r2,-8(fp)
          break;
   40a98:	00001e06 	br	40b14 <switchesISR+0x17c>

        case DISP_ALARM:
          display = getAlarmTime();
   40a9c:	004196c0 	call	4196c <getAlarmTime>
   40aa0:	e0bffd85 	stb	r2,-10(fp)
   40aa4:	1006d23a 	srli	r3,r2,8
   40aa8:	1809883a 	mov	r4,r3
   40aac:	00ffffc4 	movi	r3,-1
   40ab0:	20c6703a 	and	r3,r4,r3
   40ab4:	e0fffdc5 	stb	r3,-9(fp)
   40ab8:	1004d43a 	srli	r2,r2,16
   40abc:	1007883a 	mov	r3,r2
   40ac0:	00bfffc4 	movi	r2,-1
   40ac4:	1884703a 	and	r2,r3,r2
   40ac8:	e0bffe05 	stb	r2,-8(fp)
          break;
   40acc:	00001106 	br	40b14 <switchesISR+0x17c>

        case DISP_VOLUME:
          /* the current volume will be displayed on the "second" 
          7 segment displays. For the moment this means that we're not going
          to check if the volume exceeds 99 (max number that can be displayed with 2 digits) */
          display.hour = DONT_DISPLAY;
   40ad0:	00801904 	movi	r2,100
   40ad4:	e0bffd85 	stb	r2,-10(fp)
          display.minute = DONT_DISPLAY;
   40ad8:	00801904 	movi	r2,100
   40adc:	e0bffdc5 	stb	r2,-9(fp)
          display.second = getVolume();
   40ae0:	0040fac0 	call	40fac <getVolume>
   40ae4:	e0bffe05 	stb	r2,-8(fp)
          break;
   40ae8:	00000a06 	br	40b14 <switchesISR+0x17c>

        case DISP_SONG:
          /* the current song will be displayed on the "second" 
          7 segment displays. For the moment this means that we're not going
          to check if the song index exceeds 99 (max number that can be displayed with 2 digits) */
          display.hour = DONT_DISPLAY;
   40aec:	00801904 	movi	r2,100
   40af0:	e0bffd85 	stb	r2,-10(fp)
          display.minute = DONT_DISPLAY;
   40af4:	00801904 	movi	r2,100
   40af8:	e0bffdc5 	stb	r2,-9(fp)
          display.second = getSong();
   40afc:	00410240 	call	41024 <getSong>
   40b00:	e0bffe05 	stb	r2,-8(fp)
          // call playSong() here
          break;
   40b04:	00000306 	br	40b14 <switchesISR+0x17c>

        default:
          printf("ERORR: An invalid display mode is requested\n");
   40b08:	01000134 	movhi	r4,4
   40b0c:	210f9a04 	addi	r4,r4,15976
   40b10:	0041f580 	call	41f58 <puts>
      }

      // since the display mode was changed, we'll have to update the display
      updateDisplay(display);  
   40b14:	e0bffd8b 	ldhu	r2,-10(fp)
   40b18:	e0fffe0b 	ldhu	r3,-8(fp)
   40b1c:	18c03fcc 	andi	r3,r3,255
   40b20:	1806943a 	slli	r3,r3,16
   40b24:	1888b03a 	or	r4,r3,r2
   40b28:	0007883a 	mov	r3,zero
   40b2c:	00804034 	movhi	r2,256
   40b30:	10bfffc4 	addi	r2,r2,-1
   40b34:	2084703a 	and	r2,r4,r2
   40b38:	18ffc02c 	andhi	r3,r3,65280
   40b3c:	1884b03a 	or	r2,r3,r2
   40b40:	1007883a 	mov	r3,r2
   40b44:	1809883a 	mov	r4,r3
   40b48:	00403000 	call	40300 <updateDisplay>
   40b4c:	00000306 	br	40b5c <switchesISR+0x1c4>
    }

    // (mode_request.display == mode.display)
    else { 
      printf("The requested display mode is already active\n");
   40b50:	01000134 	movhi	r4,4
   40b54:	210fa504 	addi	r4,r4,16020
   40b58:	0041f580 	call	41f58 <puts>
    }

    // update the alarm mode if necessary
    if (mode_request.alarm == OFF) {
   40b5c:	e0bffc83 	ldbu	r2,-14(fp)
   40b60:	10803fcc 	andi	r2,r2,255
   40b64:	1000021e 	bne	r2,zero,40b70 <switchesISR+0x1d8>
      alarmLEDoff();
   40b68:	00406c40 	call	406c4 <alarmLEDoff>
   40b6c:	00000506 	br	40b84 <switchesISR+0x1ec>
      }
    }

    // (mode_request.alarm == ON)
    else {
      alarmLEDon();
   40b70:	00406f40 	call	406f4 <alarmLEDon>
   40b74:	00000306 	br	40b84 <switchesISR+0x1ec>
    }
  }

  // (mode_request.invalid == TRUE)
  else {
    printf("ERROR: An invalid mode was requested\n");
   40b78:	01000134 	movhi	r4,4
   40b7c:	210fb104 	addi	r4,r4,16068
   40b80:	0041f580 	call	41f58 <puts>
  }

  // make sure to update the mode struct before leaving ISR
  mode = mode_request;
   40b84:	e0bffc03 	ldbu	r2,-16(fp)
   40b88:	d0a0c905 	stb	r2,-31964(gp)
   40b8c:	e0bffc43 	ldbu	r2,-15(fp)
   40b90:	d0a0c945 	stb	r2,-31963(gp)
   40b94:	e0bffc83 	ldbu	r2,-14(fp)
   40b98:	d0a0c985 	stb	r2,-31962(gp)
   40b9c:	e0bffcc3 	ldbu	r2,-13(fp)
   40ba0:	d0a0c9c5 	stb	r2,-31961(gp)
   40ba4:	e0bffd03 	ldbu	r2,-12(fp)
   40ba8:	d0a0ca05 	stb	r2,-31960(gp)
   40bac:	e0bffd43 	ldbu	r2,-11(fp)
   40bb0:	d0a0ca45 	stb	r2,-31959(gp)
  return;
   40bb4:	0001883a 	nop

}
   40bb8:	e037883a 	mov	sp,fp
   40bbc:	dfc00117 	ldw	ra,4(sp)
   40bc0:	df000017 	ldw	fp,0(sp)
   40bc4:	dec00204 	addi	sp,sp,8
   40bc8:	f800283a 	ret

00040bcc <buttonsISR>:


/* This ISR lets us determine what sort of operation the user wants to perform for the
correctly active display mode (increase/decrease clock time, song select, etc.).
Once the requested operation is determined, the system will update the display to match what was requested */
void buttonsISR(void* isr_context) {
   40bcc:	defffc04 	addi	sp,sp,-16
   40bd0:	dfc00315 	stw	ra,12(sp)
   40bd4:	df000215 	stw	fp,8(sp)
   40bd8:	df000204 	addi	fp,sp,8
   40bdc:	e13fff15 	stw	r4,-4(fp)

  // if the user is not currently configuring something (time, alarm, etc), then a button press won't do anything
  if (mode.config.on == FALSE) {
   40be0:	d0a0c9c3 	ldbu	r2,-31961(gp)
   40be4:	10803fcc 	andi	r2,r2,255
   40be8:	1000051e 	bne	r2,zero,40c00 <buttonsISR+0x34>
    // we can't forget to reset edge capture register by writing to it though!
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   40bec:	0007883a 	mov	r3,zero
   40bf0:	00800234 	movhi	r2,8
   40bf4:	10841f04 	addi	r2,r2,4220
   40bf8:	10c00035 	stwio	r3,0(r2)
    return;
   40bfc:	0000e606 	br	40f98 <buttonsISR+0x3cc>
  }
  else {
    // determine the operation requested based on the buttons state
    uint8_t buttons_state = IORD_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE);
   40c00:	00800234 	movhi	r2,8
   40c04:	10841f04 	addi	r2,r2,4220
   40c08:	10800037 	ldwio	r2,0(r2)
   40c0c:	e0bffe05 	stb	r2,-8(fp)
      struct time display;

      /* what happens next is entirely dependant on what the current display mode is, whether or not 
      the button press was an UP or DOWN operation, and finally if the config was for the minute or hour time units.
      This scary case statement figures it out */
      switch(mode.display) {
   40c10:	d0a0c943 	ldbu	r2,-31963(gp)
   40c14:	10803fcc 	andi	r2,r2,255
   40c18:	10c00060 	cmpeqi	r3,r2,1
   40c1c:	1800551e 	bne	r3,zero,40d74 <buttonsISR+0x1a8>
   40c20:	10c00088 	cmpgei	r3,r2,2
   40c24:	1800021e 	bne	r3,zero,40c30 <buttonsISR+0x64>
   40c28:	10000626 	beq	r2,zero,40c44 <buttonsISR+0x78>
   40c2c:	0000bb06 	br	40f1c <buttonsISR+0x350>
   40c30:	10c000a0 	cmpeqi	r3,r2,2
   40c34:	1800991e 	bne	r3,zero,40e9c <buttonsISR+0x2d0>
   40c38:	108000e0 	cmpeqi	r2,r2,3
   40c3c:	1000a71e 	bne	r2,zero,40edc <buttonsISR+0x310>
   40c40:	0000b606 	br	40f1c <buttonsISR+0x350>

        case DISP_CLOCK: 

          if (buttons_state == UP) {
   40c44:	e0bffe03 	ldbu	r2,-8(fp)
   40c48:	10800098 	cmpnei	r2,r2,2
   40c4c:	1000231e 	bne	r2,zero,40cdc <buttonsISR+0x110>
            if (mode.config.hour == TRUE) {
   40c50:	d0a0ca03 	ldbu	r2,-31960(gp)
   40c54:	10803fcc 	andi	r2,r2,255
   40c58:	10800058 	cmpnei	r2,r2,1
   40c5c:	10000d1e 	bne	r2,zero,40c94 <buttonsISR+0xc8>
              display = upClockHour();
   40c60:	00416480 	call	41648 <upClockHour>
   40c64:	e0bffe45 	stb	r2,-7(fp)
   40c68:	1006d23a 	srli	r3,r2,8
   40c6c:	1809883a 	mov	r4,r3
   40c70:	00ffffc4 	movi	r3,-1
   40c74:	20c6703a 	and	r3,r4,r3
   40c78:	e0fffe85 	stb	r3,-6(fp)
   40c7c:	1004d43a 	srli	r2,r2,16
   40c80:	1007883a 	mov	r3,r2
   40c84:	00bfffc4 	movi	r2,-1
   40c88:	1884703a 	and	r2,r3,r2
   40c8c:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   40c90:	0000a606 	br	40f2c <buttonsISR+0x360>

          if (buttons_state == UP) {
            if (mode.config.hour == TRUE) {
              display = upClockHour();
            }
            else if (mode.config.minute == TRUE) {
   40c94:	d0a0ca43 	ldbu	r2,-31959(gp)
   40c98:	10803fcc 	andi	r2,r2,255
   40c9c:	10800058 	cmpnei	r2,r2,1
   40ca0:	1000a21e 	bne	r2,zero,40f2c <buttonsISR+0x360>
              display = upClockMinute(CARRY_OFF);
   40ca4:	0009883a 	mov	r4,zero
   40ca8:	00415800 	call	41580 <upClockMinute>
   40cac:	e0bffe45 	stb	r2,-7(fp)
   40cb0:	1006d23a 	srli	r3,r2,8
   40cb4:	1809883a 	mov	r4,r3
   40cb8:	00ffffc4 	movi	r3,-1
   40cbc:	20c6703a 	and	r3,r4,r3
   40cc0:	e0fffe85 	stb	r3,-6(fp)
   40cc4:	1004d43a 	srli	r2,r2,16
   40cc8:	1007883a 	mov	r3,r2
   40ccc:	00bfffc4 	movi	r2,-1
   40cd0:	1884703a 	and	r2,r3,r2
   40cd4:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   40cd8:	00009406 	br	40f2c <buttonsISR+0x360>
            }
            else if (mode.config.minute == TRUE) {
              display = upClockMinute(CARRY_OFF);
            }
          }
          else if (buttons_state == DOWN) {
   40cdc:	e0bffe03 	ldbu	r2,-8(fp)
   40ce0:	10800058 	cmpnei	r2,r2,1
   40ce4:	1000911e 	bne	r2,zero,40f2c <buttonsISR+0x360>
            if (mode.config.hour == TRUE) {
   40ce8:	d0a0ca03 	ldbu	r2,-31960(gp)
   40cec:	10803fcc 	andi	r2,r2,255
   40cf0:	10800058 	cmpnei	r2,r2,1
   40cf4:	10000d1e 	bne	r2,zero,40d2c <buttonsISR+0x160>
              display = downClockHour();
   40cf8:	004188c0 	call	4188c <downClockHour>
   40cfc:	e0bffe45 	stb	r2,-7(fp)
   40d00:	1006d23a 	srli	r3,r2,8
   40d04:	1809883a 	mov	r4,r3
   40d08:	00ffffc4 	movi	r3,-1
   40d0c:	20c6703a 	and	r3,r4,r3
   40d10:	e0fffe85 	stb	r3,-6(fp)
   40d14:	1004d43a 	srli	r2,r2,16
   40d18:	1007883a 	mov	r3,r2
   40d1c:	00bfffc4 	movi	r2,-1
   40d20:	1884703a 	and	r2,r3,r2
   40d24:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   40d28:	00008006 	br	40f2c <buttonsISR+0x360>
          }
          else if (buttons_state == DOWN) {
            if (mode.config.hour == TRUE) {
              display = downClockHour();
            }
            else if (mode.config.minute == TRUE) {
   40d2c:	d0a0ca43 	ldbu	r2,-31959(gp)
   40d30:	10803fcc 	andi	r2,r2,255
   40d34:	10800058 	cmpnei	r2,r2,1
   40d38:	10007c1e 	bne	r2,zero,40f2c <buttonsISR+0x360>
              display = downClockMinute(CARRY_OFF);
   40d3c:	0009883a 	mov	r4,zero
   40d40:	00417c40 	call	417c4 <downClockMinute>
   40d44:	e0bffe45 	stb	r2,-7(fp)
   40d48:	1006d23a 	srli	r3,r2,8
   40d4c:	1809883a 	mov	r4,r3
   40d50:	00ffffc4 	movi	r3,-1
   40d54:	20c6703a 	and	r3,r4,r3
   40d58:	e0fffe85 	stb	r3,-6(fp)
   40d5c:	1004d43a 	srli	r2,r2,16
   40d60:	1007883a 	mov	r3,r2
   40d64:	00bfffc4 	movi	r2,-1
   40d68:	1884703a 	and	r2,r3,r2
   40d6c:	e0bffec5 	stb	r2,-5(fp)
            }
          }
          break;
   40d70:	00006e06 	br	40f2c <buttonsISR+0x360>

        case DISP_ALARM:

          if (buttons_state == UP) {
   40d74:	e0bffe03 	ldbu	r2,-8(fp)
   40d78:	10800098 	cmpnei	r2,r2,2
   40d7c:	1000221e 	bne	r2,zero,40e08 <buttonsISR+0x23c>
            if (mode.config.hour == TRUE) {
   40d80:	d0a0ca03 	ldbu	r2,-31960(gp)
   40d84:	10803fcc 	andi	r2,r2,255
   40d88:	10800058 	cmpnei	r2,r2,1
   40d8c:	10000d1e 	bne	r2,zero,40dc4 <buttonsISR+0x1f8>
              display = upAlarmHour();
   40d90:	0041a980 	call	41a98 <upAlarmHour>
   40d94:	e0bffe45 	stb	r2,-7(fp)
   40d98:	1006d23a 	srli	r3,r2,8
   40d9c:	1809883a 	mov	r4,r3
   40da0:	00ffffc4 	movi	r3,-1
   40da4:	20c6703a 	and	r3,r4,r3
   40da8:	e0fffe85 	stb	r3,-6(fp)
   40dac:	1004d43a 	srli	r2,r2,16
   40db0:	1007883a 	mov	r3,r2
   40db4:	00bfffc4 	movi	r2,-1
   40db8:	1884703a 	and	r2,r3,r2
   40dbc:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   40dc0:	00005c06 	br	40f34 <buttonsISR+0x368>

          if (buttons_state == UP) {
            if (mode.config.hour == TRUE) {
              display = upAlarmHour();
            }
            else if (mode.config.minute == TRUE) {
   40dc4:	d0a0ca43 	ldbu	r2,-31959(gp)
   40dc8:	10803fcc 	andi	r2,r2,255
   40dcc:	10800058 	cmpnei	r2,r2,1
   40dd0:	1000581e 	bne	r2,zero,40f34 <buttonsISR+0x368>
              display = upAlarmMinute();
   40dd4:	00419f00 	call	419f0 <upAlarmMinute>
   40dd8:	e0bffe45 	stb	r2,-7(fp)
   40ddc:	1006d23a 	srli	r3,r2,8
   40de0:	1809883a 	mov	r4,r3
   40de4:	00ffffc4 	movi	r3,-1
   40de8:	20c6703a 	and	r3,r4,r3
   40dec:	e0fffe85 	stb	r3,-6(fp)
   40df0:	1004d43a 	srli	r2,r2,16
   40df4:	1007883a 	mov	r3,r2
   40df8:	00bfffc4 	movi	r2,-1
   40dfc:	1884703a 	and	r2,r3,r2
   40e00:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   40e04:	00004b06 	br	40f34 <buttonsISR+0x368>
            }
            else if (mode.config.minute == TRUE) {
              display = upAlarmMinute();
            }
          }
          else if (buttons_state == DOWN) {
   40e08:	e0bffe03 	ldbu	r2,-8(fp)
   40e0c:	10800058 	cmpnei	r2,r2,1
   40e10:	1000481e 	bne	r2,zero,40f34 <buttonsISR+0x368>
            if (mode.config.hour == TRUE) {
   40e14:	d0a0ca03 	ldbu	r2,-31960(gp)
   40e18:	10803fcc 	andi	r2,r2,255
   40e1c:	10800058 	cmpnei	r2,r2,1
   40e20:	10000d1e 	bne	r2,zero,40e58 <buttonsISR+0x28c>
              display = downAlarmHour();
   40e24:	0041bf00 	call	41bf0 <downAlarmHour>
   40e28:	e0bffe45 	stb	r2,-7(fp)
   40e2c:	1006d23a 	srli	r3,r2,8
   40e30:	1809883a 	mov	r4,r3
   40e34:	00ffffc4 	movi	r3,-1
   40e38:	20c6703a 	and	r3,r4,r3
   40e3c:	e0fffe85 	stb	r3,-6(fp)
   40e40:	1004d43a 	srli	r2,r2,16
   40e44:	1007883a 	mov	r3,r2
   40e48:	00bfffc4 	movi	r2,-1
   40e4c:	1884703a 	and	r2,r3,r2
   40e50:	e0bffec5 	stb	r2,-5(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   40e54:	00003706 	br	40f34 <buttonsISR+0x368>
          }
          else if (buttons_state == DOWN) {
            if (mode.config.hour == TRUE) {
              display = downAlarmHour();
            }
            else if (mode.config.minute == TRUE) {
   40e58:	d0a0ca43 	ldbu	r2,-31959(gp)
   40e5c:	10803fcc 	andi	r2,r2,255
   40e60:	10800058 	cmpnei	r2,r2,1
   40e64:	1000331e 	bne	r2,zero,40f34 <buttonsISR+0x368>
              display = downAlarmMinute();
   40e68:	0041b480 	call	41b48 <downAlarmMinute>
   40e6c:	e0bffe45 	stb	r2,-7(fp)
   40e70:	1006d23a 	srli	r3,r2,8
   40e74:	1809883a 	mov	r4,r3
   40e78:	00ffffc4 	movi	r3,-1
   40e7c:	20c6703a 	and	r3,r4,r3
   40e80:	e0fffe85 	stb	r3,-6(fp)
   40e84:	1004d43a 	srli	r2,r2,16
   40e88:	1007883a 	mov	r3,r2
   40e8c:	00bfffc4 	movi	r2,-1
   40e90:	1884703a 	and	r2,r3,r2
   40e94:	e0bffec5 	stb	r2,-5(fp)
            }
          }
          break;
   40e98:	00002606 	br	40f34 <buttonsISR+0x368>


        case DISP_VOLUME:

          display.hour = DONT_DISPLAY;
   40e9c:	00801904 	movi	r2,100
   40ea0:	e0bffe45 	stb	r2,-7(fp)
          display.minute = DONT_DISPLAY;
   40ea4:	00801904 	movi	r2,100
   40ea8:	e0bffe85 	stb	r2,-6(fp)
          if (buttons_state == UP) {
   40eac:	e0bffe03 	ldbu	r2,-8(fp)
   40eb0:	10800098 	cmpnei	r2,r2,2
   40eb4:	1000031e 	bne	r2,zero,40ec4 <buttonsISR+0x2f8>
            display.second = upVolume();
   40eb8:	0040fcc0 	call	40fcc <upVolume>
   40ebc:	e0bffec5 	stb	r2,-5(fp)
          }
          else if (buttons_state == DOWN) {
            display.second = downVolume();
          }
          
          break;
   40ec0:	00001e06 	br	40f3c <buttonsISR+0x370>
          display.hour = DONT_DISPLAY;
          display.minute = DONT_DISPLAY;
          if (buttons_state == UP) {
            display.second = upVolume();
          }
          else if (buttons_state == DOWN) {
   40ec4:	e0bffe03 	ldbu	r2,-8(fp)
   40ec8:	10800058 	cmpnei	r2,r2,1
   40ecc:	10001b1e 	bne	r2,zero,40f3c <buttonsISR+0x370>
            display.second = downVolume();
   40ed0:	0040ff80 	call	40ff8 <downVolume>
   40ed4:	e0bffec5 	stb	r2,-5(fp)
          }
          
          break;
   40ed8:	00001806 	br	40f3c <buttonsISR+0x370>

        case DISP_SONG:

          display.hour = DONT_DISPLAY;
   40edc:	00801904 	movi	r2,100
   40ee0:	e0bffe45 	stb	r2,-7(fp)
          display.minute = DONT_DISPLAY;
   40ee4:	00801904 	movi	r2,100
   40ee8:	e0bffe85 	stb	r2,-6(fp)
          if (buttons_state == UP) {
   40eec:	e0bffe03 	ldbu	r2,-8(fp)
   40ef0:	10800098 	cmpnei	r2,r2,2
   40ef4:	1000031e 	bne	r2,zero,40f04 <buttonsISR+0x338>
            display.second = upSong();
   40ef8:	00410440 	call	41044 <upSong>
   40efc:	e0bffec5 	stb	r2,-5(fp)
          }
          else if (buttons_state == DOWN) {
            display.second = downSong();
          }
          // call playSong() here
          break;
   40f00:	00001006 	br	40f44 <buttonsISR+0x378>
          display.hour = DONT_DISPLAY;
          display.minute = DONT_DISPLAY;
          if (buttons_state == UP) {
            display.second = upSong();
          }
          else if (buttons_state == DOWN) {
   40f04:	e0bffe03 	ldbu	r2,-8(fp)
   40f08:	10800058 	cmpnei	r2,r2,1
   40f0c:	10000d1e 	bne	r2,zero,40f44 <buttonsISR+0x378>
            display.second = downSong();
   40f10:	00410700 	call	41070 <downSong>
   40f14:	e0bffec5 	stb	r2,-5(fp)
          }
          // call playSong() here
          break;
   40f18:	00000a06 	br	40f44 <buttonsISR+0x378>

        default:
          // if the switches.c module didn't mess up, this should never print!
          printf("ERORR: The system is currently in an invalid display mode!!\n");
   40f1c:	01000134 	movhi	r4,4
   40f20:	210fbb04 	addi	r4,r4,16108
   40f24:	0041f580 	call	41f58 <puts>
   40f28:	00000706 	br	40f48 <buttonsISR+0x37c>
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   40f2c:	0001883a 	nop
   40f30:	00000506 	br	40f48 <buttonsISR+0x37c>
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   40f34:	0001883a 	nop
   40f38:	00000306 	br	40f48 <buttonsISR+0x37c>
          }
          else if (buttons_state == DOWN) {
            display.second = downVolume();
          }
          
          break;
   40f3c:	0001883a 	nop
   40f40:	00000106 	br	40f48 <buttonsISR+0x37c>
          }
          else if (buttons_state == DOWN) {
            display.second = downSong();
          }
          // call playSong() here
          break;
   40f44:	0001883a 	nop
          // if the switches.c module didn't mess up, this should never print!
          printf("ERORR: The system is currently in an invalid display mode!!\n");
      }

      // since the display mode was changed, we'll have to update the display
      updateDisplay(display);  
   40f48:	e0bffe43 	ldbu	r2,-7(fp)
   40f4c:	e0fffe83 	ldbu	r3,-6(fp)
   40f50:	1806923a 	slli	r3,r3,8
   40f54:	1884b03a 	or	r2,r3,r2
   40f58:	e0fffec3 	ldbu	r3,-5(fp)
   40f5c:	1806943a 	slli	r3,r3,16
   40f60:	1888b03a 	or	r4,r3,r2
   40f64:	0007883a 	mov	r3,zero
   40f68:	00804034 	movhi	r2,256
   40f6c:	10bfffc4 	addi	r2,r2,-1
   40f70:	2084703a 	and	r2,r4,r2
   40f74:	18ffc02c 	andhi	r3,r3,65280
   40f78:	1884b03a 	or	r2,r3,r2
   40f7c:	1007883a 	mov	r3,r2
   40f80:	1809883a 	mov	r4,r3
   40f84:	00403000 	call	40300 <updateDisplay>
    }

  // we can't forget to reset edge capture register by writing to it!
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   40f88:	0007883a 	mov	r3,zero
   40f8c:	00800234 	movhi	r2,8
   40f90:	10841f04 	addi	r2,r2,4220
   40f94:	10c00035 	stwio	r3,0(r2)

}
   40f98:	e037883a 	mov	sp,fp
   40f9c:	dfc00117 	ldw	ra,4(sp)
   40fa0:	df000017 	ldw	fp,0(sp)
   40fa4:	dec00204 	addi	sp,sp,8
   40fa8:	f800283a 	ret

00040fac <getVolume>:
#include "pwm.h"

uint8_t volume = 5;

uint8_t getVolume(void) {
   40fac:	deffff04 	addi	sp,sp,-4
   40fb0:	df000015 	stw	fp,0(sp)
   40fb4:	d839883a 	mov	fp,sp
  return volume;
   40fb8:	d0a00003 	ldbu	r2,-32768(gp)
}
   40fbc:	e037883a 	mov	sp,fp
   40fc0:	df000017 	ldw	fp,0(sp)
   40fc4:	dec00104 	addi	sp,sp,4
   40fc8:	f800283a 	ret

00040fcc <upVolume>:

uint8_t upVolume(void) {
   40fcc:	deffff04 	addi	sp,sp,-4
   40fd0:	df000015 	stw	fp,0(sp)
   40fd4:	d839883a 	mov	fp,sp
  volume++;
   40fd8:	d0a00003 	ldbu	r2,-32768(gp)
   40fdc:	10800044 	addi	r2,r2,1
   40fe0:	d0a00005 	stb	r2,-32768(gp)
  return volume;
   40fe4:	d0a00003 	ldbu	r2,-32768(gp)
}
   40fe8:	e037883a 	mov	sp,fp
   40fec:	df000017 	ldw	fp,0(sp)
   40ff0:	dec00104 	addi	sp,sp,4
   40ff4:	f800283a 	ret

00040ff8 <downVolume>:

uint8_t downVolume(void) {
   40ff8:	deffff04 	addi	sp,sp,-4
   40ffc:	df000015 	stw	fp,0(sp)
   41000:	d839883a 	mov	fp,sp
  volume--;
   41004:	d0a00003 	ldbu	r2,-32768(gp)
   41008:	10bfffc4 	addi	r2,r2,-1
   4100c:	d0a00005 	stb	r2,-32768(gp)
  return volume;
   41010:	d0a00003 	ldbu	r2,-32768(gp)
   41014:	e037883a 	mov	sp,fp
   41018:	df000017 	ldw	fp,0(sp)
   4101c:	dec00104 	addi	sp,sp,4
   41020:	f800283a 	ret

00041024 <getSong>:
#include "rtttl.h"

uint8_t song_index = 0;

uint8_t getSong(void) {
   41024:	deffff04 	addi	sp,sp,-4
   41028:	df000015 	stw	fp,0(sp)
   4102c:	d839883a 	mov	fp,sp
  return song_index;
   41030:	d0a0ca83 	ldbu	r2,-31958(gp)
}
   41034:	e037883a 	mov	sp,fp
   41038:	df000017 	ldw	fp,0(sp)
   4103c:	dec00104 	addi	sp,sp,4
   41040:	f800283a 	ret

00041044 <upSong>:

uint8_t upSong(void) {
   41044:	deffff04 	addi	sp,sp,-4
   41048:	df000015 	stw	fp,0(sp)
   4104c:	d839883a 	mov	fp,sp
  song_index++;
   41050:	d0a0ca83 	ldbu	r2,-31958(gp)
   41054:	10800044 	addi	r2,r2,1
   41058:	d0a0ca85 	stb	r2,-31958(gp)
  return song_index;
   4105c:	d0a0ca83 	ldbu	r2,-31958(gp)
}
   41060:	e037883a 	mov	sp,fp
   41064:	df000017 	ldw	fp,0(sp)
   41068:	dec00104 	addi	sp,sp,4
   4106c:	f800283a 	ret

00041070 <downSong>:

uint8_t downSong(void) {
   41070:	deffff04 	addi	sp,sp,-4
   41074:	df000015 	stw	fp,0(sp)
   41078:	d839883a 	mov	fp,sp
  song_index--;
   4107c:	d0a0ca83 	ldbu	r2,-31958(gp)
   41080:	10bfffc4 	addi	r2,r2,-1
   41084:	d0a0ca85 	stb	r2,-31958(gp)
  return song_index;
   41088:	d0a0ca83 	ldbu	r2,-31958(gp)
   4108c:	e037883a 	mov	sp,fp
   41090:	df000017 	ldw	fp,0(sp)
   41094:	dec00104 	addi	sp,sp,4
   41098:	f800283a 	ret

0004109c <determineMode>:
#include "switches.h" 

struct mode determineMode(void) {
   4109c:	defff904 	addi	sp,sp,-28
   410a0:	dfc00615 	stw	ra,24(sp)
   410a4:	df000515 	stw	fp,20(sp)
   410a8:	dc400415 	stw	r17,16(sp)
   410ac:	dc000315 	stw	r16,12(sp)
   410b0:	df000504 	addi	fp,sp,20
  ISR, the current mode is known allowing us to determine if an 
  invalid mode was requested */
  static struct mode mode;

  // this variable lets us test whether or not an invalid mode was requested
  volatile uint16_t switches_state_request = IORD_ALTERA_AVALON_PIO_DATA(SWITCHES_BASE);
   410b4:	00800234 	movhi	r2,8
   410b8:	10843c04 	addi	r2,r2,4336
   410bc:	10800037 	ldwio	r2,0(r2)
   410c0:	e0bffd0d 	sth	r2,-12(fp)

  // check if the request is invalid
  if (checkInvalidMode(switches_state_request) == INVALID) {
   410c4:	e0bffd0b 	ldhu	r2,-12(fp)
   410c8:	10bfffcc 	andi	r2,r2,65535
   410cc:	1009883a 	mov	r4,r2
   410d0:	00413180 	call	41318 <checkInvalidMode>
   410d4:	10803fcc 	andi	r2,r2,255
   410d8:	10800058 	cmpnei	r2,r2,1
   410dc:	10000f1e 	bne	r2,zero,4111c <determineMode+0x80>
    mode.invalid = TRUE;
   410e0:	00800044 	movi	r2,1
   410e4:	d0a0cac5 	stb	r2,-31957(gp)
    return mode;
   410e8:	d0a0cac3 	ldbu	r2,-31957(gp)
   410ec:	e0bffb45 	stb	r2,-19(fp)
   410f0:	d0a0cb03 	ldbu	r2,-31956(gp)
   410f4:	e0bffb85 	stb	r2,-18(fp)
   410f8:	d0a0cb43 	ldbu	r2,-31955(gp)
   410fc:	e0bffbc5 	stb	r2,-17(fp)
   41100:	d0a0cb83 	ldbu	r2,-31954(gp)
   41104:	e0bffc05 	stb	r2,-16(fp)
   41108:	d0a0cbc3 	ldbu	r2,-31953(gp)
   4110c:	e0bffc45 	stb	r2,-15(fp)
   41110:	d0a0cc03 	ldbu	r2,-31952(gp)
   41114:	e0bffc85 	stb	r2,-14(fp)
   41118:	00004906 	br	41240 <determineMode+0x1a4>
  }

  else {
    // now that we know the mode request is valid, let's determine what it is
    mode.invalid = FALSE;
   4111c:	d020cac5 	stb	zero,-31957(gp)

    uint8_t i = 0;
   41120:	e03ffb05 	stb	zero,-20(fp)

    // check for the valid mode request in lookup table
    while (switches_state_request != mode_lookup_table[i][0]) {
   41124:	00000606 	br	41140 <determineMode+0xa4>
      i++;
   41128:	e0bffb03 	ldbu	r2,-20(fp)
   4112c:	10800044 	addi	r2,r2,1
   41130:	e0bffb05 	stb	r2,-20(fp)
      // catch error in case the bounds of the lookup table are exceeded
      if (i == NUM_VALID_MODES) {
   41134:	e0bffb03 	ldbu	r2,-20(fp)
   41138:	10800218 	cmpnei	r2,r2,8
   4113c:	10000b26 	beq	r2,zero,4116c <determineMode+0xd0>
    mode.invalid = FALSE;

    uint8_t i = 0;

    // check for the valid mode request in lookup table
    while (switches_state_request != mode_lookup_table[i][0]) {
   41140:	e0fffb03 	ldbu	r3,-20(fp)
   41144:	00800134 	movhi	r2,4
   41148:	108fca04 	addi	r2,r2,16168
   4114c:	18c00324 	muli	r3,r3,12
   41150:	10c5883a 	add	r2,r2,r3
   41154:	10c0000b 	ldhu	r3,0(r2)
   41158:	e0bffd0b 	ldhu	r2,-12(fp)
   4115c:	18ffffcc 	andi	r3,r3,65535
   41160:	10bfffcc 	andi	r2,r2,65535
   41164:	18bff01e 	bne	r3,r2,41128 <__alt_data_end+0xfffd9128>
   41168:	00000106 	br	41170 <determineMode+0xd4>
      i++;
      // catch error in case the bounds of the lookup table are exceeded
      if (i == NUM_VALID_MODES) {
        break;
   4116c:	0001883a 	nop
    }

    // once the valid mode request is find, the while loop ends and we have found
    // the correct mode; its location is determined by the index i
    // at this point, we can update the members of the mode struct
    mode.display = mode_lookup_table[i][1];
   41170:	e0fffb03 	ldbu	r3,-20(fp)
   41174:	00800134 	movhi	r2,4
   41178:	108fca04 	addi	r2,r2,16168
   4117c:	18c00324 	muli	r3,r3,12
   41180:	10c5883a 	add	r2,r2,r3
   41184:	10800084 	addi	r2,r2,2
   41188:	1080000b 	ldhu	r2,0(r2)
   4118c:	d0a0cb05 	stb	r2,-31956(gp)
    mode.config.on = mode_lookup_table[i][2];
   41190:	e0fffb03 	ldbu	r3,-20(fp)
   41194:	00800134 	movhi	r2,4
   41198:	108fca04 	addi	r2,r2,16168
   4119c:	18c00324 	muli	r3,r3,12
   411a0:	10c5883a 	add	r2,r2,r3
   411a4:	10800104 	addi	r2,r2,4
   411a8:	1080000b 	ldhu	r2,0(r2)
   411ac:	d0a0cb85 	stb	r2,-31954(gp)
    mode.config.hour = mode_lookup_table[i][3];
   411b0:	e0fffb03 	ldbu	r3,-20(fp)
   411b4:	00800134 	movhi	r2,4
   411b8:	108fca04 	addi	r2,r2,16168
   411bc:	18c00324 	muli	r3,r3,12
   411c0:	10c5883a 	add	r2,r2,r3
   411c4:	10800184 	addi	r2,r2,6
   411c8:	1080000b 	ldhu	r2,0(r2)
   411cc:	d0a0cbc5 	stb	r2,-31953(gp)
    mode.config.minute = mode_lookup_table[i][4];
   411d0:	e0fffb03 	ldbu	r3,-20(fp)
   411d4:	00800134 	movhi	r2,4
   411d8:	108fca04 	addi	r2,r2,16168
   411dc:	18c00324 	muli	r3,r3,12
   411e0:	10c5883a 	add	r2,r2,r3
   411e4:	10800204 	addi	r2,r2,8
   411e8:	1080000b 	ldhu	r2,0(r2)
   411ec:	d0a0cc05 	stb	r2,-31952(gp)
    mode.alarm = mode_lookup_table[i][5];
   411f0:	e0fffb03 	ldbu	r3,-20(fp)
   411f4:	00800134 	movhi	r2,4
   411f8:	108fca04 	addi	r2,r2,16168
   411fc:	18c00324 	muli	r3,r3,12
   41200:	10c5883a 	add	r2,r2,r3
   41204:	10800284 	addi	r2,r2,10
   41208:	1080000b 	ldhu	r2,0(r2)
   4120c:	d0a0cb45 	stb	r2,-31955(gp)

    return mode;
   41210:	d0a0cac3 	ldbu	r2,-31957(gp)
   41214:	e0bffb45 	stb	r2,-19(fp)
   41218:	d0a0cb03 	ldbu	r2,-31956(gp)
   4121c:	e0bffb85 	stb	r2,-18(fp)
   41220:	d0a0cb43 	ldbu	r2,-31955(gp)
   41224:	e0bffbc5 	stb	r2,-17(fp)
   41228:	d0a0cb83 	ldbu	r2,-31954(gp)
   4122c:	e0bffc05 	stb	r2,-16(fp)
   41230:	d0a0cbc3 	ldbu	r2,-31953(gp)
   41234:	e0bffc45 	stb	r2,-15(fp)
   41238:	d0a0cc03 	ldbu	r2,-31952(gp)
   4123c:	e0bffc85 	stb	r2,-14(fp)
   41240:	0005883a 	mov	r2,zero
   41244:	e0fffb43 	ldbu	r3,-19(fp)
   41248:	18c03fcc 	andi	r3,r3,255
   4124c:	013fc004 	movi	r4,-256
   41250:	1104703a 	and	r2,r2,r4
   41254:	10c4b03a 	or	r2,r2,r3
   41258:	e0fffb83 	ldbu	r3,-18(fp)
   4125c:	18c03fcc 	andi	r3,r3,255
   41260:	1808923a 	slli	r4,r3,8
   41264:	00fffff4 	movhi	r3,65535
   41268:	18c03fc4 	addi	r3,r3,255
   4126c:	10c4703a 	and	r2,r2,r3
   41270:	1104b03a 	or	r2,r2,r4
   41274:	e0fffbc3 	ldbu	r3,-17(fp)
   41278:	18c03fcc 	andi	r3,r3,255
   4127c:	1808943a 	slli	r4,r3,16
   41280:	00ffc074 	movhi	r3,65281
   41284:	18ffffc4 	addi	r3,r3,-1
   41288:	10c4703a 	and	r2,r2,r3
   4128c:	1104b03a 	or	r2,r2,r4
   41290:	e0fffc03 	ldbu	r3,-16(fp)
   41294:	1808963a 	slli	r4,r3,24
   41298:	00c04034 	movhi	r3,256
   4129c:	18ffffc4 	addi	r3,r3,-1
   412a0:	10c4703a 	and	r2,r2,r3
   412a4:	1104b03a 	or	r2,r2,r4
   412a8:	0009883a 	mov	r4,zero
   412ac:	e0fffc43 	ldbu	r3,-15(fp)
   412b0:	18c03fcc 	andi	r3,r3,255
   412b4:	017fc004 	movi	r5,-256
   412b8:	2148703a 	and	r4,r4,r5
   412bc:	20c6b03a 	or	r3,r4,r3
   412c0:	1809883a 	mov	r4,r3
   412c4:	e0fffc83 	ldbu	r3,-14(fp)
   412c8:	18c03fcc 	andi	r3,r3,255
   412cc:	180a923a 	slli	r5,r3,8
   412d0:	00fffff4 	movhi	r3,65535
   412d4:	18c03fc4 	addi	r3,r3,255
   412d8:	20c6703a 	and	r3,r4,r3
   412dc:	1946b03a 	or	r3,r3,r5
   412e0:	1809883a 	mov	r4,r3
   412e4:	1021883a 	mov	r16,r2
   412e8:	2023883a 	mov	r17,r4
   412ec:	8007883a 	mov	r3,r16
   412f0:	8809883a 	mov	r4,r17
  }

}
   412f4:	1805883a 	mov	r2,r3
   412f8:	2007883a 	mov	r3,r4
   412fc:	e6fffe04 	addi	sp,fp,-8
   41300:	dfc00317 	ldw	ra,12(sp)
   41304:	df000217 	ldw	fp,8(sp)
   41308:	dc400117 	ldw	r17,4(sp)
   4130c:	dc000017 	ldw	r16,0(sp)
   41310:	dec00404 	addi	sp,sp,16
   41314:	f800283a 	ret

00041318 <checkInvalidMode>:

uint8_t checkInvalidMode(uint16_t switches_state_request) {
   41318:	defffc04 	addi	sp,sp,-16
   4131c:	dfc00315 	stw	ra,12(sp)
   41320:	df000215 	stw	fp,8(sp)
   41324:	df000204 	addi	fp,sp,8
   41328:	2005883a 	mov	r2,r4
   4132c:	e0bfff0d 	sth	r2,-4(fp)
  // check if an unused switch was turned on
  uint8_t i = 0;
   41330:	e03ffe05 	stb	zero,-8(fp)

  do {
    // if the entire array of unused_switches was searched but an
    // unused switch was not activated, then exit while loop
    if (i == NUM_UNUSED_SWITCHES) {
   41334:	e0bffe03 	ldbu	r2,-8(fp)
   41338:	108000d8 	cmpnei	r2,r2,3
   4133c:	10000e26 	beq	r2,zero,41378 <checkInvalidMode+0x60>
      break;
    }
    // if an unused switch was activated, exit function and indicate that
    // an invalid mode was selected
    else if (switches_state_request == unused_switches[i]) {
   41340:	e0bffe03 	ldbu	r2,-8(fp)
   41344:	1087883a 	add	r3,r2,r2
   41348:	d0a00084 	addi	r2,gp,-32766
   4134c:	1885883a 	add	r2,r3,r2
   41350:	1080000b 	ldhu	r2,0(r2)
   41354:	10ffffcc 	andi	r3,r2,65535
   41358:	e0bfff0b 	ldhu	r2,-4(fp)
   4135c:	1880021e 	bne	r3,r2,41368 <checkInvalidMode+0x50>
      return INVALID;
   41360:	00800044 	movi	r2,1
   41364:	00000e06 	br	413a0 <checkInvalidMode+0x88>
    }

    // increment index of unused_switches array
    i++;
   41368:	e0bffe03 	ldbu	r2,-8(fp)
   4136c:	10800044 	addi	r2,r2,1
   41370:	e0bffe05 	stb	r2,-8(fp)

  } while(1);
   41374:	003fef06 	br	41334 <__alt_data_end+0xfffd9334>

  do {
    // if the entire array of unused_switches was searched but an
    // unused switch was not activated, then exit while loop
    if (i == NUM_UNUSED_SWITCHES) {
      break;
   41378:	0001883a 	nop

  } while(1);

  // now that we know an unused switch is not activated, we need to verify that 
  // the used switches are in a valid configuration
  if ( isPowerOfTwoOrZero(switches_state_request) == TRUE ) {
   4137c:	e0bfff0b 	ldhu	r2,-4(fp)
   41380:	1009883a 	mov	r4,r2
   41384:	00413b40 	call	413b4 <isPowerOfTwoOrZero>
   41388:	10803fcc 	andi	r2,r2,255
   4138c:	10800058 	cmpnei	r2,r2,1
   41390:	1000021e 	bne	r2,zero,4139c <checkInvalidMode+0x84>
    return VALID;
   41394:	0005883a 	mov	r2,zero
   41398:	00000106 	br	413a0 <checkInvalidMode+0x88>
  }

  else {
    return INVALID;
   4139c:	00800044 	movi	r2,1
  }
}
   413a0:	e037883a 	mov	sp,fp
   413a4:	dfc00117 	ldw	ra,4(sp)
   413a8:	df000017 	ldw	fp,0(sp)
   413ac:	dec00204 	addi	sp,sp,8
   413b0:	f800283a 	ret

000413b4 <isPowerOfTwoOrZero>:
6 & 5  != 0 -> invalid!
7 & 6  != 0 -> invalid!
---------------------------------------------
*/ 

uint8_t isPowerOfTwoOrZero(uint16_t value) {
   413b4:	defffe04 	addi	sp,sp,-8
   413b8:	df000115 	stw	fp,4(sp)
   413bc:	df000104 	addi	fp,sp,4
   413c0:	2005883a 	mov	r2,r4
   413c4:	e0bfff0d 	sth	r2,-4(fp)
  if ((value & (value-1)) == 0) {
   413c8:	e0ffff0b 	ldhu	r3,-4(fp)
   413cc:	e0bfff0b 	ldhu	r2,-4(fp)
   413d0:	10bfffc4 	addi	r2,r2,-1
   413d4:	1884703a 	and	r2,r3,r2
   413d8:	1000021e 	bne	r2,zero,413e4 <isPowerOfTwoOrZero+0x30>
    return TRUE;
   413dc:	00800044 	movi	r2,1
   413e0:	00000106 	br	413e8 <isPowerOfTwoOrZero+0x34>
  }
  else {
    return FALSE;
   413e4:	0005883a 	mov	r2,zero
  }
   413e8:	e037883a 	mov	sp,fp
   413ec:	df000017 	ldw	fp,0(sp)
   413f0:	dec00104 	addi	sp,sp,4
   413f4:	f800283a 	ret

000413f8 <resetClockTime>:


/* ------------------------ CLOCK functions ---------------------- */

// initialize clock time to default time (see display.h)
void resetClockTime(void) {
   413f8:	deffff04 	addi	sp,sp,-4
   413fc:	df000015 	stw	fp,0(sp)
   41400:	d839883a 	mov	fp,sp
  clock.hour = reset_clock_value[0];
   41404:	008002c4 	movi	r2,11
   41408:	d0a0cd05 	stb	r2,-31948(gp)
  clock.minute = reset_clock_value[1];
   4140c:	00800ec4 	movi	r2,59
   41410:	d0a0cd45 	stb	r2,-31947(gp)
  clock.second = reset_clock_value[2];
   41414:	0005883a 	mov	r2,zero
   41418:	d0a0cd85 	stb	r2,-31946(gp)
}
   4141c:	0001883a 	nop
   41420:	e037883a 	mov	sp,fp
   41424:	df000017 	ldw	fp,0(sp)
   41428:	dec00104 	addi	sp,sp,4
   4142c:	f800283a 	ret

00041430 <getClockTime>:

struct time getClockTime(void) {
   41430:	defffe04 	addi	sp,sp,-8
   41434:	df000115 	stw	fp,4(sp)
   41438:	df000104 	addi	fp,sp,4
  return clock;
   4143c:	d0a0cd03 	ldbu	r2,-31948(gp)
   41440:	e0bfff05 	stb	r2,-4(fp)
   41444:	d0a0cd43 	ldbu	r2,-31947(gp)
   41448:	e0bfff45 	stb	r2,-3(fp)
   4144c:	d0a0cd83 	ldbu	r2,-31946(gp)
   41450:	e0bfff85 	stb	r2,-2(fp)
   41454:	0005883a 	mov	r2,zero
   41458:	e0ffff03 	ldbu	r3,-4(fp)
   4145c:	18c03fcc 	andi	r3,r3,255
   41460:	013fc004 	movi	r4,-256
   41464:	1104703a 	and	r2,r2,r4
   41468:	10c4b03a 	or	r2,r2,r3
   4146c:	e0ffff43 	ldbu	r3,-3(fp)
   41470:	18c03fcc 	andi	r3,r3,255
   41474:	1808923a 	slli	r4,r3,8
   41478:	00fffff4 	movhi	r3,65535
   4147c:	18c03fc4 	addi	r3,r3,255
   41480:	10c4703a 	and	r2,r2,r3
   41484:	1104b03a 	or	r2,r2,r4
   41488:	e0ffff83 	ldbu	r3,-2(fp)
   4148c:	18c03fcc 	andi	r3,r3,255
   41490:	1808943a 	slli	r4,r3,16
   41494:	00ffc074 	movhi	r3,65281
   41498:	18ffffc4 	addi	r3,r3,-1
   4149c:	10c4703a 	and	r2,r2,r3
   414a0:	1104b03a 	or	r2,r2,r4
}
   414a4:	e037883a 	mov	sp,fp
   414a8:	df000017 	ldw	fp,0(sp)
   414ac:	dec00104 	addi	sp,sp,4
   414b0:	f800283a 	ret

000414b4 <upClockSecond>:

/*--------- up operations -------*/

// SECONDS
struct time upClockSecond(uint8_t carry_setting) {
   414b4:	defffc04 	addi	sp,sp,-16
   414b8:	dfc00315 	stw	ra,12(sp)
   414bc:	df000215 	stw	fp,8(sp)
   414c0:	df000204 	addi	fp,sp,8
   414c4:	2005883a 	mov	r2,r4
   414c8:	e0bfff05 	stb	r2,-4(fp)
  if (clock.second == (ONE_MINUTE-1)) {
   414cc:	d0a0cd83 	ldbu	r2,-31946(gp)
   414d0:	10803fcc 	andi	r2,r2,255
   414d4:	10800ed8 	cmpnei	r2,r2,59
   414d8:	1000071e 	bne	r2,zero,414f8 <upClockSecond+0x44>
    clock.second = 0;
   414dc:	d020cd85 	stb	zero,-31946(gp)
    
    if (carry_setting == CARRY_ON) {
   414e0:	e0bfff03 	ldbu	r2,-4(fp)
   414e4:	10800058 	cmpnei	r2,r2,1
   414e8:	1000061e 	bne	r2,zero,41504 <upClockSecond+0x50>
      upClockMinute(CARRY_ON);
   414ec:	01000044 	movi	r4,1
   414f0:	00415800 	call	41580 <upClockMinute>
   414f4:	00000306 	br	41504 <upClockSecond+0x50>
    }
  }
  else {
    clock.second++;
   414f8:	d0a0cd83 	ldbu	r2,-31946(gp)
   414fc:	10800044 	addi	r2,r2,1
   41500:	d0a0cd85 	stb	r2,-31946(gp)
  }
  return clock;
   41504:	d0a0cd03 	ldbu	r2,-31948(gp)
   41508:	e0bffe05 	stb	r2,-8(fp)
   4150c:	d0a0cd43 	ldbu	r2,-31947(gp)
   41510:	e0bffe45 	stb	r2,-7(fp)
   41514:	d0a0cd83 	ldbu	r2,-31946(gp)
   41518:	e0bffe85 	stb	r2,-6(fp)
   4151c:	0005883a 	mov	r2,zero
   41520:	e0fffe03 	ldbu	r3,-8(fp)
   41524:	18c03fcc 	andi	r3,r3,255
   41528:	013fc004 	movi	r4,-256
   4152c:	1104703a 	and	r2,r2,r4
   41530:	10c4b03a 	or	r2,r2,r3
   41534:	e0fffe43 	ldbu	r3,-7(fp)
   41538:	18c03fcc 	andi	r3,r3,255
   4153c:	1808923a 	slli	r4,r3,8
   41540:	00fffff4 	movhi	r3,65535
   41544:	18c03fc4 	addi	r3,r3,255
   41548:	10c4703a 	and	r2,r2,r3
   4154c:	1104b03a 	or	r2,r2,r4
   41550:	e0fffe83 	ldbu	r3,-6(fp)
   41554:	18c03fcc 	andi	r3,r3,255
   41558:	1808943a 	slli	r4,r3,16
   4155c:	00ffc074 	movhi	r3,65281
   41560:	18ffffc4 	addi	r3,r3,-1
   41564:	10c4703a 	and	r2,r2,r3
   41568:	1104b03a 	or	r2,r2,r4
}
   4156c:	e037883a 	mov	sp,fp
   41570:	dfc00117 	ldw	ra,4(sp)
   41574:	df000017 	ldw	fp,0(sp)
   41578:	dec00204 	addi	sp,sp,8
   4157c:	f800283a 	ret

00041580 <upClockMinute>:

// MINUTES
struct time upClockMinute(uint8_t carry_setting) {
   41580:	defffc04 	addi	sp,sp,-16
   41584:	dfc00315 	stw	ra,12(sp)
   41588:	df000215 	stw	fp,8(sp)
   4158c:	df000204 	addi	fp,sp,8
   41590:	2005883a 	mov	r2,r4
   41594:	e0bfff05 	stb	r2,-4(fp)
  if (clock.minute == (ONE_HOUR-1)) {
   41598:	d0a0cd43 	ldbu	r2,-31947(gp)
   4159c:	10803fcc 	andi	r2,r2,255
   415a0:	10800ed8 	cmpnei	r2,r2,59
   415a4:	1000061e 	bne	r2,zero,415c0 <upClockMinute+0x40>
    clock.minute = 0;
   415a8:	d020cd45 	stb	zero,-31947(gp)
    
    if (carry_setting == CARRY_ON) {
   415ac:	e0bfff03 	ldbu	r2,-4(fp)
   415b0:	10800058 	cmpnei	r2,r2,1
   415b4:	1000051e 	bne	r2,zero,415cc <upClockMinute+0x4c>
      upClockHour();
   415b8:	00416480 	call	41648 <upClockHour>
   415bc:	00000306 	br	415cc <upClockMinute+0x4c>
    }
  }
  else {
    clock.minute++;
   415c0:	d0a0cd43 	ldbu	r2,-31947(gp)
   415c4:	10800044 	addi	r2,r2,1
   415c8:	d0a0cd45 	stb	r2,-31947(gp)
  }
  return clock;
   415cc:	d0a0cd03 	ldbu	r2,-31948(gp)
   415d0:	e0bffe05 	stb	r2,-8(fp)
   415d4:	d0a0cd43 	ldbu	r2,-31947(gp)
   415d8:	e0bffe45 	stb	r2,-7(fp)
   415dc:	d0a0cd83 	ldbu	r2,-31946(gp)
   415e0:	e0bffe85 	stb	r2,-6(fp)
   415e4:	0005883a 	mov	r2,zero
   415e8:	e0fffe03 	ldbu	r3,-8(fp)
   415ec:	18c03fcc 	andi	r3,r3,255
   415f0:	013fc004 	movi	r4,-256
   415f4:	1104703a 	and	r2,r2,r4
   415f8:	10c4b03a 	or	r2,r2,r3
   415fc:	e0fffe43 	ldbu	r3,-7(fp)
   41600:	18c03fcc 	andi	r3,r3,255
   41604:	1808923a 	slli	r4,r3,8
   41608:	00fffff4 	movhi	r3,65535
   4160c:	18c03fc4 	addi	r3,r3,255
   41610:	10c4703a 	and	r2,r2,r3
   41614:	1104b03a 	or	r2,r2,r4
   41618:	e0fffe83 	ldbu	r3,-6(fp)
   4161c:	18c03fcc 	andi	r3,r3,255
   41620:	1808943a 	slli	r4,r3,16
   41624:	00ffc074 	movhi	r3,65281
   41628:	18ffffc4 	addi	r3,r3,-1
   4162c:	10c4703a 	and	r2,r2,r3
   41630:	1104b03a 	or	r2,r2,r4
}
   41634:	e037883a 	mov	sp,fp
   41638:	dfc00117 	ldw	ra,4(sp)
   4163c:	df000017 	ldw	fp,0(sp)
   41640:	dec00204 	addi	sp,sp,8
   41644:	f800283a 	ret

00041648 <upClockHour>:

// HOURS
struct time upClockHour(void) {
   41648:	defffe04 	addi	sp,sp,-8
   4164c:	df000115 	stw	fp,4(sp)
   41650:	df000104 	addi	fp,sp,4
  if (clock.hour == (time_format-1)) {
   41654:	d0a0cd03 	ldbu	r2,-31948(gp)
   41658:	10c03fcc 	andi	r3,r2,255
   4165c:	d0a002c3 	ldbu	r2,-32757(gp)
   41660:	10803fcc 	andi	r2,r2,255
   41664:	10bfffc4 	addi	r2,r2,-1
   41668:	1880021e 	bne	r3,r2,41674 <upClockHour+0x2c>
    clock.hour = 0;
   4166c:	d020cd05 	stb	zero,-31948(gp)
   41670:	00000306 	br	41680 <upClockHour+0x38>
  }
  else {
    clock.hour++;
   41674:	d0a0cd03 	ldbu	r2,-31948(gp)
   41678:	10800044 	addi	r2,r2,1
   4167c:	d0a0cd05 	stb	r2,-31948(gp)
  }
  return clock;
   41680:	d0a0cd03 	ldbu	r2,-31948(gp)
   41684:	e0bfff05 	stb	r2,-4(fp)
   41688:	d0a0cd43 	ldbu	r2,-31947(gp)
   4168c:	e0bfff45 	stb	r2,-3(fp)
   41690:	d0a0cd83 	ldbu	r2,-31946(gp)
   41694:	e0bfff85 	stb	r2,-2(fp)
   41698:	0005883a 	mov	r2,zero
   4169c:	e0ffff03 	ldbu	r3,-4(fp)
   416a0:	18c03fcc 	andi	r3,r3,255
   416a4:	013fc004 	movi	r4,-256
   416a8:	1104703a 	and	r2,r2,r4
   416ac:	10c4b03a 	or	r2,r2,r3
   416b0:	e0ffff43 	ldbu	r3,-3(fp)
   416b4:	18c03fcc 	andi	r3,r3,255
   416b8:	1808923a 	slli	r4,r3,8
   416bc:	00fffff4 	movhi	r3,65535
   416c0:	18c03fc4 	addi	r3,r3,255
   416c4:	10c4703a 	and	r2,r2,r3
   416c8:	1104b03a 	or	r2,r2,r4
   416cc:	e0ffff83 	ldbu	r3,-2(fp)
   416d0:	18c03fcc 	andi	r3,r3,255
   416d4:	1808943a 	slli	r4,r3,16
   416d8:	00ffc074 	movhi	r3,65281
   416dc:	18ffffc4 	addi	r3,r3,-1
   416e0:	10c4703a 	and	r2,r2,r3
   416e4:	1104b03a 	or	r2,r2,r4
}
   416e8:	e037883a 	mov	sp,fp
   416ec:	df000017 	ldw	fp,0(sp)
   416f0:	dec00104 	addi	sp,sp,4
   416f4:	f800283a 	ret

000416f8 <downClockSecond>:

/*--------- down operations -------*/

// SECONDS
struct time downClockSecond(uint8_t carry_setting) {
   416f8:	defffc04 	addi	sp,sp,-16
   416fc:	dfc00315 	stw	ra,12(sp)
   41700:	df000215 	stw	fp,8(sp)
   41704:	df000204 	addi	fp,sp,8
   41708:	2005883a 	mov	r2,r4
   4170c:	e0bfff05 	stb	r2,-4(fp)
  if (clock.second == 0) {
   41710:	d0a0cd83 	ldbu	r2,-31946(gp)
   41714:	10803fcc 	andi	r2,r2,255
   41718:	1000081e 	bne	r2,zero,4173c <downClockSecond+0x44>
    clock.second = (ONE_MINUTE-1);
   4171c:	00800ec4 	movi	r2,59
   41720:	d0a0cd85 	stb	r2,-31946(gp)
    
    if (carry_setting == CARRY_ON) {
   41724:	e0bfff03 	ldbu	r2,-4(fp)
   41728:	10800058 	cmpnei	r2,r2,1
   4172c:	1000061e 	bne	r2,zero,41748 <downClockSecond+0x50>
      downClockMinute(CARRY_ON);
   41730:	01000044 	movi	r4,1
   41734:	00417c40 	call	417c4 <downClockMinute>
   41738:	00000306 	br	41748 <downClockSecond+0x50>
    }
  }
  else {
    clock.second--;
   4173c:	d0a0cd83 	ldbu	r2,-31946(gp)
   41740:	10bfffc4 	addi	r2,r2,-1
   41744:	d0a0cd85 	stb	r2,-31946(gp)
  }
  return clock;
   41748:	d0a0cd03 	ldbu	r2,-31948(gp)
   4174c:	e0bffe05 	stb	r2,-8(fp)
   41750:	d0a0cd43 	ldbu	r2,-31947(gp)
   41754:	e0bffe45 	stb	r2,-7(fp)
   41758:	d0a0cd83 	ldbu	r2,-31946(gp)
   4175c:	e0bffe85 	stb	r2,-6(fp)
   41760:	0005883a 	mov	r2,zero
   41764:	e0fffe03 	ldbu	r3,-8(fp)
   41768:	18c03fcc 	andi	r3,r3,255
   4176c:	013fc004 	movi	r4,-256
   41770:	1104703a 	and	r2,r2,r4
   41774:	10c4b03a 	or	r2,r2,r3
   41778:	e0fffe43 	ldbu	r3,-7(fp)
   4177c:	18c03fcc 	andi	r3,r3,255
   41780:	1808923a 	slli	r4,r3,8
   41784:	00fffff4 	movhi	r3,65535
   41788:	18c03fc4 	addi	r3,r3,255
   4178c:	10c4703a 	and	r2,r2,r3
   41790:	1104b03a 	or	r2,r2,r4
   41794:	e0fffe83 	ldbu	r3,-6(fp)
   41798:	18c03fcc 	andi	r3,r3,255
   4179c:	1808943a 	slli	r4,r3,16
   417a0:	00ffc074 	movhi	r3,65281
   417a4:	18ffffc4 	addi	r3,r3,-1
   417a8:	10c4703a 	and	r2,r2,r3
   417ac:	1104b03a 	or	r2,r2,r4
}
   417b0:	e037883a 	mov	sp,fp
   417b4:	dfc00117 	ldw	ra,4(sp)
   417b8:	df000017 	ldw	fp,0(sp)
   417bc:	dec00204 	addi	sp,sp,8
   417c0:	f800283a 	ret

000417c4 <downClockMinute>:

// MINUTES
struct time downClockMinute(uint8_t carry_setting) {
   417c4:	defffc04 	addi	sp,sp,-16
   417c8:	dfc00315 	stw	ra,12(sp)
   417cc:	df000215 	stw	fp,8(sp)
   417d0:	df000204 	addi	fp,sp,8
   417d4:	2005883a 	mov	r2,r4
   417d8:	e0bfff05 	stb	r2,-4(fp)
  if (clock.minute == 0) {
   417dc:	d0a0cd43 	ldbu	r2,-31947(gp)
   417e0:	10803fcc 	andi	r2,r2,255
   417e4:	1000071e 	bne	r2,zero,41804 <downClockMinute+0x40>
    clock.minute = (ONE_HOUR-1);
   417e8:	00800ec4 	movi	r2,59
   417ec:	d0a0cd45 	stb	r2,-31947(gp)
    
    if (carry_setting == CARRY_ON) {
   417f0:	e0bfff03 	ldbu	r2,-4(fp)
   417f4:	10800058 	cmpnei	r2,r2,1
   417f8:	1000051e 	bne	r2,zero,41810 <downClockMinute+0x4c>
      downClockHour();
   417fc:	004188c0 	call	4188c <downClockHour>
   41800:	00000306 	br	41810 <downClockMinute+0x4c>
    }
  }
  else {
    clock.minute--;
   41804:	d0a0cd43 	ldbu	r2,-31947(gp)
   41808:	10bfffc4 	addi	r2,r2,-1
   4180c:	d0a0cd45 	stb	r2,-31947(gp)
  }
  return clock;
   41810:	d0a0cd03 	ldbu	r2,-31948(gp)
   41814:	e0bffe05 	stb	r2,-8(fp)
   41818:	d0a0cd43 	ldbu	r2,-31947(gp)
   4181c:	e0bffe45 	stb	r2,-7(fp)
   41820:	d0a0cd83 	ldbu	r2,-31946(gp)
   41824:	e0bffe85 	stb	r2,-6(fp)
   41828:	0005883a 	mov	r2,zero
   4182c:	e0fffe03 	ldbu	r3,-8(fp)
   41830:	18c03fcc 	andi	r3,r3,255
   41834:	013fc004 	movi	r4,-256
   41838:	1104703a 	and	r2,r2,r4
   4183c:	10c4b03a 	or	r2,r2,r3
   41840:	e0fffe43 	ldbu	r3,-7(fp)
   41844:	18c03fcc 	andi	r3,r3,255
   41848:	1808923a 	slli	r4,r3,8
   4184c:	00fffff4 	movhi	r3,65535
   41850:	18c03fc4 	addi	r3,r3,255
   41854:	10c4703a 	and	r2,r2,r3
   41858:	1104b03a 	or	r2,r2,r4
   4185c:	e0fffe83 	ldbu	r3,-6(fp)
   41860:	18c03fcc 	andi	r3,r3,255
   41864:	1808943a 	slli	r4,r3,16
   41868:	00ffc074 	movhi	r3,65281
   4186c:	18ffffc4 	addi	r3,r3,-1
   41870:	10c4703a 	and	r2,r2,r3
   41874:	1104b03a 	or	r2,r2,r4
}
   41878:	e037883a 	mov	sp,fp
   4187c:	dfc00117 	ldw	ra,4(sp)
   41880:	df000017 	ldw	fp,0(sp)
   41884:	dec00204 	addi	sp,sp,8
   41888:	f800283a 	ret

0004188c <downClockHour>:

// HOURS
struct time downClockHour(void) {
   4188c:	defffe04 	addi	sp,sp,-8
   41890:	df000115 	stw	fp,4(sp)
   41894:	df000104 	addi	fp,sp,4
  if (clock.hour == 0) {
   41898:	d0a0cd03 	ldbu	r2,-31948(gp)
   4189c:	10803fcc 	andi	r2,r2,255
   418a0:	1000041e 	bne	r2,zero,418b4 <downClockHour+0x28>
    clock.hour = (time_format-1);
   418a4:	d0a002c3 	ldbu	r2,-32757(gp)
   418a8:	10bfffc4 	addi	r2,r2,-1
   418ac:	d0a0cd05 	stb	r2,-31948(gp)
   418b0:	00000306 	br	418c0 <downClockHour+0x34>
  }
  else {
    clock.hour--;
   418b4:	d0a0cd03 	ldbu	r2,-31948(gp)
   418b8:	10bfffc4 	addi	r2,r2,-1
   418bc:	d0a0cd05 	stb	r2,-31948(gp)
  }
  return clock;
   418c0:	d0a0cd03 	ldbu	r2,-31948(gp)
   418c4:	e0bfff05 	stb	r2,-4(fp)
   418c8:	d0a0cd43 	ldbu	r2,-31947(gp)
   418cc:	e0bfff45 	stb	r2,-3(fp)
   418d0:	d0a0cd83 	ldbu	r2,-31946(gp)
   418d4:	e0bfff85 	stb	r2,-2(fp)
   418d8:	0005883a 	mov	r2,zero
   418dc:	e0ffff03 	ldbu	r3,-4(fp)
   418e0:	18c03fcc 	andi	r3,r3,255
   418e4:	013fc004 	movi	r4,-256
   418e8:	1104703a 	and	r2,r2,r4
   418ec:	10c4b03a 	or	r2,r2,r3
   418f0:	e0ffff43 	ldbu	r3,-3(fp)
   418f4:	18c03fcc 	andi	r3,r3,255
   418f8:	1808923a 	slli	r4,r3,8
   418fc:	00fffff4 	movhi	r3,65535
   41900:	18c03fc4 	addi	r3,r3,255
   41904:	10c4703a 	and	r2,r2,r3
   41908:	1104b03a 	or	r2,r2,r4
   4190c:	e0ffff83 	ldbu	r3,-2(fp)
   41910:	18c03fcc 	andi	r3,r3,255
   41914:	1808943a 	slli	r4,r3,16
   41918:	00ffc074 	movhi	r3,65281
   4191c:	18ffffc4 	addi	r3,r3,-1
   41920:	10c4703a 	and	r2,r2,r3
   41924:	1104b03a 	or	r2,r2,r4
}
   41928:	e037883a 	mov	sp,fp
   4192c:	df000017 	ldw	fp,0(sp)
   41930:	dec00104 	addi	sp,sp,4
   41934:	f800283a 	ret

00041938 <resetAlarmTime>:


/* ------------------------ ALARM functions ---------------------- */

// initialize alarm time to 00:00 (seconds are turned off)
void resetAlarmTime(void) {
   41938:	deffff04 	addi	sp,sp,-4
   4193c:	df000015 	stw	fp,0(sp)
   41940:	d839883a 	mov	fp,sp
  // necessary to cast to a time struct, otherwise the 
  // value assignment won't work
  alarm =  (struct time){0};
   41944:	d020cc45 	stb	zero,-31951(gp)
   41948:	d020cc85 	stb	zero,-31950(gp)
   4194c:	d020ccc5 	stb	zero,-31949(gp)

  // we explicitly request that the seconds are not displayed
  alarm.second = DONT_DISPLAY;
   41950:	00801904 	movi	r2,100
   41954:	d0a0ccc5 	stb	r2,-31949(gp)
}
   41958:	0001883a 	nop
   4195c:	e037883a 	mov	sp,fp
   41960:	df000017 	ldw	fp,0(sp)
   41964:	dec00104 	addi	sp,sp,4
   41968:	f800283a 	ret

0004196c <getAlarmTime>:

struct time getAlarmTime(void) {
   4196c:	defffe04 	addi	sp,sp,-8
   41970:	df000115 	stw	fp,4(sp)
   41974:	df000104 	addi	fp,sp,4
  return alarm;
   41978:	d0a0cc43 	ldbu	r2,-31951(gp)
   4197c:	e0bfff05 	stb	r2,-4(fp)
   41980:	d0a0cc83 	ldbu	r2,-31950(gp)
   41984:	e0bfff45 	stb	r2,-3(fp)
   41988:	d0a0ccc3 	ldbu	r2,-31949(gp)
   4198c:	e0bfff85 	stb	r2,-2(fp)
   41990:	0005883a 	mov	r2,zero
   41994:	e0ffff03 	ldbu	r3,-4(fp)
   41998:	18c03fcc 	andi	r3,r3,255
   4199c:	013fc004 	movi	r4,-256
   419a0:	1104703a 	and	r2,r2,r4
   419a4:	10c4b03a 	or	r2,r2,r3
   419a8:	e0ffff43 	ldbu	r3,-3(fp)
   419ac:	18c03fcc 	andi	r3,r3,255
   419b0:	1808923a 	slli	r4,r3,8
   419b4:	00fffff4 	movhi	r3,65535
   419b8:	18c03fc4 	addi	r3,r3,255
   419bc:	10c4703a 	and	r2,r2,r3
   419c0:	1104b03a 	or	r2,r2,r4
   419c4:	e0ffff83 	ldbu	r3,-2(fp)
   419c8:	18c03fcc 	andi	r3,r3,255
   419cc:	1808943a 	slli	r4,r3,16
   419d0:	00ffc074 	movhi	r3,65281
   419d4:	18ffffc4 	addi	r3,r3,-1
   419d8:	10c4703a 	and	r2,r2,r3
   419dc:	1104b03a 	or	r2,r2,r4
}
   419e0:	e037883a 	mov	sp,fp
   419e4:	df000017 	ldw	fp,0(sp)
   419e8:	dec00104 	addi	sp,sp,4
   419ec:	f800283a 	ret

000419f0 <upAlarmMinute>:

/*--------- up operations -------*/

// MINUTES
struct time upAlarmMinute(void) {
   419f0:	defffe04 	addi	sp,sp,-8
   419f4:	df000115 	stw	fp,4(sp)
   419f8:	df000104 	addi	fp,sp,4
  if (alarm.minute == (ONE_HOUR-1)) {
   419fc:	d0a0cc83 	ldbu	r2,-31950(gp)
   41a00:	10803fcc 	andi	r2,r2,255
   41a04:	10800ed8 	cmpnei	r2,r2,59
   41a08:	1000021e 	bne	r2,zero,41a14 <upAlarmMinute+0x24>
    alarm.minute = 0;
   41a0c:	d020cc85 	stb	zero,-31950(gp)
   41a10:	00000306 	br	41a20 <upAlarmMinute+0x30>
  }
  else {
    alarm.minute++;
   41a14:	d0a0cc83 	ldbu	r2,-31950(gp)
   41a18:	10800044 	addi	r2,r2,1
   41a1c:	d0a0cc85 	stb	r2,-31950(gp)
  }
  return alarm;
   41a20:	d0a0cc43 	ldbu	r2,-31951(gp)
   41a24:	e0bfff05 	stb	r2,-4(fp)
   41a28:	d0a0cc83 	ldbu	r2,-31950(gp)
   41a2c:	e0bfff45 	stb	r2,-3(fp)
   41a30:	d0a0ccc3 	ldbu	r2,-31949(gp)
   41a34:	e0bfff85 	stb	r2,-2(fp)
   41a38:	0005883a 	mov	r2,zero
   41a3c:	e0ffff03 	ldbu	r3,-4(fp)
   41a40:	18c03fcc 	andi	r3,r3,255
   41a44:	013fc004 	movi	r4,-256
   41a48:	1104703a 	and	r2,r2,r4
   41a4c:	10c4b03a 	or	r2,r2,r3
   41a50:	e0ffff43 	ldbu	r3,-3(fp)
   41a54:	18c03fcc 	andi	r3,r3,255
   41a58:	1808923a 	slli	r4,r3,8
   41a5c:	00fffff4 	movhi	r3,65535
   41a60:	18c03fc4 	addi	r3,r3,255
   41a64:	10c4703a 	and	r2,r2,r3
   41a68:	1104b03a 	or	r2,r2,r4
   41a6c:	e0ffff83 	ldbu	r3,-2(fp)
   41a70:	18c03fcc 	andi	r3,r3,255
   41a74:	1808943a 	slli	r4,r3,16
   41a78:	00ffc074 	movhi	r3,65281
   41a7c:	18ffffc4 	addi	r3,r3,-1
   41a80:	10c4703a 	and	r2,r2,r3
   41a84:	1104b03a 	or	r2,r2,r4
}
   41a88:	e037883a 	mov	sp,fp
   41a8c:	df000017 	ldw	fp,0(sp)
   41a90:	dec00104 	addi	sp,sp,4
   41a94:	f800283a 	ret

00041a98 <upAlarmHour>:

// HOURS
struct time upAlarmHour(void) {
   41a98:	defffe04 	addi	sp,sp,-8
   41a9c:	df000115 	stw	fp,4(sp)
   41aa0:	df000104 	addi	fp,sp,4
  if (alarm.hour == (time_format-1)) {
   41aa4:	d0a0cc43 	ldbu	r2,-31951(gp)
   41aa8:	10c03fcc 	andi	r3,r2,255
   41aac:	d0a002c3 	ldbu	r2,-32757(gp)
   41ab0:	10803fcc 	andi	r2,r2,255
   41ab4:	10bfffc4 	addi	r2,r2,-1
   41ab8:	1880021e 	bne	r3,r2,41ac4 <upAlarmHour+0x2c>
    alarm.hour = 0;
   41abc:	d020cc45 	stb	zero,-31951(gp)
   41ac0:	00000306 	br	41ad0 <upAlarmHour+0x38>
  }
  else {
    alarm.hour++;
   41ac4:	d0a0cc43 	ldbu	r2,-31951(gp)
   41ac8:	10800044 	addi	r2,r2,1
   41acc:	d0a0cc45 	stb	r2,-31951(gp)
  }
  return alarm;
   41ad0:	d0a0cc43 	ldbu	r2,-31951(gp)
   41ad4:	e0bfff05 	stb	r2,-4(fp)
   41ad8:	d0a0cc83 	ldbu	r2,-31950(gp)
   41adc:	e0bfff45 	stb	r2,-3(fp)
   41ae0:	d0a0ccc3 	ldbu	r2,-31949(gp)
   41ae4:	e0bfff85 	stb	r2,-2(fp)
   41ae8:	0005883a 	mov	r2,zero
   41aec:	e0ffff03 	ldbu	r3,-4(fp)
   41af0:	18c03fcc 	andi	r3,r3,255
   41af4:	013fc004 	movi	r4,-256
   41af8:	1104703a 	and	r2,r2,r4
   41afc:	10c4b03a 	or	r2,r2,r3
   41b00:	e0ffff43 	ldbu	r3,-3(fp)
   41b04:	18c03fcc 	andi	r3,r3,255
   41b08:	1808923a 	slli	r4,r3,8
   41b0c:	00fffff4 	movhi	r3,65535
   41b10:	18c03fc4 	addi	r3,r3,255
   41b14:	10c4703a 	and	r2,r2,r3
   41b18:	1104b03a 	or	r2,r2,r4
   41b1c:	e0ffff83 	ldbu	r3,-2(fp)
   41b20:	18c03fcc 	andi	r3,r3,255
   41b24:	1808943a 	slli	r4,r3,16
   41b28:	00ffc074 	movhi	r3,65281
   41b2c:	18ffffc4 	addi	r3,r3,-1
   41b30:	10c4703a 	and	r2,r2,r3
   41b34:	1104b03a 	or	r2,r2,r4
}
   41b38:	e037883a 	mov	sp,fp
   41b3c:	df000017 	ldw	fp,0(sp)
   41b40:	dec00104 	addi	sp,sp,4
   41b44:	f800283a 	ret

00041b48 <downAlarmMinute>:

/*--------- down operations -------*/

// MINUTES
struct time downAlarmMinute(void) {
   41b48:	defffe04 	addi	sp,sp,-8
   41b4c:	df000115 	stw	fp,4(sp)
   41b50:	df000104 	addi	fp,sp,4
  if (alarm.minute == 0) {
   41b54:	d0a0cc83 	ldbu	r2,-31950(gp)
   41b58:	10803fcc 	andi	r2,r2,255
   41b5c:	1000031e 	bne	r2,zero,41b6c <downAlarmMinute+0x24>
    alarm.minute = (ONE_HOUR-1);
   41b60:	00800ec4 	movi	r2,59
   41b64:	d0a0cc85 	stb	r2,-31950(gp)
   41b68:	00000306 	br	41b78 <downAlarmMinute+0x30>
  }
  else {
    alarm.minute--;
   41b6c:	d0a0cc83 	ldbu	r2,-31950(gp)
   41b70:	10bfffc4 	addi	r2,r2,-1
   41b74:	d0a0cc85 	stb	r2,-31950(gp)
  }
  return alarm;
   41b78:	d0a0cc43 	ldbu	r2,-31951(gp)
   41b7c:	e0bfff05 	stb	r2,-4(fp)
   41b80:	d0a0cc83 	ldbu	r2,-31950(gp)
   41b84:	e0bfff45 	stb	r2,-3(fp)
   41b88:	d0a0ccc3 	ldbu	r2,-31949(gp)
   41b8c:	e0bfff85 	stb	r2,-2(fp)
   41b90:	0005883a 	mov	r2,zero
   41b94:	e0ffff03 	ldbu	r3,-4(fp)
   41b98:	18c03fcc 	andi	r3,r3,255
   41b9c:	013fc004 	movi	r4,-256
   41ba0:	1104703a 	and	r2,r2,r4
   41ba4:	10c4b03a 	or	r2,r2,r3
   41ba8:	e0ffff43 	ldbu	r3,-3(fp)
   41bac:	18c03fcc 	andi	r3,r3,255
   41bb0:	1808923a 	slli	r4,r3,8
   41bb4:	00fffff4 	movhi	r3,65535
   41bb8:	18c03fc4 	addi	r3,r3,255
   41bbc:	10c4703a 	and	r2,r2,r3
   41bc0:	1104b03a 	or	r2,r2,r4
   41bc4:	e0ffff83 	ldbu	r3,-2(fp)
   41bc8:	18c03fcc 	andi	r3,r3,255
   41bcc:	1808943a 	slli	r4,r3,16
   41bd0:	00ffc074 	movhi	r3,65281
   41bd4:	18ffffc4 	addi	r3,r3,-1
   41bd8:	10c4703a 	and	r2,r2,r3
   41bdc:	1104b03a 	or	r2,r2,r4
}
   41be0:	e037883a 	mov	sp,fp
   41be4:	df000017 	ldw	fp,0(sp)
   41be8:	dec00104 	addi	sp,sp,4
   41bec:	f800283a 	ret

00041bf0 <downAlarmHour>:

// HOURS
struct time downAlarmHour(void) {
   41bf0:	defffe04 	addi	sp,sp,-8
   41bf4:	df000115 	stw	fp,4(sp)
   41bf8:	df000104 	addi	fp,sp,4
  if (alarm.hour == 0) {
   41bfc:	d0a0cc43 	ldbu	r2,-31951(gp)
   41c00:	10803fcc 	andi	r2,r2,255
   41c04:	1000041e 	bne	r2,zero,41c18 <downAlarmHour+0x28>
    alarm.hour = (time_format-1);
   41c08:	d0a002c3 	ldbu	r2,-32757(gp)
   41c0c:	10bfffc4 	addi	r2,r2,-1
   41c10:	d0a0cc45 	stb	r2,-31951(gp)
   41c14:	00000306 	br	41c24 <downAlarmHour+0x34>
  }
  else {
    alarm.hour--;
   41c18:	d0a0cc43 	ldbu	r2,-31951(gp)
   41c1c:	10bfffc4 	addi	r2,r2,-1
   41c20:	d0a0cc45 	stb	r2,-31951(gp)
  }
  return alarm;
   41c24:	d0a0cc43 	ldbu	r2,-31951(gp)
   41c28:	e0bfff05 	stb	r2,-4(fp)
   41c2c:	d0a0cc83 	ldbu	r2,-31950(gp)
   41c30:	e0bfff45 	stb	r2,-3(fp)
   41c34:	d0a0ccc3 	ldbu	r2,-31949(gp)
   41c38:	e0bfff85 	stb	r2,-2(fp)
   41c3c:	0005883a 	mov	r2,zero
   41c40:	e0ffff03 	ldbu	r3,-4(fp)
   41c44:	18c03fcc 	andi	r3,r3,255
   41c48:	013fc004 	movi	r4,-256
   41c4c:	1104703a 	and	r2,r2,r4
   41c50:	10c4b03a 	or	r2,r2,r3
   41c54:	e0ffff43 	ldbu	r3,-3(fp)
   41c58:	18c03fcc 	andi	r3,r3,255
   41c5c:	1808923a 	slli	r4,r3,8
   41c60:	00fffff4 	movhi	r3,65535
   41c64:	18c03fc4 	addi	r3,r3,255
   41c68:	10c4703a 	and	r2,r2,r3
   41c6c:	1104b03a 	or	r2,r2,r4
   41c70:	e0ffff83 	ldbu	r3,-2(fp)
   41c74:	18c03fcc 	andi	r3,r3,255
   41c78:	1808943a 	slli	r4,r3,16
   41c7c:	00ffc074 	movhi	r3,65281
   41c80:	18ffffc4 	addi	r3,r3,-1
   41c84:	10c4703a 	and	r2,r2,r3
   41c88:	1104b03a 	or	r2,r2,r4
}
   41c8c:	e037883a 	mov	sp,fp
   41c90:	df000017 	ldw	fp,0(sp)
   41c94:	dec00104 	addi	sp,sp,4
   41c98:	f800283a 	ret

00041c9c <__divsi3>:
   41c9c:	20001b16 	blt	r4,zero,41d0c <__divsi3+0x70>
   41ca0:	000f883a 	mov	r7,zero
   41ca4:	28001616 	blt	r5,zero,41d00 <__divsi3+0x64>
   41ca8:	200d883a 	mov	r6,r4
   41cac:	29001a2e 	bgeu	r5,r4,41d18 <__divsi3+0x7c>
   41cb0:	00800804 	movi	r2,32
   41cb4:	00c00044 	movi	r3,1
   41cb8:	00000106 	br	41cc0 <__divsi3+0x24>
   41cbc:	10000d26 	beq	r2,zero,41cf4 <__divsi3+0x58>
   41cc0:	294b883a 	add	r5,r5,r5
   41cc4:	10bfffc4 	addi	r2,r2,-1
   41cc8:	18c7883a 	add	r3,r3,r3
   41ccc:	293ffb36 	bltu	r5,r4,41cbc <__alt_data_end+0xfffd9cbc>
   41cd0:	0005883a 	mov	r2,zero
   41cd4:	18000726 	beq	r3,zero,41cf4 <__divsi3+0x58>
   41cd8:	0005883a 	mov	r2,zero
   41cdc:	31400236 	bltu	r6,r5,41ce8 <__divsi3+0x4c>
   41ce0:	314dc83a 	sub	r6,r6,r5
   41ce4:	10c4b03a 	or	r2,r2,r3
   41ce8:	1806d07a 	srli	r3,r3,1
   41cec:	280ad07a 	srli	r5,r5,1
   41cf0:	183ffa1e 	bne	r3,zero,41cdc <__alt_data_end+0xfffd9cdc>
   41cf4:	38000126 	beq	r7,zero,41cfc <__divsi3+0x60>
   41cf8:	0085c83a 	sub	r2,zero,r2
   41cfc:	f800283a 	ret
   41d00:	014bc83a 	sub	r5,zero,r5
   41d04:	39c0005c 	xori	r7,r7,1
   41d08:	003fe706 	br	41ca8 <__alt_data_end+0xfffd9ca8>
   41d0c:	0109c83a 	sub	r4,zero,r4
   41d10:	01c00044 	movi	r7,1
   41d14:	003fe306 	br	41ca4 <__alt_data_end+0xfffd9ca4>
   41d18:	00c00044 	movi	r3,1
   41d1c:	003fee06 	br	41cd8 <__alt_data_end+0xfffd9cd8>

00041d20 <__modsi3>:
   41d20:	20001716 	blt	r4,zero,41d80 <__modsi3+0x60>
   41d24:	000f883a 	mov	r7,zero
   41d28:	2005883a 	mov	r2,r4
   41d2c:	28001216 	blt	r5,zero,41d78 <__modsi3+0x58>
   41d30:	2900162e 	bgeu	r5,r4,41d8c <__modsi3+0x6c>
   41d34:	01800804 	movi	r6,32
   41d38:	00c00044 	movi	r3,1
   41d3c:	00000106 	br	41d44 <__modsi3+0x24>
   41d40:	30000a26 	beq	r6,zero,41d6c <__modsi3+0x4c>
   41d44:	294b883a 	add	r5,r5,r5
   41d48:	31bfffc4 	addi	r6,r6,-1
   41d4c:	18c7883a 	add	r3,r3,r3
   41d50:	293ffb36 	bltu	r5,r4,41d40 <__alt_data_end+0xfffd9d40>
   41d54:	18000526 	beq	r3,zero,41d6c <__modsi3+0x4c>
   41d58:	1806d07a 	srli	r3,r3,1
   41d5c:	11400136 	bltu	r2,r5,41d64 <__modsi3+0x44>
   41d60:	1145c83a 	sub	r2,r2,r5
   41d64:	280ad07a 	srli	r5,r5,1
   41d68:	183ffb1e 	bne	r3,zero,41d58 <__alt_data_end+0xfffd9d58>
   41d6c:	38000126 	beq	r7,zero,41d74 <__modsi3+0x54>
   41d70:	0085c83a 	sub	r2,zero,r2
   41d74:	f800283a 	ret
   41d78:	014bc83a 	sub	r5,zero,r5
   41d7c:	003fec06 	br	41d30 <__alt_data_end+0xfffd9d30>
   41d80:	0109c83a 	sub	r4,zero,r4
   41d84:	01c00044 	movi	r7,1
   41d88:	003fe706 	br	41d28 <__alt_data_end+0xfffd9d28>
   41d8c:	00c00044 	movi	r3,1
   41d90:	003ff106 	br	41d58 <__alt_data_end+0xfffd9d58>

00041d94 <__udivsi3>:
   41d94:	200d883a 	mov	r6,r4
   41d98:	2900152e 	bgeu	r5,r4,41df0 <__udivsi3+0x5c>
   41d9c:	28001416 	blt	r5,zero,41df0 <__udivsi3+0x5c>
   41da0:	00800804 	movi	r2,32
   41da4:	00c00044 	movi	r3,1
   41da8:	00000206 	br	41db4 <__udivsi3+0x20>
   41dac:	10000e26 	beq	r2,zero,41de8 <__udivsi3+0x54>
   41db0:	28000516 	blt	r5,zero,41dc8 <__udivsi3+0x34>
   41db4:	294b883a 	add	r5,r5,r5
   41db8:	10bfffc4 	addi	r2,r2,-1
   41dbc:	18c7883a 	add	r3,r3,r3
   41dc0:	293ffa36 	bltu	r5,r4,41dac <__alt_data_end+0xfffd9dac>
   41dc4:	18000826 	beq	r3,zero,41de8 <__udivsi3+0x54>
   41dc8:	0005883a 	mov	r2,zero
   41dcc:	31400236 	bltu	r6,r5,41dd8 <__udivsi3+0x44>
   41dd0:	314dc83a 	sub	r6,r6,r5
   41dd4:	10c4b03a 	or	r2,r2,r3
   41dd8:	1806d07a 	srli	r3,r3,1
   41ddc:	280ad07a 	srli	r5,r5,1
   41de0:	183ffa1e 	bne	r3,zero,41dcc <__alt_data_end+0xfffd9dcc>
   41de4:	f800283a 	ret
   41de8:	0005883a 	mov	r2,zero
   41dec:	f800283a 	ret
   41df0:	00c00044 	movi	r3,1
   41df4:	003ff406 	br	41dc8 <__alt_data_end+0xfffd9dc8>

00041df8 <__umodsi3>:
   41df8:	2005883a 	mov	r2,r4
   41dfc:	2900122e 	bgeu	r5,r4,41e48 <__umodsi3+0x50>
   41e00:	28001116 	blt	r5,zero,41e48 <__umodsi3+0x50>
   41e04:	01800804 	movi	r6,32
   41e08:	00c00044 	movi	r3,1
   41e0c:	00000206 	br	41e18 <__umodsi3+0x20>
   41e10:	30000c26 	beq	r6,zero,41e44 <__umodsi3+0x4c>
   41e14:	28000516 	blt	r5,zero,41e2c <__umodsi3+0x34>
   41e18:	294b883a 	add	r5,r5,r5
   41e1c:	31bfffc4 	addi	r6,r6,-1
   41e20:	18c7883a 	add	r3,r3,r3
   41e24:	293ffa36 	bltu	r5,r4,41e10 <__alt_data_end+0xfffd9e10>
   41e28:	18000626 	beq	r3,zero,41e44 <__umodsi3+0x4c>
   41e2c:	1806d07a 	srli	r3,r3,1
   41e30:	11400136 	bltu	r2,r5,41e38 <__umodsi3+0x40>
   41e34:	1145c83a 	sub	r2,r2,r5
   41e38:	280ad07a 	srli	r5,r5,1
   41e3c:	183ffb1e 	bne	r3,zero,41e2c <__alt_data_end+0xfffd9e2c>
   41e40:	f800283a 	ret
   41e44:	f800283a 	ret
   41e48:	00c00044 	movi	r3,1
   41e4c:	003ff706 	br	41e2c <__alt_data_end+0xfffd9e2c>

00041e50 <_printf_r>:
   41e50:	defffd04 	addi	sp,sp,-12
   41e54:	dfc00015 	stw	ra,0(sp)
   41e58:	d9800115 	stw	r6,4(sp)
   41e5c:	d9c00215 	stw	r7,8(sp)
   41e60:	20c00217 	ldw	r3,8(r4)
   41e64:	01800134 	movhi	r6,4
   41e68:	31894d04 	addi	r6,r6,9524
   41e6c:	19800115 	stw	r6,4(r3)
   41e70:	280d883a 	mov	r6,r5
   41e74:	21400217 	ldw	r5,8(r4)
   41e78:	d9c00104 	addi	r7,sp,4
   41e7c:	0041ff40 	call	41ff4 <___vfprintf_internal_r>
   41e80:	dfc00017 	ldw	ra,0(sp)
   41e84:	dec00304 	addi	sp,sp,12
   41e88:	f800283a 	ret

00041e8c <printf>:
   41e8c:	defffc04 	addi	sp,sp,-16
   41e90:	dfc00015 	stw	ra,0(sp)
   41e94:	d9400115 	stw	r5,4(sp)
   41e98:	d9800215 	stw	r6,8(sp)
   41e9c:	d9c00315 	stw	r7,12(sp)
   41ea0:	00800134 	movhi	r2,4
   41ea4:	1090a104 	addi	r2,r2,17028
   41ea8:	10800017 	ldw	r2,0(r2)
   41eac:	01400134 	movhi	r5,4
   41eb0:	29494d04 	addi	r5,r5,9524
   41eb4:	10c00217 	ldw	r3,8(r2)
   41eb8:	d9800104 	addi	r6,sp,4
   41ebc:	19400115 	stw	r5,4(r3)
   41ec0:	200b883a 	mov	r5,r4
   41ec4:	11000217 	ldw	r4,8(r2)
   41ec8:	00425180 	call	42518 <__vfprintf_internal>
   41ecc:	dfc00017 	ldw	ra,0(sp)
   41ed0:	dec00404 	addi	sp,sp,16
   41ed4:	f800283a 	ret

00041ed8 <_puts_r>:
   41ed8:	defffd04 	addi	sp,sp,-12
   41edc:	dc000015 	stw	r16,0(sp)
   41ee0:	2021883a 	mov	r16,r4
   41ee4:	2809883a 	mov	r4,r5
   41ee8:	dfc00215 	stw	ra,8(sp)
   41eec:	dc400115 	stw	r17,4(sp)
   41ef0:	2823883a 	mov	r17,r5
   41ef4:	0041f6c0 	call	41f6c <strlen>
   41ef8:	81400217 	ldw	r5,8(r16)
   41efc:	01000134 	movhi	r4,4
   41f00:	21094d04 	addi	r4,r4,9524
   41f04:	29000115 	stw	r4,4(r5)
   41f08:	100f883a 	mov	r7,r2
   41f0c:	880d883a 	mov	r6,r17
   41f10:	8009883a 	mov	r4,r16
   41f14:	00425340 	call	42534 <__sfvwrite_small_dev>
   41f18:	00ffffc4 	movi	r3,-1
   41f1c:	10c00926 	beq	r2,r3,41f44 <_puts_r+0x6c>
   41f20:	81400217 	ldw	r5,8(r16)
   41f24:	01800134 	movhi	r6,4
   41f28:	01c00044 	movi	r7,1
   41f2c:	28800117 	ldw	r2,4(r5)
   41f30:	318fe204 	addi	r6,r6,16264
   41f34:	8009883a 	mov	r4,r16
   41f38:	103ee83a 	callr	r2
   41f3c:	10bfffe0 	cmpeqi	r2,r2,-1
   41f40:	0085c83a 	sub	r2,zero,r2
   41f44:	dfc00217 	ldw	ra,8(sp)
   41f48:	dc400117 	ldw	r17,4(sp)
   41f4c:	dc000017 	ldw	r16,0(sp)
   41f50:	dec00304 	addi	sp,sp,12
   41f54:	f800283a 	ret

00041f58 <puts>:
   41f58:	00800134 	movhi	r2,4
   41f5c:	1090a104 	addi	r2,r2,17028
   41f60:	200b883a 	mov	r5,r4
   41f64:	11000017 	ldw	r4,0(r2)
   41f68:	0041ed81 	jmpi	41ed8 <_puts_r>

00041f6c <strlen>:
   41f6c:	2005883a 	mov	r2,r4
   41f70:	10c00007 	ldb	r3,0(r2)
   41f74:	18000226 	beq	r3,zero,41f80 <strlen+0x14>
   41f78:	10800044 	addi	r2,r2,1
   41f7c:	003ffc06 	br	41f70 <__alt_data_end+0xfffd9f70>
   41f80:	1105c83a 	sub	r2,r2,r4
   41f84:	f800283a 	ret

00041f88 <print_repeat>:
   41f88:	defffb04 	addi	sp,sp,-20
   41f8c:	dc800315 	stw	r18,12(sp)
   41f90:	dc400215 	stw	r17,8(sp)
   41f94:	dc000115 	stw	r16,4(sp)
   41f98:	dfc00415 	stw	ra,16(sp)
   41f9c:	2025883a 	mov	r18,r4
   41fa0:	2823883a 	mov	r17,r5
   41fa4:	d9800005 	stb	r6,0(sp)
   41fa8:	3821883a 	mov	r16,r7
   41fac:	04000a0e 	bge	zero,r16,41fd8 <print_repeat+0x50>
   41fb0:	88800117 	ldw	r2,4(r17)
   41fb4:	01c00044 	movi	r7,1
   41fb8:	d80d883a 	mov	r6,sp
   41fbc:	880b883a 	mov	r5,r17
   41fc0:	9009883a 	mov	r4,r18
   41fc4:	103ee83a 	callr	r2
   41fc8:	843fffc4 	addi	r16,r16,-1
   41fcc:	103ff726 	beq	r2,zero,41fac <__alt_data_end+0xfffd9fac>
   41fd0:	00bfffc4 	movi	r2,-1
   41fd4:	00000106 	br	41fdc <print_repeat+0x54>
   41fd8:	0005883a 	mov	r2,zero
   41fdc:	dfc00417 	ldw	ra,16(sp)
   41fe0:	dc800317 	ldw	r18,12(sp)
   41fe4:	dc400217 	ldw	r17,8(sp)
   41fe8:	dc000117 	ldw	r16,4(sp)
   41fec:	dec00504 	addi	sp,sp,20
   41ff0:	f800283a 	ret

00041ff4 <___vfprintf_internal_r>:
   41ff4:	deffe504 	addi	sp,sp,-108
   41ff8:	d8c00804 	addi	r3,sp,32
   41ffc:	df001915 	stw	fp,100(sp)
   42000:	ddc01815 	stw	r23,96(sp)
   42004:	dd801715 	stw	r22,92(sp)
   42008:	dd401615 	stw	r21,88(sp)
   4200c:	dd001515 	stw	r20,84(sp)
   42010:	dcc01415 	stw	r19,80(sp)
   42014:	dc801315 	stw	r18,76(sp)
   42018:	dc401215 	stw	r17,72(sp)
   4201c:	dc001115 	stw	r16,68(sp)
   42020:	dfc01a15 	stw	ra,104(sp)
   42024:	2027883a 	mov	r19,r4
   42028:	2839883a 	mov	fp,r5
   4202c:	382d883a 	mov	r22,r7
   42030:	d9800f15 	stw	r6,60(sp)
   42034:	0021883a 	mov	r16,zero
   42038:	d8000e15 	stw	zero,56(sp)
   4203c:	002f883a 	mov	r23,zero
   42040:	002b883a 	mov	r21,zero
   42044:	0025883a 	mov	r18,zero
   42048:	0023883a 	mov	r17,zero
   4204c:	d8000c15 	stw	zero,48(sp)
   42050:	d8000b15 	stw	zero,44(sp)
   42054:	0029883a 	mov	r20,zero
   42058:	d8c00915 	stw	r3,36(sp)
   4205c:	d8c00f17 	ldw	r3,60(sp)
   42060:	19000003 	ldbu	r4,0(r3)
   42064:	20803fcc 	andi	r2,r4,255
   42068:	1080201c 	xori	r2,r2,128
   4206c:	10bfe004 	addi	r2,r2,-128
   42070:	10011c26 	beq	r2,zero,424e4 <___vfprintf_internal_r+0x4f0>
   42074:	00c00044 	movi	r3,1
   42078:	a0c01426 	beq	r20,r3,420cc <___vfprintf_internal_r+0xd8>
   4207c:	1d000216 	blt	r3,r20,42088 <___vfprintf_internal_r+0x94>
   42080:	a0000626 	beq	r20,zero,4209c <___vfprintf_internal_r+0xa8>
   42084:	00011306 	br	424d4 <___vfprintf_internal_r+0x4e0>
   42088:	01400084 	movi	r5,2
   4208c:	a1401d26 	beq	r20,r5,42104 <___vfprintf_internal_r+0x110>
   42090:	014000c4 	movi	r5,3
   42094:	a1402926 	beq	r20,r5,4213c <___vfprintf_internal_r+0x148>
   42098:	00010e06 	br	424d4 <___vfprintf_internal_r+0x4e0>
   4209c:	01400944 	movi	r5,37
   420a0:	1140fb26 	beq	r2,r5,42490 <___vfprintf_internal_r+0x49c>
   420a4:	e0800117 	ldw	r2,4(fp)
   420a8:	d9000005 	stb	r4,0(sp)
   420ac:	01c00044 	movi	r7,1
   420b0:	d80d883a 	mov	r6,sp
   420b4:	e00b883a 	mov	r5,fp
   420b8:	9809883a 	mov	r4,r19
   420bc:	103ee83a 	callr	r2
   420c0:	1000d61e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   420c4:	84000044 	addi	r16,r16,1
   420c8:	00010206 	br	424d4 <___vfprintf_internal_r+0x4e0>
   420cc:	01400c04 	movi	r5,48
   420d0:	1140f826 	beq	r2,r5,424b4 <___vfprintf_internal_r+0x4c0>
   420d4:	01400944 	movi	r5,37
   420d8:	11400a1e 	bne	r2,r5,42104 <___vfprintf_internal_r+0x110>
   420dc:	d8800005 	stb	r2,0(sp)
   420e0:	e0800117 	ldw	r2,4(fp)
   420e4:	a00f883a 	mov	r7,r20
   420e8:	d80d883a 	mov	r6,sp
   420ec:	e00b883a 	mov	r5,fp
   420f0:	9809883a 	mov	r4,r19
   420f4:	103ee83a 	callr	r2
   420f8:	1000c81e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   420fc:	84000044 	addi	r16,r16,1
   42100:	0000f306 	br	424d0 <___vfprintf_internal_r+0x4dc>
   42104:	217ff404 	addi	r5,r4,-48
   42108:	29403fcc 	andi	r5,r5,255
   4210c:	00c00244 	movi	r3,9
   42110:	19400736 	bltu	r3,r5,42130 <___vfprintf_internal_r+0x13c>
   42114:	00bfffc4 	movi	r2,-1
   42118:	88800226 	beq	r17,r2,42124 <___vfprintf_internal_r+0x130>
   4211c:	8c4002a4 	muli	r17,r17,10
   42120:	00000106 	br	42128 <___vfprintf_internal_r+0x134>
   42124:	0023883a 	mov	r17,zero
   42128:	2c63883a 	add	r17,r5,r17
   4212c:	0000e206 	br	424b8 <___vfprintf_internal_r+0x4c4>
   42130:	01400b84 	movi	r5,46
   42134:	1140e426 	beq	r2,r5,424c8 <___vfprintf_internal_r+0x4d4>
   42138:	05000084 	movi	r20,2
   4213c:	213ff404 	addi	r4,r4,-48
   42140:	21003fcc 	andi	r4,r4,255
   42144:	00c00244 	movi	r3,9
   42148:	19000736 	bltu	r3,r4,42168 <___vfprintf_internal_r+0x174>
   4214c:	00bfffc4 	movi	r2,-1
   42150:	90800226 	beq	r18,r2,4215c <___vfprintf_internal_r+0x168>
   42154:	948002a4 	muli	r18,r18,10
   42158:	00000106 	br	42160 <___vfprintf_internal_r+0x16c>
   4215c:	0025883a 	mov	r18,zero
   42160:	24a5883a 	add	r18,r4,r18
   42164:	0000db06 	br	424d4 <___vfprintf_internal_r+0x4e0>
   42168:	00c01b04 	movi	r3,108
   4216c:	10c0d426 	beq	r2,r3,424c0 <___vfprintf_internal_r+0x4cc>
   42170:	013fffc4 	movi	r4,-1
   42174:	91000226 	beq	r18,r4,42180 <___vfprintf_internal_r+0x18c>
   42178:	d8000b15 	stw	zero,44(sp)
   4217c:	00000106 	br	42184 <___vfprintf_internal_r+0x190>
   42180:	04800044 	movi	r18,1
   42184:	01001a44 	movi	r4,105
   42188:	11001626 	beq	r2,r4,421e4 <___vfprintf_internal_r+0x1f0>
   4218c:	20800916 	blt	r4,r2,421b4 <___vfprintf_internal_r+0x1c0>
   42190:	010018c4 	movi	r4,99
   42194:	11008a26 	beq	r2,r4,423c0 <___vfprintf_internal_r+0x3cc>
   42198:	01001904 	movi	r4,100
   4219c:	11001126 	beq	r2,r4,421e4 <___vfprintf_internal_r+0x1f0>
   421a0:	01001604 	movi	r4,88
   421a4:	1100ca1e 	bne	r2,r4,424d0 <___vfprintf_internal_r+0x4dc>
   421a8:	00c00044 	movi	r3,1
   421ac:	d8c00e15 	stw	r3,56(sp)
   421b0:	00001406 	br	42204 <___vfprintf_internal_r+0x210>
   421b4:	01001cc4 	movi	r4,115
   421b8:	11009a26 	beq	r2,r4,42424 <___vfprintf_internal_r+0x430>
   421bc:	20800416 	blt	r4,r2,421d0 <___vfprintf_internal_r+0x1dc>
   421c0:	01001bc4 	movi	r4,111
   421c4:	1100c21e 	bne	r2,r4,424d0 <___vfprintf_internal_r+0x4dc>
   421c8:	05400204 	movi	r21,8
   421cc:	00000e06 	br	42208 <___vfprintf_internal_r+0x214>
   421d0:	01001d44 	movi	r4,117
   421d4:	11000c26 	beq	r2,r4,42208 <___vfprintf_internal_r+0x214>
   421d8:	01001e04 	movi	r4,120
   421dc:	11000926 	beq	r2,r4,42204 <___vfprintf_internal_r+0x210>
   421e0:	0000bb06 	br	424d0 <___vfprintf_internal_r+0x4dc>
   421e4:	b5000104 	addi	r20,r22,4
   421e8:	b8000726 	beq	r23,zero,42208 <___vfprintf_internal_r+0x214>
   421ec:	dd000d15 	stw	r20,52(sp)
   421f0:	b5800017 	ldw	r22,0(r22)
   421f4:	b000080e 	bge	r22,zero,42218 <___vfprintf_internal_r+0x224>
   421f8:	05adc83a 	sub	r22,zero,r22
   421fc:	02800044 	movi	r10,1
   42200:	00000606 	br	4221c <___vfprintf_internal_r+0x228>
   42204:	05400404 	movi	r21,16
   42208:	b0c00104 	addi	r3,r22,4
   4220c:	d8c00d15 	stw	r3,52(sp)
   42210:	b5800017 	ldw	r22,0(r22)
   42214:	002f883a 	mov	r23,zero
   42218:	0015883a 	mov	r10,zero
   4221c:	d829883a 	mov	r20,sp
   42220:	b0001426 	beq	r22,zero,42274 <___vfprintf_internal_r+0x280>
   42224:	b009883a 	mov	r4,r22
   42228:	a80b883a 	mov	r5,r21
   4222c:	da801015 	stw	r10,64(sp)
   42230:	0041d940 	call	41d94 <__udivsi3>
   42234:	1549383a 	mul	r4,r2,r21
   42238:	00c00244 	movi	r3,9
   4223c:	da801017 	ldw	r10,64(sp)
   42240:	b12dc83a 	sub	r22,r22,r4
   42244:	1d800216 	blt	r3,r22,42250 <___vfprintf_internal_r+0x25c>
   42248:	b5800c04 	addi	r22,r22,48
   4224c:	00000506 	br	42264 <___vfprintf_internal_r+0x270>
   42250:	d8c00e17 	ldw	r3,56(sp)
   42254:	18000226 	beq	r3,zero,42260 <___vfprintf_internal_r+0x26c>
   42258:	b5800dc4 	addi	r22,r22,55
   4225c:	00000106 	br	42264 <___vfprintf_internal_r+0x270>
   42260:	b58015c4 	addi	r22,r22,87
   42264:	a5800005 	stb	r22,0(r20)
   42268:	a5000044 	addi	r20,r20,1
   4226c:	102d883a 	mov	r22,r2
   42270:	003feb06 	br	42220 <__alt_data_end+0xfffda220>
   42274:	a6c7c83a 	sub	r3,r20,sp
   42278:	d8c00a15 	stw	r3,40(sp)
   4227c:	90c5c83a 	sub	r2,r18,r3
   42280:	00800a0e 	bge	zero,r2,422ac <___vfprintf_internal_r+0x2b8>
   42284:	a085883a 	add	r2,r20,r2
   42288:	01400c04 	movi	r5,48
   4228c:	d8c00917 	ldw	r3,36(sp)
   42290:	a009883a 	mov	r4,r20
   42294:	a0c0032e 	bgeu	r20,r3,422a4 <___vfprintf_internal_r+0x2b0>
   42298:	a5000044 	addi	r20,r20,1
   4229c:	21400005 	stb	r5,0(r4)
   422a0:	a0bffa1e 	bne	r20,r2,4228c <__alt_data_end+0xfffda28c>
   422a4:	a6c7c83a 	sub	r3,r20,sp
   422a8:	d8c00a15 	stw	r3,40(sp)
   422ac:	d8c00a17 	ldw	r3,40(sp)
   422b0:	50d3883a 	add	r9,r10,r3
   422b4:	d8c00b17 	ldw	r3,44(sp)
   422b8:	8a6dc83a 	sub	r22,r17,r9
   422bc:	18001726 	beq	r3,zero,4231c <___vfprintf_internal_r+0x328>
   422c0:	50000a26 	beq	r10,zero,422ec <___vfprintf_internal_r+0x2f8>
   422c4:	00800b44 	movi	r2,45
   422c8:	d8800805 	stb	r2,32(sp)
   422cc:	e0800117 	ldw	r2,4(fp)
   422d0:	01c00044 	movi	r7,1
   422d4:	d9800804 	addi	r6,sp,32
   422d8:	e00b883a 	mov	r5,fp
   422dc:	9809883a 	mov	r4,r19
   422e0:	103ee83a 	callr	r2
   422e4:	10004d1e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   422e8:	84000044 	addi	r16,r16,1
   422ec:	0580070e 	bge	zero,r22,4230c <___vfprintf_internal_r+0x318>
   422f0:	b00f883a 	mov	r7,r22
   422f4:	01800c04 	movi	r6,48
   422f8:	e00b883a 	mov	r5,fp
   422fc:	9809883a 	mov	r4,r19
   42300:	0041f880 	call	41f88 <print_repeat>
   42304:	1000451e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   42308:	85a1883a 	add	r16,r16,r22
   4230c:	d8c00a17 	ldw	r3,40(sp)
   42310:	a013883a 	mov	r9,r20
   42314:	1d2dc83a 	sub	r22,r3,r20
   42318:	00002206 	br	423a4 <___vfprintf_internal_r+0x3b0>
   4231c:	0580090e 	bge	zero,r22,42344 <___vfprintf_internal_r+0x350>
   42320:	b00f883a 	mov	r7,r22
   42324:	01800804 	movi	r6,32
   42328:	e00b883a 	mov	r5,fp
   4232c:	9809883a 	mov	r4,r19
   42330:	da801015 	stw	r10,64(sp)
   42334:	0041f880 	call	41f88 <print_repeat>
   42338:	da801017 	ldw	r10,64(sp)
   4233c:	1000371e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   42340:	85a1883a 	add	r16,r16,r22
   42344:	503ff126 	beq	r10,zero,4230c <__alt_data_end+0xfffda30c>
   42348:	00800b44 	movi	r2,45
   4234c:	d8800805 	stb	r2,32(sp)
   42350:	e0800117 	ldw	r2,4(fp)
   42354:	01c00044 	movi	r7,1
   42358:	d9800804 	addi	r6,sp,32
   4235c:	e00b883a 	mov	r5,fp
   42360:	9809883a 	mov	r4,r19
   42364:	103ee83a 	callr	r2
   42368:	10002c1e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   4236c:	84000044 	addi	r16,r16,1
   42370:	003fe606 	br	4230c <__alt_data_end+0xfffda30c>
   42374:	4a7fffc4 	addi	r9,r9,-1
   42378:	48800003 	ldbu	r2,0(r9)
   4237c:	01c00044 	movi	r7,1
   42380:	d9800804 	addi	r6,sp,32
   42384:	d8800805 	stb	r2,32(sp)
   42388:	e0800117 	ldw	r2,4(fp)
   4238c:	e00b883a 	mov	r5,fp
   42390:	da401015 	stw	r9,64(sp)
   42394:	9809883a 	mov	r4,r19
   42398:	103ee83a 	callr	r2
   4239c:	da401017 	ldw	r9,64(sp)
   423a0:	10001e1e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   423a4:	8245c83a 	sub	r2,r16,r9
   423a8:	4d89883a 	add	r4,r9,r22
   423ac:	a085883a 	add	r2,r20,r2
   423b0:	013ff016 	blt	zero,r4,42374 <__alt_data_end+0xfffda374>
   423b4:	1021883a 	mov	r16,r2
   423b8:	dd800d17 	ldw	r22,52(sp)
   423bc:	00004406 	br	424d0 <___vfprintf_internal_r+0x4dc>
   423c0:	00800044 	movi	r2,1
   423c4:	1440080e 	bge	r2,r17,423e8 <___vfprintf_internal_r+0x3f4>
   423c8:	8d3fffc4 	addi	r20,r17,-1
   423cc:	a00f883a 	mov	r7,r20
   423d0:	01800804 	movi	r6,32
   423d4:	e00b883a 	mov	r5,fp
   423d8:	9809883a 	mov	r4,r19
   423dc:	0041f880 	call	41f88 <print_repeat>
   423e0:	10000e1e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   423e4:	8521883a 	add	r16,r16,r20
   423e8:	b0800017 	ldw	r2,0(r22)
   423ec:	01c00044 	movi	r7,1
   423f0:	d80d883a 	mov	r6,sp
   423f4:	d8800005 	stb	r2,0(sp)
   423f8:	e0800117 	ldw	r2,4(fp)
   423fc:	e00b883a 	mov	r5,fp
   42400:	9809883a 	mov	r4,r19
   42404:	b5000104 	addi	r20,r22,4
   42408:	103ee83a 	callr	r2
   4240c:	1000031e 	bne	r2,zero,4241c <___vfprintf_internal_r+0x428>
   42410:	84000044 	addi	r16,r16,1
   42414:	a02d883a 	mov	r22,r20
   42418:	00002d06 	br	424d0 <___vfprintf_internal_r+0x4dc>
   4241c:	00bfffc4 	movi	r2,-1
   42420:	00003106 	br	424e8 <___vfprintf_internal_r+0x4f4>
   42424:	b5000017 	ldw	r20,0(r22)
   42428:	b0c00104 	addi	r3,r22,4
   4242c:	d8c00a15 	stw	r3,40(sp)
   42430:	a009883a 	mov	r4,r20
   42434:	0041f6c0 	call	41f6c <strlen>
   42438:	8893c83a 	sub	r9,r17,r2
   4243c:	102d883a 	mov	r22,r2
   42440:	0240090e 	bge	zero,r9,42468 <___vfprintf_internal_r+0x474>
   42444:	480f883a 	mov	r7,r9
   42448:	01800804 	movi	r6,32
   4244c:	e00b883a 	mov	r5,fp
   42450:	9809883a 	mov	r4,r19
   42454:	da401015 	stw	r9,64(sp)
   42458:	0041f880 	call	41f88 <print_repeat>
   4245c:	da401017 	ldw	r9,64(sp)
   42460:	103fee1e 	bne	r2,zero,4241c <__alt_data_end+0xfffda41c>
   42464:	8261883a 	add	r16,r16,r9
   42468:	e0800117 	ldw	r2,4(fp)
   4246c:	b00f883a 	mov	r7,r22
   42470:	a00d883a 	mov	r6,r20
   42474:	e00b883a 	mov	r5,fp
   42478:	9809883a 	mov	r4,r19
   4247c:	103ee83a 	callr	r2
   42480:	103fe61e 	bne	r2,zero,4241c <__alt_data_end+0xfffda41c>
   42484:	85a1883a 	add	r16,r16,r22
   42488:	dd800a17 	ldw	r22,40(sp)
   4248c:	00001006 	br	424d0 <___vfprintf_internal_r+0x4dc>
   42490:	05c00044 	movi	r23,1
   42494:	04bfffc4 	movi	r18,-1
   42498:	d8000e15 	stw	zero,56(sp)
   4249c:	05400284 	movi	r21,10
   424a0:	9023883a 	mov	r17,r18
   424a4:	d8000c15 	stw	zero,48(sp)
   424a8:	d8000b15 	stw	zero,44(sp)
   424ac:	b829883a 	mov	r20,r23
   424b0:	00000806 	br	424d4 <___vfprintf_internal_r+0x4e0>
   424b4:	dd000b15 	stw	r20,44(sp)
   424b8:	05000084 	movi	r20,2
   424bc:	00000506 	br	424d4 <___vfprintf_internal_r+0x4e0>
   424c0:	00c00044 	movi	r3,1
   424c4:	d8c00c15 	stw	r3,48(sp)
   424c8:	050000c4 	movi	r20,3
   424cc:	00000106 	br	424d4 <___vfprintf_internal_r+0x4e0>
   424d0:	0029883a 	mov	r20,zero
   424d4:	d8c00f17 	ldw	r3,60(sp)
   424d8:	18c00044 	addi	r3,r3,1
   424dc:	d8c00f15 	stw	r3,60(sp)
   424e0:	003ede06 	br	4205c <__alt_data_end+0xfffda05c>
   424e4:	8005883a 	mov	r2,r16
   424e8:	dfc01a17 	ldw	ra,104(sp)
   424ec:	df001917 	ldw	fp,100(sp)
   424f0:	ddc01817 	ldw	r23,96(sp)
   424f4:	dd801717 	ldw	r22,92(sp)
   424f8:	dd401617 	ldw	r21,88(sp)
   424fc:	dd001517 	ldw	r20,84(sp)
   42500:	dcc01417 	ldw	r19,80(sp)
   42504:	dc801317 	ldw	r18,76(sp)
   42508:	dc401217 	ldw	r17,72(sp)
   4250c:	dc001117 	ldw	r16,68(sp)
   42510:	dec01b04 	addi	sp,sp,108
   42514:	f800283a 	ret

00042518 <__vfprintf_internal>:
   42518:	00800134 	movhi	r2,4
   4251c:	1090a104 	addi	r2,r2,17028
   42520:	300f883a 	mov	r7,r6
   42524:	280d883a 	mov	r6,r5
   42528:	200b883a 	mov	r5,r4
   4252c:	11000017 	ldw	r4,0(r2)
   42530:	0041ff41 	jmpi	41ff4 <___vfprintf_internal_r>

00042534 <__sfvwrite_small_dev>:
   42534:	2880000b 	ldhu	r2,0(r5)
   42538:	1080020c 	andi	r2,r2,8
   4253c:	10002126 	beq	r2,zero,425c4 <__sfvwrite_small_dev+0x90>
   42540:	2880008f 	ldh	r2,2(r5)
   42544:	defffa04 	addi	sp,sp,-24
   42548:	dc000015 	stw	r16,0(sp)
   4254c:	dfc00515 	stw	ra,20(sp)
   42550:	dd000415 	stw	r20,16(sp)
   42554:	dcc00315 	stw	r19,12(sp)
   42558:	dc800215 	stw	r18,8(sp)
   4255c:	dc400115 	stw	r17,4(sp)
   42560:	2821883a 	mov	r16,r5
   42564:	10001216 	blt	r2,zero,425b0 <__sfvwrite_small_dev+0x7c>
   42568:	2027883a 	mov	r19,r4
   4256c:	3025883a 	mov	r18,r6
   42570:	3823883a 	mov	r17,r7
   42574:	05010004 	movi	r20,1024
   42578:	04400b0e 	bge	zero,r17,425a8 <__sfvwrite_small_dev+0x74>
   4257c:	880f883a 	mov	r7,r17
   42580:	a440010e 	bge	r20,r17,42588 <__sfvwrite_small_dev+0x54>
   42584:	01c10004 	movi	r7,1024
   42588:	8140008f 	ldh	r5,2(r16)
   4258c:	900d883a 	mov	r6,r18
   42590:	9809883a 	mov	r4,r19
   42594:	00425ec0 	call	425ec <_write_r>
   42598:	0080050e 	bge	zero,r2,425b0 <__sfvwrite_small_dev+0x7c>
   4259c:	88a3c83a 	sub	r17,r17,r2
   425a0:	90a5883a 	add	r18,r18,r2
   425a4:	003ff406 	br	42578 <__alt_data_end+0xfffda578>
   425a8:	0005883a 	mov	r2,zero
   425ac:	00000706 	br	425cc <__sfvwrite_small_dev+0x98>
   425b0:	8080000b 	ldhu	r2,0(r16)
   425b4:	10801014 	ori	r2,r2,64
   425b8:	8080000d 	sth	r2,0(r16)
   425bc:	00bfffc4 	movi	r2,-1
   425c0:	00000206 	br	425cc <__sfvwrite_small_dev+0x98>
   425c4:	00bfffc4 	movi	r2,-1
   425c8:	f800283a 	ret
   425cc:	dfc00517 	ldw	ra,20(sp)
   425d0:	dd000417 	ldw	r20,16(sp)
   425d4:	dcc00317 	ldw	r19,12(sp)
   425d8:	dc800217 	ldw	r18,8(sp)
   425dc:	dc400117 	ldw	r17,4(sp)
   425e0:	dc000017 	ldw	r16,0(sp)
   425e4:	dec00604 	addi	sp,sp,24
   425e8:	f800283a 	ret

000425ec <_write_r>:
   425ec:	defffd04 	addi	sp,sp,-12
   425f0:	dc000015 	stw	r16,0(sp)
   425f4:	04000134 	movhi	r16,4
   425f8:	dc400115 	stw	r17,4(sp)
   425fc:	84116b04 	addi	r16,r16,17836
   42600:	2023883a 	mov	r17,r4
   42604:	2809883a 	mov	r4,r5
   42608:	300b883a 	mov	r5,r6
   4260c:	380d883a 	mov	r6,r7
   42610:	dfc00215 	stw	ra,8(sp)
   42614:	80000015 	stw	zero,0(r16)
   42618:	0042a780 	call	42a78 <write>
   4261c:	00ffffc4 	movi	r3,-1
   42620:	10c0031e 	bne	r2,r3,42630 <_write_r+0x44>
   42624:	80c00017 	ldw	r3,0(r16)
   42628:	18000126 	beq	r3,zero,42630 <_write_r+0x44>
   4262c:	88c00015 	stw	r3,0(r17)
   42630:	dfc00217 	ldw	ra,8(sp)
   42634:	dc400117 	ldw	r17,4(sp)
   42638:	dc000017 	ldw	r16,0(sp)
   4263c:	dec00304 	addi	sp,sp,12
   42640:	f800283a 	ret

00042644 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   42644:	defff904 	addi	sp,sp,-28
   42648:	dfc00615 	stw	ra,24(sp)
   4264c:	df000515 	stw	fp,20(sp)
   42650:	df000504 	addi	fp,sp,20
   42654:	e13ffc15 	stw	r4,-16(fp)
   42658:	e17ffd15 	stw	r5,-12(fp)
   4265c:	e1bffe15 	stw	r6,-8(fp)
   42660:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   42664:	e0800217 	ldw	r2,8(fp)
   42668:	d8800015 	stw	r2,0(sp)
   4266c:	e1ffff17 	ldw	r7,-4(fp)
   42670:	e1bffe17 	ldw	r6,-8(fp)
   42674:	e17ffd17 	ldw	r5,-12(fp)
   42678:	e13ffc17 	ldw	r4,-16(fp)
   4267c:	00427f40 	call	427f4 <alt_iic_isr_register>
}  
   42680:	e037883a 	mov	sp,fp
   42684:	dfc00117 	ldw	ra,4(sp)
   42688:	df000017 	ldw	fp,0(sp)
   4268c:	dec00204 	addi	sp,sp,8
   42690:	f800283a 	ret

00042694 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
   42694:	defff904 	addi	sp,sp,-28
   42698:	df000615 	stw	fp,24(sp)
   4269c:	df000604 	addi	fp,sp,24
   426a0:	e13ffe15 	stw	r4,-8(fp)
   426a4:	e17fff15 	stw	r5,-4(fp)
   426a8:	e0bfff17 	ldw	r2,-4(fp)
   426ac:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   426b0:	0005303a 	rdctl	r2,status
   426b4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   426b8:	e0fffb17 	ldw	r3,-20(fp)
   426bc:	00bfff84 	movi	r2,-2
   426c0:	1884703a 	and	r2,r3,r2
   426c4:	1001703a 	wrctl	status,r2
  
  return context;
   426c8:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   426cc:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
   426d0:	00c00044 	movi	r3,1
   426d4:	e0bffa17 	ldw	r2,-24(fp)
   426d8:	1884983a 	sll	r2,r3,r2
   426dc:	1007883a 	mov	r3,r2
   426e0:	d0a0cf17 	ldw	r2,-31940(gp)
   426e4:	1884b03a 	or	r2,r3,r2
   426e8:	d0a0cf15 	stw	r2,-31940(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   426ec:	d0a0cf17 	ldw	r2,-31940(gp)
   426f0:	100170fa 	wrctl	ienable,r2
   426f4:	e0bffc17 	ldw	r2,-16(fp)
   426f8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   426fc:	e0bffd17 	ldw	r2,-12(fp)
   42700:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   42704:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
   42708:	0001883a 	nop
}
   4270c:	e037883a 	mov	sp,fp
   42710:	df000017 	ldw	fp,0(sp)
   42714:	dec00104 	addi	sp,sp,4
   42718:	f800283a 	ret

0004271c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
   4271c:	defff904 	addi	sp,sp,-28
   42720:	df000615 	stw	fp,24(sp)
   42724:	df000604 	addi	fp,sp,24
   42728:	e13ffe15 	stw	r4,-8(fp)
   4272c:	e17fff15 	stw	r5,-4(fp)
   42730:	e0bfff17 	ldw	r2,-4(fp)
   42734:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   42738:	0005303a 	rdctl	r2,status
   4273c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   42740:	e0fffb17 	ldw	r3,-20(fp)
   42744:	00bfff84 	movi	r2,-2
   42748:	1884703a 	and	r2,r3,r2
   4274c:	1001703a 	wrctl	status,r2
  
  return context;
   42750:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   42754:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
   42758:	00c00044 	movi	r3,1
   4275c:	e0bffa17 	ldw	r2,-24(fp)
   42760:	1884983a 	sll	r2,r3,r2
   42764:	0084303a 	nor	r2,zero,r2
   42768:	1007883a 	mov	r3,r2
   4276c:	d0a0cf17 	ldw	r2,-31940(gp)
   42770:	1884703a 	and	r2,r3,r2
   42774:	d0a0cf15 	stw	r2,-31940(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   42778:	d0a0cf17 	ldw	r2,-31940(gp)
   4277c:	100170fa 	wrctl	ienable,r2
   42780:	e0bffc17 	ldw	r2,-16(fp)
   42784:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   42788:	e0bffd17 	ldw	r2,-12(fp)
   4278c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   42790:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
   42794:	0001883a 	nop
}
   42798:	e037883a 	mov	sp,fp
   4279c:	df000017 	ldw	fp,0(sp)
   427a0:	dec00104 	addi	sp,sp,4
   427a4:	f800283a 	ret

000427a8 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
   427a8:	defffc04 	addi	sp,sp,-16
   427ac:	df000315 	stw	fp,12(sp)
   427b0:	df000304 	addi	fp,sp,12
   427b4:	e13ffe15 	stw	r4,-8(fp)
   427b8:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   427bc:	000530fa 	rdctl	r2,ienable
   427c0:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
   427c4:	00c00044 	movi	r3,1
   427c8:	e0bfff17 	ldw	r2,-4(fp)
   427cc:	1884983a 	sll	r2,r3,r2
   427d0:	1007883a 	mov	r3,r2
   427d4:	e0bffd17 	ldw	r2,-12(fp)
   427d8:	1884703a 	and	r2,r3,r2
   427dc:	1004c03a 	cmpne	r2,r2,zero
   427e0:	10803fcc 	andi	r2,r2,255
}
   427e4:	e037883a 	mov	sp,fp
   427e8:	df000017 	ldw	fp,0(sp)
   427ec:	dec00104 	addi	sp,sp,4
   427f0:	f800283a 	ret

000427f4 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   427f4:	defff504 	addi	sp,sp,-44
   427f8:	dfc00a15 	stw	ra,40(sp)
   427fc:	df000915 	stw	fp,36(sp)
   42800:	df000904 	addi	fp,sp,36
   42804:	e13ffc15 	stw	r4,-16(fp)
   42808:	e17ffd15 	stw	r5,-12(fp)
   4280c:	e1bffe15 	stw	r6,-8(fp)
   42810:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
   42814:	00bffa84 	movi	r2,-22
   42818:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
   4281c:	e0bffd17 	ldw	r2,-12(fp)
   42820:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   42824:	e0bff817 	ldw	r2,-32(fp)
   42828:	10800808 	cmpgei	r2,r2,32
   4282c:	1000271e 	bne	r2,zero,428cc <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   42830:	0005303a 	rdctl	r2,status
   42834:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   42838:	e0fffb17 	ldw	r3,-20(fp)
   4283c:	00bfff84 	movi	r2,-2
   42840:	1884703a 	and	r2,r3,r2
   42844:	1001703a 	wrctl	status,r2
  
  return context;
   42848:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
   4284c:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
   42850:	00800134 	movhi	r2,4
   42854:	10917304 	addi	r2,r2,17868
   42858:	e0fff817 	ldw	r3,-32(fp)
   4285c:	180690fa 	slli	r3,r3,3
   42860:	10c5883a 	add	r2,r2,r3
   42864:	e0fffe17 	ldw	r3,-8(fp)
   42868:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
   4286c:	00800134 	movhi	r2,4
   42870:	10917304 	addi	r2,r2,17868
   42874:	e0fff817 	ldw	r3,-32(fp)
   42878:	180690fa 	slli	r3,r3,3
   4287c:	10c5883a 	add	r2,r2,r3
   42880:	10800104 	addi	r2,r2,4
   42884:	e0ffff17 	ldw	r3,-4(fp)
   42888:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   4288c:	e0bffe17 	ldw	r2,-8(fp)
   42890:	10000526 	beq	r2,zero,428a8 <alt_iic_isr_register+0xb4>
   42894:	e0bff817 	ldw	r2,-32(fp)
   42898:	100b883a 	mov	r5,r2
   4289c:	e13ffc17 	ldw	r4,-16(fp)
   428a0:	00426940 	call	42694 <alt_ic_irq_enable>
   428a4:	00000406 	br	428b8 <alt_iic_isr_register+0xc4>
   428a8:	e0bff817 	ldw	r2,-32(fp)
   428ac:	100b883a 	mov	r5,r2
   428b0:	e13ffc17 	ldw	r4,-16(fp)
   428b4:	004271c0 	call	4271c <alt_ic_irq_disable>
   428b8:	e0bff715 	stw	r2,-36(fp)
   428bc:	e0bffa17 	ldw	r2,-24(fp)
   428c0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   428c4:	e0bff917 	ldw	r2,-28(fp)
   428c8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
   428cc:	e0bff717 	ldw	r2,-36(fp)
}
   428d0:	e037883a 	mov	sp,fp
   428d4:	dfc00117 	ldw	ra,4(sp)
   428d8:	df000017 	ldw	fp,0(sp)
   428dc:	dec00204 	addi	sp,sp,8
   428e0:	f800283a 	ret

000428e4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   428e4:	defffc04 	addi	sp,sp,-16
   428e8:	df000315 	stw	fp,12(sp)
   428ec:	df000304 	addi	fp,sp,12
   428f0:	e13ffd15 	stw	r4,-12(fp)
   428f4:	e17ffe15 	stw	r5,-8(fp)
   428f8:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   428fc:	e0fffe17 	ldw	r3,-8(fp)
   42900:	e0bffd17 	ldw	r2,-12(fp)
   42904:	18800c26 	beq	r3,r2,42938 <alt_load_section+0x54>
  {
    while( to != end )
   42908:	00000806 	br	4292c <alt_load_section+0x48>
    {
      *to++ = *from++;
   4290c:	e0bffe17 	ldw	r2,-8(fp)
   42910:	10c00104 	addi	r3,r2,4
   42914:	e0fffe15 	stw	r3,-8(fp)
   42918:	e0fffd17 	ldw	r3,-12(fp)
   4291c:	19000104 	addi	r4,r3,4
   42920:	e13ffd15 	stw	r4,-12(fp)
   42924:	18c00017 	ldw	r3,0(r3)
   42928:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   4292c:	e0fffe17 	ldw	r3,-8(fp)
   42930:	e0bfff17 	ldw	r2,-4(fp)
   42934:	18bff51e 	bne	r3,r2,4290c <__alt_data_end+0xfffda90c>
    {
      *to++ = *from++;
    }
  }
}
   42938:	0001883a 	nop
   4293c:	e037883a 	mov	sp,fp
   42940:	df000017 	ldw	fp,0(sp)
   42944:	dec00104 	addi	sp,sp,4
   42948:	f800283a 	ret

0004294c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   4294c:	defffe04 	addi	sp,sp,-8
   42950:	dfc00115 	stw	ra,4(sp)
   42954:	df000015 	stw	fp,0(sp)
   42958:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   4295c:	01800134 	movhi	r6,4
   42960:	3190ab04 	addi	r6,r6,17068
   42964:	01400134 	movhi	r5,4
   42968:	294ff004 	addi	r5,r5,16320
   4296c:	01000134 	movhi	r4,4
   42970:	2110ab04 	addi	r4,r4,17068
   42974:	00428e40 	call	428e4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   42978:	01800134 	movhi	r6,4
   4297c:	31809104 	addi	r6,r6,580
   42980:	01400134 	movhi	r5,4
   42984:	29400804 	addi	r5,r5,32
   42988:	01000134 	movhi	r4,4
   4298c:	21000804 	addi	r4,r4,32
   42990:	00428e40 	call	428e4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   42994:	01800134 	movhi	r6,4
   42998:	318ff004 	addi	r6,r6,16320
   4299c:	01400134 	movhi	r5,4
   429a0:	294f4204 	addi	r5,r5,15624
   429a4:	01000134 	movhi	r4,4
   429a8:	210f4204 	addi	r4,r4,15624
   429ac:	00428e40 	call	428e4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   429b0:	004306c0 	call	4306c <alt_dcache_flush_all>
  alt_icache_flush_all();
   429b4:	00431980 	call	43198 <alt_icache_flush_all>
}
   429b8:	0001883a 	nop
   429bc:	e037883a 	mov	sp,fp
   429c0:	dfc00117 	ldw	ra,4(sp)
   429c4:	df000017 	ldw	fp,0(sp)
   429c8:	dec00204 	addi	sp,sp,8
   429cc:	f800283a 	ret

000429d0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   429d0:	defffd04 	addi	sp,sp,-12
   429d4:	dfc00215 	stw	ra,8(sp)
   429d8:	df000115 	stw	fp,4(sp)
   429dc:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   429e0:	0009883a 	mov	r4,zero
   429e4:	0042ba40 	call	42ba4 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   429e8:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   429ec:	0042bdc0 	call	42bdc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   429f0:	01800134 	movhi	r6,4
   429f4:	318fe304 	addi	r6,r6,16268
   429f8:	01400134 	movhi	r5,4
   429fc:	294fe304 	addi	r5,r5,16268
   42a00:	01000134 	movhi	r4,4
   42a04:	210fe304 	addi	r4,r4,16268
   42a08:	004332c0 	call	4332c <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   42a0c:	d0a0d017 	ldw	r2,-31936(gp)
   42a10:	d0e0d117 	ldw	r3,-31932(gp)
   42a14:	d120d217 	ldw	r4,-31928(gp)
   42a18:	200d883a 	mov	r6,r4
   42a1c:	180b883a 	mov	r5,r3
   42a20:	1009883a 	mov	r4,r2
   42a24:	00407700 	call	40770 <main>
   42a28:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   42a2c:	01000044 	movi	r4,1
   42a30:	0042f9c0 	call	42f9c <close>
  exit (result);
   42a34:	e13fff17 	ldw	r4,-4(fp)
   42a38:	0043af40 	call	43af4 <exit>

00042a3c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   42a3c:	defffe04 	addi	sp,sp,-8
   42a40:	dfc00115 	stw	ra,4(sp)
   42a44:	df000015 	stw	fp,0(sp)
   42a48:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   42a4c:	d0a00b17 	ldw	r2,-32724(gp)
   42a50:	10000326 	beq	r2,zero,42a60 <alt_get_errno+0x24>
   42a54:	d0a00b17 	ldw	r2,-32724(gp)
   42a58:	103ee83a 	callr	r2
   42a5c:	00000106 	br	42a64 <alt_get_errno+0x28>
   42a60:	d0a0ce04 	addi	r2,gp,-31944
}
   42a64:	e037883a 	mov	sp,fp
   42a68:	dfc00117 	ldw	ra,4(sp)
   42a6c:	df000017 	ldw	fp,0(sp)
   42a70:	dec00204 	addi	sp,sp,8
   42a74:	f800283a 	ret

00042a78 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   42a78:	defff904 	addi	sp,sp,-28
   42a7c:	dfc00615 	stw	ra,24(sp)
   42a80:	df000515 	stw	fp,20(sp)
   42a84:	df000504 	addi	fp,sp,20
   42a88:	e13ffd15 	stw	r4,-12(fp)
   42a8c:	e17ffe15 	stw	r5,-8(fp)
   42a90:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   42a94:	e0bffd17 	ldw	r2,-12(fp)
   42a98:	10000616 	blt	r2,zero,42ab4 <write+0x3c>
   42a9c:	e0bffd17 	ldw	r2,-12(fp)
   42aa0:	10c00324 	muli	r3,r2,12
   42aa4:	00800134 	movhi	r2,4
   42aa8:	10903d04 	addi	r2,r2,16628
   42aac:	1885883a 	add	r2,r3,r2
   42ab0:	00000106 	br	42ab8 <write+0x40>
   42ab4:	0005883a 	mov	r2,zero
   42ab8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   42abc:	e0bffb17 	ldw	r2,-20(fp)
   42ac0:	10002126 	beq	r2,zero,42b48 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   42ac4:	e0bffb17 	ldw	r2,-20(fp)
   42ac8:	10800217 	ldw	r2,8(r2)
   42acc:	108000cc 	andi	r2,r2,3
   42ad0:	10001826 	beq	r2,zero,42b34 <write+0xbc>
   42ad4:	e0bffb17 	ldw	r2,-20(fp)
   42ad8:	10800017 	ldw	r2,0(r2)
   42adc:	10800617 	ldw	r2,24(r2)
   42ae0:	10001426 	beq	r2,zero,42b34 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   42ae4:	e0bffb17 	ldw	r2,-20(fp)
   42ae8:	10800017 	ldw	r2,0(r2)
   42aec:	10800617 	ldw	r2,24(r2)
   42af0:	e0ffff17 	ldw	r3,-4(fp)
   42af4:	180d883a 	mov	r6,r3
   42af8:	e17ffe17 	ldw	r5,-8(fp)
   42afc:	e13ffb17 	ldw	r4,-20(fp)
   42b00:	103ee83a 	callr	r2
   42b04:	e0bffc15 	stw	r2,-16(fp)
   42b08:	e0bffc17 	ldw	r2,-16(fp)
   42b0c:	1000070e 	bge	r2,zero,42b2c <write+0xb4>
      {
        ALT_ERRNO = -rval;
   42b10:	0042a3c0 	call	42a3c <alt_get_errno>
   42b14:	1007883a 	mov	r3,r2
   42b18:	e0bffc17 	ldw	r2,-16(fp)
   42b1c:	0085c83a 	sub	r2,zero,r2
   42b20:	18800015 	stw	r2,0(r3)
        return -1;
   42b24:	00bfffc4 	movi	r2,-1
   42b28:	00000c06 	br	42b5c <write+0xe4>
      }
      return rval;
   42b2c:	e0bffc17 	ldw	r2,-16(fp)
   42b30:	00000a06 	br	42b5c <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
   42b34:	0042a3c0 	call	42a3c <alt_get_errno>
   42b38:	1007883a 	mov	r3,r2
   42b3c:	00800344 	movi	r2,13
   42b40:	18800015 	stw	r2,0(r3)
   42b44:	00000406 	br	42b58 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   42b48:	0042a3c0 	call	42a3c <alt_get_errno>
   42b4c:	1007883a 	mov	r3,r2
   42b50:	00801444 	movi	r2,81
   42b54:	18800015 	stw	r2,0(r3)
  }
  return -1;
   42b58:	00bfffc4 	movi	r2,-1
}
   42b5c:	e037883a 	mov	sp,fp
   42b60:	dfc00117 	ldw	ra,4(sp)
   42b64:	df000017 	ldw	fp,0(sp)
   42b68:	dec00204 	addi	sp,sp,8
   42b6c:	f800283a 	ret

00042b70 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   42b70:	defffd04 	addi	sp,sp,-12
   42b74:	dfc00215 	stw	ra,8(sp)
   42b78:	df000115 	stw	fp,4(sp)
   42b7c:	df000104 	addi	fp,sp,4
   42b80:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   42b84:	d1600804 	addi	r5,gp,-32736
   42b88:	e13fff17 	ldw	r4,-4(fp)
   42b8c:	00430f40 	call	430f4 <alt_dev_llist_insert>
}
   42b90:	e037883a 	mov	sp,fp
   42b94:	dfc00117 	ldw	ra,4(sp)
   42b98:	df000017 	ldw	fp,0(sp)
   42b9c:	dec00204 	addi	sp,sp,8
   42ba0:	f800283a 	ret

00042ba4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   42ba4:	defffd04 	addi	sp,sp,-12
   42ba8:	dfc00215 	stw	ra,8(sp)
   42bac:	df000115 	stw	fp,4(sp)
   42bb0:	df000104 	addi	fp,sp,4
   42bb4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOSII_CPU, NiosII_CPU);
   42bb8:	00438040 	call	43804 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   42bbc:	00800044 	movi	r2,1
   42bc0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   42bc4:	0001883a 	nop
   42bc8:	e037883a 	mov	sp,fp
   42bcc:	dfc00117 	ldw	ra,4(sp)
   42bd0:	df000017 	ldw	fp,0(sp)
   42bd4:	dec00204 	addi	sp,sp,8
   42bd8:	f800283a 	ret

00042bdc <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   42bdc:	defffe04 	addi	sp,sp,-8
   42be0:	dfc00115 	stw	ra,4(sp)
   42be4:	df000015 	stw	fp,0(sp)
   42be8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, SYS_CLK_timer);
   42bec:	01c0fa04 	movi	r7,1000
   42bf0:	000d883a 	mov	r6,zero
   42bf4:	000b883a 	mov	r5,zero
   42bf8:	01000234 	movhi	r4,8
   42bfc:	21040804 	addi	r4,r4,4128
   42c00:	0042ee40 	call	42ee4 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_SECOND, timer_second);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
   42c04:	01000134 	movhi	r4,4
   42c08:	21102804 	addi	r4,r4,16544
   42c0c:	0042b700 	call	42b70 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
   42c10:	0001883a 	nop
}
   42c14:	0001883a 	nop
   42c18:	e037883a 	mov	sp,fp
   42c1c:	dfc00117 	ldw	ra,4(sp)
   42c20:	df000017 	ldw	fp,0(sp)
   42c24:	dec00204 	addi	sp,sp,8
   42c28:	f800283a 	ret

00042c2c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   42c2c:	defffa04 	addi	sp,sp,-24
   42c30:	dfc00515 	stw	ra,20(sp)
   42c34:	df000415 	stw	fp,16(sp)
   42c38:	df000404 	addi	fp,sp,16
   42c3c:	e13ffd15 	stw	r4,-12(fp)
   42c40:	e17ffe15 	stw	r5,-8(fp)
   42c44:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   42c48:	e0bffd17 	ldw	r2,-12(fp)
   42c4c:	10800017 	ldw	r2,0(r2)
   42c50:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   42c54:	e0bffc17 	ldw	r2,-16(fp)
   42c58:	10c00a04 	addi	r3,r2,40
   42c5c:	e0bffd17 	ldw	r2,-12(fp)
   42c60:	10800217 	ldw	r2,8(r2)
   42c64:	100f883a 	mov	r7,r2
   42c68:	e1bfff17 	ldw	r6,-4(fp)
   42c6c:	e17ffe17 	ldw	r5,-8(fp)
   42c70:	1809883a 	mov	r4,r3
   42c74:	0042cec0 	call	42cec <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   42c78:	e037883a 	mov	sp,fp
   42c7c:	dfc00117 	ldw	ra,4(sp)
   42c80:	df000017 	ldw	fp,0(sp)
   42c84:	dec00204 	addi	sp,sp,8
   42c88:	f800283a 	ret

00042c8c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   42c8c:	defffa04 	addi	sp,sp,-24
   42c90:	dfc00515 	stw	ra,20(sp)
   42c94:	df000415 	stw	fp,16(sp)
   42c98:	df000404 	addi	fp,sp,16
   42c9c:	e13ffd15 	stw	r4,-12(fp)
   42ca0:	e17ffe15 	stw	r5,-8(fp)
   42ca4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   42ca8:	e0bffd17 	ldw	r2,-12(fp)
   42cac:	10800017 	ldw	r2,0(r2)
   42cb0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   42cb4:	e0bffc17 	ldw	r2,-16(fp)
   42cb8:	10c00a04 	addi	r3,r2,40
   42cbc:	e0bffd17 	ldw	r2,-12(fp)
   42cc0:	10800217 	ldw	r2,8(r2)
   42cc4:	100f883a 	mov	r7,r2
   42cc8:	e1bfff17 	ldw	r6,-4(fp)
   42ccc:	e17ffe17 	ldw	r5,-8(fp)
   42cd0:	1809883a 	mov	r4,r3
   42cd4:	0042dd80 	call	42dd8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   42cd8:	e037883a 	mov	sp,fp
   42cdc:	dfc00117 	ldw	ra,4(sp)
   42ce0:	df000017 	ldw	fp,0(sp)
   42ce4:	dec00204 	addi	sp,sp,8
   42ce8:	f800283a 	ret

00042cec <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
   42cec:	defff704 	addi	sp,sp,-36
   42cf0:	df000815 	stw	fp,32(sp)
   42cf4:	df000804 	addi	fp,sp,32
   42cf8:	e13ffc15 	stw	r4,-16(fp)
   42cfc:	e17ffd15 	stw	r5,-12(fp)
   42d00:	e1bffe15 	stw	r6,-8(fp)
   42d04:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   42d08:	e0bffc17 	ldw	r2,-16(fp)
   42d0c:	10800017 	ldw	r2,0(r2)
   42d10:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
   42d14:	e0bffd17 	ldw	r2,-12(fp)
   42d18:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
   42d1c:	e0bffe17 	ldw	r2,-8(fp)
   42d20:	e0fffd17 	ldw	r3,-12(fp)
   42d24:	1885883a 	add	r2,r3,r2
   42d28:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
   42d2c:	00001206 	br	42d78 <altera_avalon_jtag_uart_read+0x8c>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   42d30:	e0bff917 	ldw	r2,-28(fp)
   42d34:	10800037 	ldwio	r2,0(r2)
   42d38:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
   42d3c:	e0bffb17 	ldw	r2,-20(fp)
   42d40:	10a0000c 	andi	r2,r2,32768
   42d44:	10000626 	beq	r2,zero,42d60 <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   42d48:	e0bff817 	ldw	r2,-32(fp)
   42d4c:	10c00044 	addi	r3,r2,1
   42d50:	e0fff815 	stw	r3,-32(fp)
   42d54:	e0fffb17 	ldw	r3,-20(fp)
   42d58:	10c00005 	stb	r3,0(r2)
   42d5c:	00000606 	br	42d78 <altera_avalon_jtag_uart_read+0x8c>
    else if (ptr != buffer)
   42d60:	e0fff817 	ldw	r3,-32(fp)
   42d64:	e0bffd17 	ldw	r2,-12(fp)
   42d68:	1880071e 	bne	r3,r2,42d88 <altera_avalon_jtag_uart_read+0x9c>
      break;
    else if(flags & O_NONBLOCK)
   42d6c:	e0bfff17 	ldw	r2,-4(fp)
   42d70:	1090000c 	andi	r2,r2,16384
   42d74:	1000061e 	bne	r2,zero,42d90 <altera_avalon_jtag_uart_read+0xa4>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
   42d78:	e0fff817 	ldw	r3,-32(fp)
   42d7c:	e0bffa17 	ldw	r2,-24(fp)
   42d80:	18bfeb36 	bltu	r3,r2,42d30 <__alt_data_end+0xfffdad30>
   42d84:	00000306 	br	42d94 <altera_avalon_jtag_uart_read+0xa8>
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
   42d88:	0001883a 	nop
   42d8c:	00000106 	br	42d94 <altera_avalon_jtag_uart_read+0xa8>
    else if(flags & O_NONBLOCK)
      break;   
   42d90:	0001883a 	nop
    
  }

  if (ptr != buffer)
   42d94:	e0fff817 	ldw	r3,-32(fp)
   42d98:	e0bffd17 	ldw	r2,-12(fp)
   42d9c:	18800426 	beq	r3,r2,42db0 <altera_avalon_jtag_uart_read+0xc4>
    return ptr - buffer;
   42da0:	e0fff817 	ldw	r3,-32(fp)
   42da4:	e0bffd17 	ldw	r2,-12(fp)
   42da8:	1885c83a 	sub	r2,r3,r2
   42dac:	00000606 	br	42dc8 <altera_avalon_jtag_uart_read+0xdc>
  else if (flags & O_NONBLOCK)
   42db0:	e0bfff17 	ldw	r2,-4(fp)
   42db4:	1090000c 	andi	r2,r2,16384
   42db8:	10000226 	beq	r2,zero,42dc4 <altera_avalon_jtag_uart_read+0xd8>
    return -EWOULDBLOCK;
   42dbc:	00bffd44 	movi	r2,-11
   42dc0:	00000106 	br	42dc8 <altera_avalon_jtag_uart_read+0xdc>
  else
    return -EIO;
   42dc4:	00bffec4 	movi	r2,-5
}
   42dc8:	e037883a 	mov	sp,fp
   42dcc:	df000017 	ldw	fp,0(sp)
   42dd0:	dec00104 	addi	sp,sp,4
   42dd4:	f800283a 	ret

00042dd8 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   42dd8:	defff904 	addi	sp,sp,-28
   42ddc:	df000615 	stw	fp,24(sp)
   42de0:	df000604 	addi	fp,sp,24
   42de4:	e13ffc15 	stw	r4,-16(fp)
   42de8:	e17ffd15 	stw	r5,-12(fp)
   42dec:	e1bffe15 	stw	r6,-8(fp)
   42df0:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   42df4:	e0bffc17 	ldw	r2,-16(fp)
   42df8:	10800017 	ldw	r2,0(r2)
   42dfc:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
   42e00:	e0bffe17 	ldw	r2,-8(fp)
   42e04:	e0fffd17 	ldw	r3,-12(fp)
   42e08:	1885883a 	add	r2,r3,r2
   42e0c:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
   42e10:	00000e06 	br	42e4c <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   42e14:	e0bffa17 	ldw	r2,-24(fp)
   42e18:	10800104 	addi	r2,r2,4
   42e1c:	10800037 	ldwio	r2,0(r2)
   42e20:	10bfffec 	andhi	r2,r2,65535
   42e24:	10000926 	beq	r2,zero,42e4c <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   42e28:	e0fffa17 	ldw	r3,-24(fp)
   42e2c:	e0bffd17 	ldw	r2,-12(fp)
   42e30:	11000044 	addi	r4,r2,1
   42e34:	e13ffd15 	stw	r4,-12(fp)
   42e38:	10800003 	ldbu	r2,0(r2)
   42e3c:	10803fcc 	andi	r2,r2,255
   42e40:	1080201c 	xori	r2,r2,128
   42e44:	10bfe004 	addi	r2,r2,-128
   42e48:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   42e4c:	e0fffd17 	ldw	r3,-12(fp)
   42e50:	e0bffb17 	ldw	r2,-20(fp)
   42e54:	18bfef36 	bltu	r3,r2,42e14 <__alt_data_end+0xfffdae14>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
   42e58:	e0bffe17 	ldw	r2,-8(fp)
}
   42e5c:	e037883a 	mov	sp,fp
   42e60:	df000017 	ldw	fp,0(sp)
   42e64:	dec00104 	addi	sp,sp,4
   42e68:	f800283a 	ret

00042e6c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   42e6c:	defffa04 	addi	sp,sp,-24
   42e70:	dfc00515 	stw	ra,20(sp)
   42e74:	df000415 	stw	fp,16(sp)
   42e78:	df000404 	addi	fp,sp,16
   42e7c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   42e80:	0007883a 	mov	r3,zero
   42e84:	e0bfff17 	ldw	r2,-4(fp)
   42e88:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   42e8c:	e0bfff17 	ldw	r2,-4(fp)
   42e90:	10800104 	addi	r2,r2,4
   42e94:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   42e98:	0005303a 	rdctl	r2,status
   42e9c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   42ea0:	e0fffd17 	ldw	r3,-12(fp)
   42ea4:	00bfff84 	movi	r2,-2
   42ea8:	1884703a 	and	r2,r3,r2
   42eac:	1001703a 	wrctl	status,r2
  
  return context;
   42eb0:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   42eb4:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
   42eb8:	00436fc0 	call	436fc <alt_tick>
   42ebc:	e0bffc17 	ldw	r2,-16(fp)
   42ec0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   42ec4:	e0bffe17 	ldw	r2,-8(fp)
   42ec8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   42ecc:	0001883a 	nop
   42ed0:	e037883a 	mov	sp,fp
   42ed4:	dfc00117 	ldw	ra,4(sp)
   42ed8:	df000017 	ldw	fp,0(sp)
   42edc:	dec00204 	addi	sp,sp,8
   42ee0:	f800283a 	ret

00042ee4 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   42ee4:	defff804 	addi	sp,sp,-32
   42ee8:	dfc00715 	stw	ra,28(sp)
   42eec:	df000615 	stw	fp,24(sp)
   42ef0:	df000604 	addi	fp,sp,24
   42ef4:	e13ffc15 	stw	r4,-16(fp)
   42ef8:	e17ffd15 	stw	r5,-12(fp)
   42efc:	e1bffe15 	stw	r6,-8(fp)
   42f00:	e1ffff15 	stw	r7,-4(fp)
   42f04:	e0bfff17 	ldw	r2,-4(fp)
   42f08:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   42f0c:	d0a0d417 	ldw	r2,-31920(gp)
   42f10:	1000021e 	bne	r2,zero,42f1c <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
   42f14:	e0bffb17 	ldw	r2,-20(fp)
   42f18:	d0a0d415 	stw	r2,-31920(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   42f1c:	e0bffc17 	ldw	r2,-16(fp)
   42f20:	10800104 	addi	r2,r2,4
   42f24:	00c001c4 	movi	r3,7
   42f28:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
   42f2c:	d8000015 	stw	zero,0(sp)
   42f30:	e1fffc17 	ldw	r7,-16(fp)
   42f34:	01800134 	movhi	r6,4
   42f38:	318b9b04 	addi	r6,r6,11884
   42f3c:	e17ffe17 	ldw	r5,-8(fp)
   42f40:	e13ffd17 	ldw	r4,-12(fp)
   42f44:	00426440 	call	42644 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
   42f48:	0001883a 	nop
   42f4c:	e037883a 	mov	sp,fp
   42f50:	dfc00117 	ldw	ra,4(sp)
   42f54:	df000017 	ldw	fp,0(sp)
   42f58:	dec00204 	addi	sp,sp,8
   42f5c:	f800283a 	ret

00042f60 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   42f60:	defffe04 	addi	sp,sp,-8
   42f64:	dfc00115 	stw	ra,4(sp)
   42f68:	df000015 	stw	fp,0(sp)
   42f6c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   42f70:	d0a00b17 	ldw	r2,-32724(gp)
   42f74:	10000326 	beq	r2,zero,42f84 <alt_get_errno+0x24>
   42f78:	d0a00b17 	ldw	r2,-32724(gp)
   42f7c:	103ee83a 	callr	r2
   42f80:	00000106 	br	42f88 <alt_get_errno+0x28>
   42f84:	d0a0ce04 	addi	r2,gp,-31944
}
   42f88:	e037883a 	mov	sp,fp
   42f8c:	dfc00117 	ldw	ra,4(sp)
   42f90:	df000017 	ldw	fp,0(sp)
   42f94:	dec00204 	addi	sp,sp,8
   42f98:	f800283a 	ret

00042f9c <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   42f9c:	defffb04 	addi	sp,sp,-20
   42fa0:	dfc00415 	stw	ra,16(sp)
   42fa4:	df000315 	stw	fp,12(sp)
   42fa8:	df000304 	addi	fp,sp,12
   42fac:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   42fb0:	e0bfff17 	ldw	r2,-4(fp)
   42fb4:	10000616 	blt	r2,zero,42fd0 <close+0x34>
   42fb8:	e0bfff17 	ldw	r2,-4(fp)
   42fbc:	10c00324 	muli	r3,r2,12
   42fc0:	00800134 	movhi	r2,4
   42fc4:	10903d04 	addi	r2,r2,16628
   42fc8:	1885883a 	add	r2,r3,r2
   42fcc:	00000106 	br	42fd4 <close+0x38>
   42fd0:	0005883a 	mov	r2,zero
   42fd4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   42fd8:	e0bffd17 	ldw	r2,-12(fp)
   42fdc:	10001926 	beq	r2,zero,43044 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   42fe0:	e0bffd17 	ldw	r2,-12(fp)
   42fe4:	10800017 	ldw	r2,0(r2)
   42fe8:	10800417 	ldw	r2,16(r2)
   42fec:	10000626 	beq	r2,zero,43008 <close+0x6c>
   42ff0:	e0bffd17 	ldw	r2,-12(fp)
   42ff4:	10800017 	ldw	r2,0(r2)
   42ff8:	10800417 	ldw	r2,16(r2)
   42ffc:	e13ffd17 	ldw	r4,-12(fp)
   43000:	103ee83a 	callr	r2
   43004:	00000106 	br	4300c <close+0x70>
   43008:	0005883a 	mov	r2,zero
   4300c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   43010:	e13fff17 	ldw	r4,-4(fp)
   43014:	00435fc0 	call	435fc <alt_release_fd>
    if (rval < 0)
   43018:	e0bffe17 	ldw	r2,-8(fp)
   4301c:	1000070e 	bge	r2,zero,4303c <close+0xa0>
    {
      ALT_ERRNO = -rval;
   43020:	0042f600 	call	42f60 <alt_get_errno>
   43024:	1007883a 	mov	r3,r2
   43028:	e0bffe17 	ldw	r2,-8(fp)
   4302c:	0085c83a 	sub	r2,zero,r2
   43030:	18800015 	stw	r2,0(r3)
      return -1;
   43034:	00bfffc4 	movi	r2,-1
   43038:	00000706 	br	43058 <close+0xbc>
    }
    return 0;
   4303c:	0005883a 	mov	r2,zero
   43040:	00000506 	br	43058 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   43044:	0042f600 	call	42f60 <alt_get_errno>
   43048:	1007883a 	mov	r3,r2
   4304c:	00801444 	movi	r2,81
   43050:	18800015 	stw	r2,0(r3)
    return -1;
   43054:	00bfffc4 	movi	r2,-1
  }
}
   43058:	e037883a 	mov	sp,fp
   4305c:	dfc00117 	ldw	ra,4(sp)
   43060:	df000017 	ldw	fp,0(sp)
   43064:	dec00204 	addi	sp,sp,8
   43068:	f800283a 	ret

0004306c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   4306c:	deffff04 	addi	sp,sp,-4
   43070:	df000015 	stw	fp,0(sp)
   43074:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   43078:	0001883a 	nop
   4307c:	e037883a 	mov	sp,fp
   43080:	df000017 	ldw	fp,0(sp)
   43084:	dec00104 	addi	sp,sp,4
   43088:	f800283a 	ret

0004308c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   4308c:	defffc04 	addi	sp,sp,-16
   43090:	df000315 	stw	fp,12(sp)
   43094:	df000304 	addi	fp,sp,12
   43098:	e13ffd15 	stw	r4,-12(fp)
   4309c:	e17ffe15 	stw	r5,-8(fp)
   430a0:	e1bfff15 	stw	r6,-4(fp)
  return len;
   430a4:	e0bfff17 	ldw	r2,-4(fp)
}
   430a8:	e037883a 	mov	sp,fp
   430ac:	df000017 	ldw	fp,0(sp)
   430b0:	dec00104 	addi	sp,sp,4
   430b4:	f800283a 	ret

000430b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   430b8:	defffe04 	addi	sp,sp,-8
   430bc:	dfc00115 	stw	ra,4(sp)
   430c0:	df000015 	stw	fp,0(sp)
   430c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   430c8:	d0a00b17 	ldw	r2,-32724(gp)
   430cc:	10000326 	beq	r2,zero,430dc <alt_get_errno+0x24>
   430d0:	d0a00b17 	ldw	r2,-32724(gp)
   430d4:	103ee83a 	callr	r2
   430d8:	00000106 	br	430e0 <alt_get_errno+0x28>
   430dc:	d0a0ce04 	addi	r2,gp,-31944
}
   430e0:	e037883a 	mov	sp,fp
   430e4:	dfc00117 	ldw	ra,4(sp)
   430e8:	df000017 	ldw	fp,0(sp)
   430ec:	dec00204 	addi	sp,sp,8
   430f0:	f800283a 	ret

000430f4 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   430f4:	defffa04 	addi	sp,sp,-24
   430f8:	dfc00515 	stw	ra,20(sp)
   430fc:	df000415 	stw	fp,16(sp)
   43100:	df000404 	addi	fp,sp,16
   43104:	e13ffe15 	stw	r4,-8(fp)
   43108:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   4310c:	e0bffe17 	ldw	r2,-8(fp)
   43110:	10000326 	beq	r2,zero,43120 <alt_dev_llist_insert+0x2c>
   43114:	e0bffe17 	ldw	r2,-8(fp)
   43118:	10800217 	ldw	r2,8(r2)
   4311c:	1000061e 	bne	r2,zero,43138 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
   43120:	00430b80 	call	430b8 <alt_get_errno>
   43124:	1007883a 	mov	r3,r2
   43128:	00800584 	movi	r2,22
   4312c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   43130:	00bffa84 	movi	r2,-22
   43134:	00001306 	br	43184 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   43138:	e0bffe17 	ldw	r2,-8(fp)
   4313c:	e0ffff17 	ldw	r3,-4(fp)
   43140:	e0fffc15 	stw	r3,-16(fp)
   43144:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   43148:	e0bffd17 	ldw	r2,-12(fp)
   4314c:	e0fffc17 	ldw	r3,-16(fp)
   43150:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   43154:	e0bffc17 	ldw	r2,-16(fp)
   43158:	10c00017 	ldw	r3,0(r2)
   4315c:	e0bffd17 	ldw	r2,-12(fp)
   43160:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   43164:	e0bffc17 	ldw	r2,-16(fp)
   43168:	10800017 	ldw	r2,0(r2)
   4316c:	e0fffd17 	ldw	r3,-12(fp)
   43170:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   43174:	e0bffc17 	ldw	r2,-16(fp)
   43178:	e0fffd17 	ldw	r3,-12(fp)
   4317c:	10c00015 	stw	r3,0(r2)

  return 0;  
   43180:	0005883a 	mov	r2,zero
}
   43184:	e037883a 	mov	sp,fp
   43188:	dfc00117 	ldw	ra,4(sp)
   4318c:	df000017 	ldw	fp,0(sp)
   43190:	dec00204 	addi	sp,sp,8
   43194:	f800283a 	ret

00043198 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   43198:	defffe04 	addi	sp,sp,-8
   4319c:	dfc00115 	stw	ra,4(sp)
   431a0:	df000015 	stw	fp,0(sp)
   431a4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   431a8:	01420004 	movi	r5,2048
   431ac:	0009883a 	mov	r4,zero
   431b0:	0043a640 	call	43a64 <alt_icache_flush>
#endif
}
   431b4:	0001883a 	nop
   431b8:	e037883a 	mov	sp,fp
   431bc:	dfc00117 	ldw	ra,4(sp)
   431c0:	df000017 	ldw	fp,0(sp)
   431c4:	dec00204 	addi	sp,sp,8
   431c8:	f800283a 	ret

000431cc <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
   431cc:	defffe04 	addi	sp,sp,-8
   431d0:	df000115 	stw	fp,4(sp)
   431d4:	df000104 	addi	fp,sp,4
   431d8:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
   431dc:	e0bfff17 	ldw	r2,-4(fp)
   431e0:	10bffe84 	addi	r2,r2,-6
   431e4:	10c00428 	cmpgeui	r3,r2,16
   431e8:	18001a1e 	bne	r3,zero,43254 <alt_exception_cause_generated_bad_addr+0x88>
   431ec:	100690ba 	slli	r3,r2,2
   431f0:	00800134 	movhi	r2,4
   431f4:	108c8104 	addi	r2,r2,12804
   431f8:	1885883a 	add	r2,r3,r2
   431fc:	10800017 	ldw	r2,0(r2)
   43200:	1000683a 	jmp	r2
   43204:	00043244 	movi	zero,4297
   43208:	00043244 	movi	zero,4297
   4320c:	00043254 	movui	zero,4297
   43210:	00043254 	movui	zero,4297
   43214:	00043254 	movui	zero,4297
   43218:	00043244 	movi	zero,4297
   4321c:	0004324c 	andi	zero,zero,4297
   43220:	00043254 	movui	zero,4297
   43224:	00043244 	movi	zero,4297
   43228:	00043244 	movi	zero,4297
   4322c:	00043254 	movui	zero,4297
   43230:	00043244 	movi	zero,4297
   43234:	0004324c 	andi	zero,zero,4297
   43238:	00043254 	movui	zero,4297
   4323c:	00043254 	movui	zero,4297
   43240:	00043244 	movi	zero,4297
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   43244:	00800044 	movi	r2,1
   43248:	00000306 	br	43258 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   4324c:	0005883a 	mov	r2,zero
   43250:	00000106 	br	43258 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
   43254:	0005883a 	mov	r2,zero
  }
}
   43258:	e037883a 	mov	sp,fp
   4325c:	df000017 	ldw	fp,0(sp)
   43260:	dec00104 	addi	sp,sp,4
   43264:	f800283a 	ret

00043268 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   43268:	defff904 	addi	sp,sp,-28
   4326c:	dfc00615 	stw	ra,24(sp)
   43270:	df000515 	stw	fp,20(sp)
   43274:	df000504 	addi	fp,sp,20
   43278:	e13ffc15 	stw	r4,-16(fp)
   4327c:	e17ffd15 	stw	r5,-12(fp)
   43280:	e1bffe15 	stw	r6,-8(fp)
   43284:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   43288:	e1bfff17 	ldw	r6,-4(fp)
   4328c:	e17ffe17 	ldw	r5,-8(fp)
   43290:	e13ffd17 	ldw	r4,-12(fp)
   43294:	00434a80 	call	434a8 <open>
   43298:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   4329c:	e0bffb17 	ldw	r2,-20(fp)
   432a0:	10001c16 	blt	r2,zero,43314 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   432a4:	00800134 	movhi	r2,4
   432a8:	10903d04 	addi	r2,r2,16628
   432ac:	e0fffb17 	ldw	r3,-20(fp)
   432b0:	18c00324 	muli	r3,r3,12
   432b4:	10c5883a 	add	r2,r2,r3
   432b8:	10c00017 	ldw	r3,0(r2)
   432bc:	e0bffc17 	ldw	r2,-16(fp)
   432c0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   432c4:	00800134 	movhi	r2,4
   432c8:	10903d04 	addi	r2,r2,16628
   432cc:	e0fffb17 	ldw	r3,-20(fp)
   432d0:	18c00324 	muli	r3,r3,12
   432d4:	10c5883a 	add	r2,r2,r3
   432d8:	10800104 	addi	r2,r2,4
   432dc:	10c00017 	ldw	r3,0(r2)
   432e0:	e0bffc17 	ldw	r2,-16(fp)
   432e4:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   432e8:	00800134 	movhi	r2,4
   432ec:	10903d04 	addi	r2,r2,16628
   432f0:	e0fffb17 	ldw	r3,-20(fp)
   432f4:	18c00324 	muli	r3,r3,12
   432f8:	10c5883a 	add	r2,r2,r3
   432fc:	10800204 	addi	r2,r2,8
   43300:	10c00017 	ldw	r3,0(r2)
   43304:	e0bffc17 	ldw	r2,-16(fp)
   43308:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   4330c:	e13ffb17 	ldw	r4,-20(fp)
   43310:	00435fc0 	call	435fc <alt_release_fd>
  }
} 
   43314:	0001883a 	nop
   43318:	e037883a 	mov	sp,fp
   4331c:	dfc00117 	ldw	ra,4(sp)
   43320:	df000017 	ldw	fp,0(sp)
   43324:	dec00204 	addi	sp,sp,8
   43328:	f800283a 	ret

0004332c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   4332c:	defffb04 	addi	sp,sp,-20
   43330:	dfc00415 	stw	ra,16(sp)
   43334:	df000315 	stw	fp,12(sp)
   43338:	df000304 	addi	fp,sp,12
   4333c:	e13ffd15 	stw	r4,-12(fp)
   43340:	e17ffe15 	stw	r5,-8(fp)
   43344:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   43348:	01c07fc4 	movi	r7,511
   4334c:	01800044 	movi	r6,1
   43350:	e17ffd17 	ldw	r5,-12(fp)
   43354:	01000134 	movhi	r4,4
   43358:	21104004 	addi	r4,r4,16640
   4335c:	00432680 	call	43268 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   43360:	01c07fc4 	movi	r7,511
   43364:	000d883a 	mov	r6,zero
   43368:	e17ffe17 	ldw	r5,-8(fp)
   4336c:	01000134 	movhi	r4,4
   43370:	21103d04 	addi	r4,r4,16628
   43374:	00432680 	call	43268 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   43378:	01c07fc4 	movi	r7,511
   4337c:	01800044 	movi	r6,1
   43380:	e17fff17 	ldw	r5,-4(fp)
   43384:	01000134 	movhi	r4,4
   43388:	21104304 	addi	r4,r4,16652
   4338c:	00432680 	call	43268 <alt_open_fd>
}  
   43390:	0001883a 	nop
   43394:	e037883a 	mov	sp,fp
   43398:	dfc00117 	ldw	ra,4(sp)
   4339c:	df000017 	ldw	fp,0(sp)
   433a0:	dec00204 	addi	sp,sp,8
   433a4:	f800283a 	ret

000433a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   433a8:	defffe04 	addi	sp,sp,-8
   433ac:	dfc00115 	stw	ra,4(sp)
   433b0:	df000015 	stw	fp,0(sp)
   433b4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   433b8:	d0a00b17 	ldw	r2,-32724(gp)
   433bc:	10000326 	beq	r2,zero,433cc <alt_get_errno+0x24>
   433c0:	d0a00b17 	ldw	r2,-32724(gp)
   433c4:	103ee83a 	callr	r2
   433c8:	00000106 	br	433d0 <alt_get_errno+0x28>
   433cc:	d0a0ce04 	addi	r2,gp,-31944
}
   433d0:	e037883a 	mov	sp,fp
   433d4:	dfc00117 	ldw	ra,4(sp)
   433d8:	df000017 	ldw	fp,0(sp)
   433dc:	dec00204 	addi	sp,sp,8
   433e0:	f800283a 	ret

000433e4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   433e4:	defffd04 	addi	sp,sp,-12
   433e8:	df000215 	stw	fp,8(sp)
   433ec:	df000204 	addi	fp,sp,8
   433f0:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   433f4:	e0bfff17 	ldw	r2,-4(fp)
   433f8:	10800217 	ldw	r2,8(r2)
   433fc:	10d00034 	orhi	r3,r2,16384
   43400:	e0bfff17 	ldw	r2,-4(fp)
   43404:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   43408:	e03ffe15 	stw	zero,-8(fp)
   4340c:	00001d06 	br	43484 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   43410:	00800134 	movhi	r2,4
   43414:	10903d04 	addi	r2,r2,16628
   43418:	e0fffe17 	ldw	r3,-8(fp)
   4341c:	18c00324 	muli	r3,r3,12
   43420:	10c5883a 	add	r2,r2,r3
   43424:	10c00017 	ldw	r3,0(r2)
   43428:	e0bfff17 	ldw	r2,-4(fp)
   4342c:	10800017 	ldw	r2,0(r2)
   43430:	1880111e 	bne	r3,r2,43478 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   43434:	00800134 	movhi	r2,4
   43438:	10903d04 	addi	r2,r2,16628
   4343c:	e0fffe17 	ldw	r3,-8(fp)
   43440:	18c00324 	muli	r3,r3,12
   43444:	10c5883a 	add	r2,r2,r3
   43448:	10800204 	addi	r2,r2,8
   4344c:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   43450:	1000090e 	bge	r2,zero,43478 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   43454:	e0bffe17 	ldw	r2,-8(fp)
   43458:	10c00324 	muli	r3,r2,12
   4345c:	00800134 	movhi	r2,4
   43460:	10903d04 	addi	r2,r2,16628
   43464:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   43468:	e0bfff17 	ldw	r2,-4(fp)
   4346c:	18800226 	beq	r3,r2,43478 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   43470:	00bffcc4 	movi	r2,-13
   43474:	00000806 	br	43498 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   43478:	e0bffe17 	ldw	r2,-8(fp)
   4347c:	10800044 	addi	r2,r2,1
   43480:	e0bffe15 	stw	r2,-8(fp)
   43484:	d0a00a17 	ldw	r2,-32728(gp)
   43488:	1007883a 	mov	r3,r2
   4348c:	e0bffe17 	ldw	r2,-8(fp)
   43490:	18bfdf2e 	bgeu	r3,r2,43410 <__alt_data_end+0xfffdb410>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   43494:	0005883a 	mov	r2,zero
}
   43498:	e037883a 	mov	sp,fp
   4349c:	df000017 	ldw	fp,0(sp)
   434a0:	dec00104 	addi	sp,sp,4
   434a4:	f800283a 	ret

000434a8 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   434a8:	defff604 	addi	sp,sp,-40
   434ac:	dfc00915 	stw	ra,36(sp)
   434b0:	df000815 	stw	fp,32(sp)
   434b4:	df000804 	addi	fp,sp,32
   434b8:	e13ffd15 	stw	r4,-12(fp)
   434bc:	e17ffe15 	stw	r5,-8(fp)
   434c0:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   434c4:	00bfffc4 	movi	r2,-1
   434c8:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   434cc:	00bffb44 	movi	r2,-19
   434d0:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   434d4:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   434d8:	d1600804 	addi	r5,gp,-32736
   434dc:	e13ffd17 	ldw	r4,-12(fp)
   434e0:	00438280 	call	43828 <alt_find_dev>
   434e4:	e0bff815 	stw	r2,-32(fp)
   434e8:	e0bff817 	ldw	r2,-32(fp)
   434ec:	1000051e 	bne	r2,zero,43504 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   434f0:	e13ffd17 	ldw	r4,-12(fp)
   434f4:	00438b80 	call	438b8 <alt_find_file>
   434f8:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   434fc:	00800044 	movi	r2,1
   43500:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   43504:	e0bff817 	ldw	r2,-32(fp)
   43508:	10002926 	beq	r2,zero,435b0 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
   4350c:	e13ff817 	ldw	r4,-32(fp)
   43510:	00439c00 	call	439c0 <alt_get_fd>
   43514:	e0bff915 	stw	r2,-28(fp)
   43518:	e0bff917 	ldw	r2,-28(fp)
   4351c:	1000030e 	bge	r2,zero,4352c <open+0x84>
    {
      status = index;
   43520:	e0bff917 	ldw	r2,-28(fp)
   43524:	e0bffa15 	stw	r2,-24(fp)
   43528:	00002306 	br	435b8 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
   4352c:	e0bff917 	ldw	r2,-28(fp)
   43530:	10c00324 	muli	r3,r2,12
   43534:	00800134 	movhi	r2,4
   43538:	10903d04 	addi	r2,r2,16628
   4353c:	1885883a 	add	r2,r3,r2
   43540:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   43544:	e0fffe17 	ldw	r3,-8(fp)
   43548:	00900034 	movhi	r2,16384
   4354c:	10bfffc4 	addi	r2,r2,-1
   43550:	1886703a 	and	r3,r3,r2
   43554:	e0bffc17 	ldw	r2,-16(fp)
   43558:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   4355c:	e0bffb17 	ldw	r2,-20(fp)
   43560:	1000051e 	bne	r2,zero,43578 <open+0xd0>
   43564:	e13ffc17 	ldw	r4,-16(fp)
   43568:	00433e40 	call	433e4 <alt_file_locked>
   4356c:	e0bffa15 	stw	r2,-24(fp)
   43570:	e0bffa17 	ldw	r2,-24(fp)
   43574:	10001016 	blt	r2,zero,435b8 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   43578:	e0bff817 	ldw	r2,-32(fp)
   4357c:	10800317 	ldw	r2,12(r2)
   43580:	10000826 	beq	r2,zero,435a4 <open+0xfc>
   43584:	e0bff817 	ldw	r2,-32(fp)
   43588:	10800317 	ldw	r2,12(r2)
   4358c:	e1ffff17 	ldw	r7,-4(fp)
   43590:	e1bffe17 	ldw	r6,-8(fp)
   43594:	e17ffd17 	ldw	r5,-12(fp)
   43598:	e13ffc17 	ldw	r4,-16(fp)
   4359c:	103ee83a 	callr	r2
   435a0:	00000106 	br	435a8 <open+0x100>
   435a4:	0005883a 	mov	r2,zero
   435a8:	e0bffa15 	stw	r2,-24(fp)
   435ac:	00000206 	br	435b8 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
   435b0:	00bffb44 	movi	r2,-19
   435b4:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   435b8:	e0bffa17 	ldw	r2,-24(fp)
   435bc:	1000090e 	bge	r2,zero,435e4 <open+0x13c>
  {
    alt_release_fd (index);  
   435c0:	e13ff917 	ldw	r4,-28(fp)
   435c4:	00435fc0 	call	435fc <alt_release_fd>
    ALT_ERRNO = -status;
   435c8:	00433a80 	call	433a8 <alt_get_errno>
   435cc:	1007883a 	mov	r3,r2
   435d0:	e0bffa17 	ldw	r2,-24(fp)
   435d4:	0085c83a 	sub	r2,zero,r2
   435d8:	18800015 	stw	r2,0(r3)
    return -1;
   435dc:	00bfffc4 	movi	r2,-1
   435e0:	00000106 	br	435e8 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   435e4:	e0bff917 	ldw	r2,-28(fp)
}
   435e8:	e037883a 	mov	sp,fp
   435ec:	dfc00117 	ldw	ra,4(sp)
   435f0:	df000017 	ldw	fp,0(sp)
   435f4:	dec00204 	addi	sp,sp,8
   435f8:	f800283a 	ret

000435fc <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   435fc:	defffe04 	addi	sp,sp,-8
   43600:	df000115 	stw	fp,4(sp)
   43604:	df000104 	addi	fp,sp,4
   43608:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   4360c:	e0bfff17 	ldw	r2,-4(fp)
   43610:	108000d0 	cmplti	r2,r2,3
   43614:	10000d1e 	bne	r2,zero,4364c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   43618:	00800134 	movhi	r2,4
   4361c:	10903d04 	addi	r2,r2,16628
   43620:	e0ffff17 	ldw	r3,-4(fp)
   43624:	18c00324 	muli	r3,r3,12
   43628:	10c5883a 	add	r2,r2,r3
   4362c:	10800204 	addi	r2,r2,8
   43630:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   43634:	00800134 	movhi	r2,4
   43638:	10903d04 	addi	r2,r2,16628
   4363c:	e0ffff17 	ldw	r3,-4(fp)
   43640:	18c00324 	muli	r3,r3,12
   43644:	10c5883a 	add	r2,r2,r3
   43648:	10000015 	stw	zero,0(r2)
  }
}
   4364c:	0001883a 	nop
   43650:	e037883a 	mov	sp,fp
   43654:	df000017 	ldw	fp,0(sp)
   43658:	dec00104 	addi	sp,sp,4
   4365c:	f800283a 	ret

00043660 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   43660:	defffa04 	addi	sp,sp,-24
   43664:	df000515 	stw	fp,20(sp)
   43668:	df000504 	addi	fp,sp,20
   4366c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   43670:	0005303a 	rdctl	r2,status
   43674:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   43678:	e0fffc17 	ldw	r3,-16(fp)
   4367c:	00bfff84 	movi	r2,-2
   43680:	1884703a 	and	r2,r3,r2
   43684:	1001703a 	wrctl	status,r2
  
  return context;
   43688:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   4368c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
   43690:	e0bfff17 	ldw	r2,-4(fp)
   43694:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   43698:	e0bffd17 	ldw	r2,-12(fp)
   4369c:	10800017 	ldw	r2,0(r2)
   436a0:	e0fffd17 	ldw	r3,-12(fp)
   436a4:	18c00117 	ldw	r3,4(r3)
   436a8:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   436ac:	e0bffd17 	ldw	r2,-12(fp)
   436b0:	10800117 	ldw	r2,4(r2)
   436b4:	e0fffd17 	ldw	r3,-12(fp)
   436b8:	18c00017 	ldw	r3,0(r3)
   436bc:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   436c0:	e0bffd17 	ldw	r2,-12(fp)
   436c4:	e0fffd17 	ldw	r3,-12(fp)
   436c8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   436cc:	e0bffd17 	ldw	r2,-12(fp)
   436d0:	e0fffd17 	ldw	r3,-12(fp)
   436d4:	10c00015 	stw	r3,0(r2)
   436d8:	e0bffb17 	ldw	r2,-20(fp)
   436dc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   436e0:	e0bffe17 	ldw	r2,-8(fp)
   436e4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   436e8:	0001883a 	nop
   436ec:	e037883a 	mov	sp,fp
   436f0:	df000017 	ldw	fp,0(sp)
   436f4:	dec00104 	addi	sp,sp,4
   436f8:	f800283a 	ret

000436fc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   436fc:	defffb04 	addi	sp,sp,-20
   43700:	dfc00415 	stw	ra,16(sp)
   43704:	df000315 	stw	fp,12(sp)
   43708:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   4370c:	d0a00c17 	ldw	r2,-32720(gp)
   43710:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   43714:	d0a0d517 	ldw	r2,-31916(gp)
   43718:	10800044 	addi	r2,r2,1
   4371c:	d0a0d515 	stw	r2,-31916(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   43720:	00002e06 	br	437dc <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   43724:	e0bffd17 	ldw	r2,-12(fp)
   43728:	10800017 	ldw	r2,0(r2)
   4372c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   43730:	e0bffd17 	ldw	r2,-12(fp)
   43734:	10800403 	ldbu	r2,16(r2)
   43738:	10803fcc 	andi	r2,r2,255
   4373c:	10000426 	beq	r2,zero,43750 <alt_tick+0x54>
   43740:	d0a0d517 	ldw	r2,-31916(gp)
   43744:	1000021e 	bne	r2,zero,43750 <alt_tick+0x54>
    {
      alarm->rollover = 0;
   43748:	e0bffd17 	ldw	r2,-12(fp)
   4374c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   43750:	e0bffd17 	ldw	r2,-12(fp)
   43754:	10800217 	ldw	r2,8(r2)
   43758:	d0e0d517 	ldw	r3,-31916(gp)
   4375c:	18801d36 	bltu	r3,r2,437d4 <alt_tick+0xd8>
   43760:	e0bffd17 	ldw	r2,-12(fp)
   43764:	10800403 	ldbu	r2,16(r2)
   43768:	10803fcc 	andi	r2,r2,255
   4376c:	1000191e 	bne	r2,zero,437d4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   43770:	e0bffd17 	ldw	r2,-12(fp)
   43774:	10800317 	ldw	r2,12(r2)
   43778:	e0fffd17 	ldw	r3,-12(fp)
   4377c:	18c00517 	ldw	r3,20(r3)
   43780:	1809883a 	mov	r4,r3
   43784:	103ee83a 	callr	r2
   43788:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   4378c:	e0bfff17 	ldw	r2,-4(fp)
   43790:	1000031e 	bne	r2,zero,437a0 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   43794:	e13ffd17 	ldw	r4,-12(fp)
   43798:	00436600 	call	43660 <alt_alarm_stop>
   4379c:	00000d06 	br	437d4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   437a0:	e0bffd17 	ldw	r2,-12(fp)
   437a4:	10c00217 	ldw	r3,8(r2)
   437a8:	e0bfff17 	ldw	r2,-4(fp)
   437ac:	1887883a 	add	r3,r3,r2
   437b0:	e0bffd17 	ldw	r2,-12(fp)
   437b4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   437b8:	e0bffd17 	ldw	r2,-12(fp)
   437bc:	10c00217 	ldw	r3,8(r2)
   437c0:	d0a0d517 	ldw	r2,-31916(gp)
   437c4:	1880032e 	bgeu	r3,r2,437d4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   437c8:	e0bffd17 	ldw	r2,-12(fp)
   437cc:	00c00044 	movi	r3,1
   437d0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   437d4:	e0bffe17 	ldw	r2,-8(fp)
   437d8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   437dc:	e0fffd17 	ldw	r3,-12(fp)
   437e0:	d0a00c04 	addi	r2,gp,-32720
   437e4:	18bfcf1e 	bne	r3,r2,43724 <__alt_data_end+0xfffdb724>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   437e8:	0001883a 	nop
}
   437ec:	0001883a 	nop
   437f0:	e037883a 	mov	sp,fp
   437f4:	dfc00117 	ldw	ra,4(sp)
   437f8:	df000017 	ldw	fp,0(sp)
   437fc:	dec00204 	addi	sp,sp,8
   43800:	f800283a 	ret

00043804 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
   43804:	deffff04 	addi	sp,sp,-4
   43808:	df000015 	stw	fp,0(sp)
   4380c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   43810:	000170fa 	wrctl	ienable,zero
}
   43814:	0001883a 	nop
   43818:	e037883a 	mov	sp,fp
   4381c:	df000017 	ldw	fp,0(sp)
   43820:	dec00104 	addi	sp,sp,4
   43824:	f800283a 	ret

00043828 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   43828:	defffa04 	addi	sp,sp,-24
   4382c:	dfc00515 	stw	ra,20(sp)
   43830:	df000415 	stw	fp,16(sp)
   43834:	df000404 	addi	fp,sp,16
   43838:	e13ffe15 	stw	r4,-8(fp)
   4383c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   43840:	e0bfff17 	ldw	r2,-4(fp)
   43844:	10800017 	ldw	r2,0(r2)
   43848:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   4384c:	e13ffe17 	ldw	r4,-8(fp)
   43850:	0041f6c0 	call	41f6c <strlen>
   43854:	10800044 	addi	r2,r2,1
   43858:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   4385c:	00000d06 	br	43894 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   43860:	e0bffc17 	ldw	r2,-16(fp)
   43864:	10800217 	ldw	r2,8(r2)
   43868:	e0fffd17 	ldw	r3,-12(fp)
   4386c:	180d883a 	mov	r6,r3
   43870:	e17ffe17 	ldw	r5,-8(fp)
   43874:	1009883a 	mov	r4,r2
   43878:	0043b140 	call	43b14 <memcmp>
   4387c:	1000021e 	bne	r2,zero,43888 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   43880:	e0bffc17 	ldw	r2,-16(fp)
   43884:	00000706 	br	438a4 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   43888:	e0bffc17 	ldw	r2,-16(fp)
   4388c:	10800017 	ldw	r2,0(r2)
   43890:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   43894:	e0fffc17 	ldw	r3,-16(fp)
   43898:	e0bfff17 	ldw	r2,-4(fp)
   4389c:	18bff01e 	bne	r3,r2,43860 <__alt_data_end+0xfffdb860>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   438a0:	0005883a 	mov	r2,zero
}
   438a4:	e037883a 	mov	sp,fp
   438a8:	dfc00117 	ldw	ra,4(sp)
   438ac:	df000017 	ldw	fp,0(sp)
   438b0:	dec00204 	addi	sp,sp,8
   438b4:	f800283a 	ret

000438b8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   438b8:	defffb04 	addi	sp,sp,-20
   438bc:	dfc00415 	stw	ra,16(sp)
   438c0:	df000315 	stw	fp,12(sp)
   438c4:	df000304 	addi	fp,sp,12
   438c8:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   438cc:	d0a00617 	ldw	r2,-32744(gp)
   438d0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   438d4:	00003106 	br	4399c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
   438d8:	e0bffd17 	ldw	r2,-12(fp)
   438dc:	10800217 	ldw	r2,8(r2)
   438e0:	1009883a 	mov	r4,r2
   438e4:	0041f6c0 	call	41f6c <strlen>
   438e8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   438ec:	e0bffd17 	ldw	r2,-12(fp)
   438f0:	10c00217 	ldw	r3,8(r2)
   438f4:	e0bffe17 	ldw	r2,-8(fp)
   438f8:	10bfffc4 	addi	r2,r2,-1
   438fc:	1885883a 	add	r2,r3,r2
   43900:	10800003 	ldbu	r2,0(r2)
   43904:	10803fcc 	andi	r2,r2,255
   43908:	1080201c 	xori	r2,r2,128
   4390c:	10bfe004 	addi	r2,r2,-128
   43910:	10800bd8 	cmpnei	r2,r2,47
   43914:	1000031e 	bne	r2,zero,43924 <alt_find_file+0x6c>
    {
      len -= 1;
   43918:	e0bffe17 	ldw	r2,-8(fp)
   4391c:	10bfffc4 	addi	r2,r2,-1
   43920:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   43924:	e0bffe17 	ldw	r2,-8(fp)
   43928:	e0ffff17 	ldw	r3,-4(fp)
   4392c:	1885883a 	add	r2,r3,r2
   43930:	10800003 	ldbu	r2,0(r2)
   43934:	10803fcc 	andi	r2,r2,255
   43938:	1080201c 	xori	r2,r2,128
   4393c:	10bfe004 	addi	r2,r2,-128
   43940:	10800be0 	cmpeqi	r2,r2,47
   43944:	1000081e 	bne	r2,zero,43968 <alt_find_file+0xb0>
   43948:	e0bffe17 	ldw	r2,-8(fp)
   4394c:	e0ffff17 	ldw	r3,-4(fp)
   43950:	1885883a 	add	r2,r3,r2
   43954:	10800003 	ldbu	r2,0(r2)
   43958:	10803fcc 	andi	r2,r2,255
   4395c:	1080201c 	xori	r2,r2,128
   43960:	10bfe004 	addi	r2,r2,-128
   43964:	10000a1e 	bne	r2,zero,43990 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
   43968:	e0bffd17 	ldw	r2,-12(fp)
   4396c:	10800217 	ldw	r2,8(r2)
   43970:	e0fffe17 	ldw	r3,-8(fp)
   43974:	180d883a 	mov	r6,r3
   43978:	e17fff17 	ldw	r5,-4(fp)
   4397c:	1009883a 	mov	r4,r2
   43980:	0043b140 	call	43b14 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   43984:	1000021e 	bne	r2,zero,43990 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   43988:	e0bffd17 	ldw	r2,-12(fp)
   4398c:	00000706 	br	439ac <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
   43990:	e0bffd17 	ldw	r2,-12(fp)
   43994:	10800017 	ldw	r2,0(r2)
   43998:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   4399c:	e0fffd17 	ldw	r3,-12(fp)
   439a0:	d0a00604 	addi	r2,gp,-32744
   439a4:	18bfcc1e 	bne	r3,r2,438d8 <__alt_data_end+0xfffdb8d8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   439a8:	0005883a 	mov	r2,zero
}
   439ac:	e037883a 	mov	sp,fp
   439b0:	dfc00117 	ldw	ra,4(sp)
   439b4:	df000017 	ldw	fp,0(sp)
   439b8:	dec00204 	addi	sp,sp,8
   439bc:	f800283a 	ret

000439c0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   439c0:	defffc04 	addi	sp,sp,-16
   439c4:	df000315 	stw	fp,12(sp)
   439c8:	df000304 	addi	fp,sp,12
   439cc:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   439d0:	00bffa04 	movi	r2,-24
   439d4:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   439d8:	e03ffd15 	stw	zero,-12(fp)
   439dc:	00001906 	br	43a44 <alt_get_fd+0x84>
  {
    if (!alt_fd_list[i].dev)
   439e0:	00800134 	movhi	r2,4
   439e4:	10903d04 	addi	r2,r2,16628
   439e8:	e0fffd17 	ldw	r3,-12(fp)
   439ec:	18c00324 	muli	r3,r3,12
   439f0:	10c5883a 	add	r2,r2,r3
   439f4:	10800017 	ldw	r2,0(r2)
   439f8:	10000f1e 	bne	r2,zero,43a38 <alt_get_fd+0x78>
    {
      alt_fd_list[i].dev = dev;
   439fc:	00800134 	movhi	r2,4
   43a00:	10903d04 	addi	r2,r2,16628
   43a04:	e0fffd17 	ldw	r3,-12(fp)
   43a08:	18c00324 	muli	r3,r3,12
   43a0c:	10c5883a 	add	r2,r2,r3
   43a10:	e0ffff17 	ldw	r3,-4(fp)
   43a14:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   43a18:	d0e00a17 	ldw	r3,-32728(gp)
   43a1c:	e0bffd17 	ldw	r2,-12(fp)
   43a20:	1880020e 	bge	r3,r2,43a2c <alt_get_fd+0x6c>
      {
        alt_max_fd = i;
   43a24:	e0bffd17 	ldw	r2,-12(fp)
   43a28:	d0a00a15 	stw	r2,-32728(gp)
      }
      rc = i;
   43a2c:	e0bffd17 	ldw	r2,-12(fp)
   43a30:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   43a34:	00000606 	br	43a50 <alt_get_fd+0x90>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   43a38:	e0bffd17 	ldw	r2,-12(fp)
   43a3c:	10800044 	addi	r2,r2,1
   43a40:	e0bffd15 	stw	r2,-12(fp)
   43a44:	e0bffd17 	ldw	r2,-12(fp)
   43a48:	10800810 	cmplti	r2,r2,32
   43a4c:	103fe41e 	bne	r2,zero,439e0 <__alt_data_end+0xfffdb9e0>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   43a50:	e0bffe17 	ldw	r2,-8(fp)
}
   43a54:	e037883a 	mov	sp,fp
   43a58:	df000017 	ldw	fp,0(sp)
   43a5c:	dec00104 	addi	sp,sp,4
   43a60:	f800283a 	ret

00043a64 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   43a64:	defffb04 	addi	sp,sp,-20
   43a68:	df000415 	stw	fp,16(sp)
   43a6c:	df000404 	addi	fp,sp,16
   43a70:	e13ffe15 	stw	r4,-8(fp)
   43a74:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   43a78:	e0bfff17 	ldw	r2,-4(fp)
   43a7c:	10820070 	cmpltui	r2,r2,2049
   43a80:	1000021e 	bne	r2,zero,43a8c <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   43a84:	00820004 	movi	r2,2048
   43a88:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   43a8c:	e0fffe17 	ldw	r3,-8(fp)
   43a90:	e0bfff17 	ldw	r2,-4(fp)
   43a94:	1885883a 	add	r2,r3,r2
   43a98:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   43a9c:	e0bffe17 	ldw	r2,-8(fp)
   43aa0:	e0bffc15 	stw	r2,-16(fp)
   43aa4:	00000506 	br	43abc <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   43aa8:	e0bffc17 	ldw	r2,-16(fp)
   43aac:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   43ab0:	e0bffc17 	ldw	r2,-16(fp)
   43ab4:	10800804 	addi	r2,r2,32
   43ab8:	e0bffc15 	stw	r2,-16(fp)
   43abc:	e0fffc17 	ldw	r3,-16(fp)
   43ac0:	e0bffd17 	ldw	r2,-12(fp)
   43ac4:	18bff836 	bltu	r3,r2,43aa8 <__alt_data_end+0xfffdbaa8>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   43ac8:	e0bffe17 	ldw	r2,-8(fp)
   43acc:	108007cc 	andi	r2,r2,31
   43ad0:	10000226 	beq	r2,zero,43adc <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   43ad4:	e0bffc17 	ldw	r2,-16(fp)
   43ad8:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   43adc:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   43ae0:	0001883a 	nop
   43ae4:	e037883a 	mov	sp,fp
   43ae8:	df000017 	ldw	fp,0(sp)
   43aec:	dec00104 	addi	sp,sp,4
   43af0:	f800283a 	ret

00043af4 <exit>:
   43af4:	defffe04 	addi	sp,sp,-8
   43af8:	000b883a 	mov	r5,zero
   43afc:	dc000015 	stw	r16,0(sp)
   43b00:	dfc00115 	stw	ra,4(sp)
   43b04:	2021883a 	mov	r16,r4
   43b08:	0043b440 	call	43b44 <__call_exitprocs>
   43b0c:	8009883a 	mov	r4,r16
   43b10:	0043cd40 	call	43cd4 <_exit>

00043b14 <memcmp>:
   43b14:	218d883a 	add	r6,r4,r6
   43b18:	21800826 	beq	r4,r6,43b3c <memcmp+0x28>
   43b1c:	20800003 	ldbu	r2,0(r4)
   43b20:	28c00003 	ldbu	r3,0(r5)
   43b24:	10c00226 	beq	r2,r3,43b30 <memcmp+0x1c>
   43b28:	10c5c83a 	sub	r2,r2,r3
   43b2c:	f800283a 	ret
   43b30:	21000044 	addi	r4,r4,1
   43b34:	29400044 	addi	r5,r5,1
   43b38:	003ff706 	br	43b18 <__alt_data_end+0xfffdbb18>
   43b3c:	0005883a 	mov	r2,zero
   43b40:	f800283a 	ret

00043b44 <__call_exitprocs>:
   43b44:	defff504 	addi	sp,sp,-44
   43b48:	dd000515 	stw	r20,20(sp)
   43b4c:	05000134 	movhi	r20,4
   43b50:	dc800315 	stw	r18,12(sp)
   43b54:	dfc00a15 	stw	ra,40(sp)
   43b58:	df000915 	stw	fp,36(sp)
   43b5c:	ddc00815 	stw	r23,32(sp)
   43b60:	dd800715 	stw	r22,28(sp)
   43b64:	dd400615 	stw	r21,24(sp)
   43b68:	dcc00415 	stw	r19,16(sp)
   43b6c:	dc400215 	stw	r17,8(sp)
   43b70:	dc000115 	stw	r16,4(sp)
   43b74:	d9000015 	stw	r4,0(sp)
   43b78:	2825883a 	mov	r18,r5
   43b7c:	a510a004 	addi	r20,r20,17024
   43b80:	a4400017 	ldw	r17,0(r20)
   43b84:	8cc00c17 	ldw	r19,48(r17)
   43b88:	8c400c04 	addi	r17,r17,48
   43b8c:	98004526 	beq	r19,zero,43ca4 <__call_exitprocs+0x160>
   43b90:	9c000117 	ldw	r16,4(r19)
   43b94:	00900034 	movhi	r2,16384
   43b98:	10bfffc4 	addi	r2,r2,-1
   43b9c:	9d402217 	ldw	r21,136(r19)
   43ba0:	85bfffc4 	addi	r22,r16,-1
   43ba4:	80a1883a 	add	r16,r16,r2
   43ba8:	8421883a 	add	r16,r16,r16
   43bac:	8421883a 	add	r16,r16,r16
   43bb0:	ac2f883a 	add	r23,r21,r16
   43bb4:	84000204 	addi	r16,r16,8
   43bb8:	9c21883a 	add	r16,r19,r16
   43bbc:	b0002716 	blt	r22,zero,43c5c <__call_exitprocs+0x118>
   43bc0:	90000726 	beq	r18,zero,43be0 <__call_exitprocs+0x9c>
   43bc4:	a800041e 	bne	r21,zero,43bd8 <__call_exitprocs+0x94>
   43bc8:	b5bfffc4 	addi	r22,r22,-1
   43bcc:	bdffff04 	addi	r23,r23,-4
   43bd0:	843fff04 	addi	r16,r16,-4
   43bd4:	003ff906 	br	43bbc <__alt_data_end+0xfffdbbbc>
   43bd8:	b9002017 	ldw	r4,128(r23)
   43bdc:	913ffa1e 	bne	r18,r4,43bc8 <__alt_data_end+0xfffdbbc8>
   43be0:	99000117 	ldw	r4,4(r19)
   43be4:	82000017 	ldw	r8,0(r16)
   43be8:	213fffc4 	addi	r4,r4,-1
   43bec:	b100021e 	bne	r22,r4,43bf8 <__call_exitprocs+0xb4>
   43bf0:	9d800115 	stw	r22,4(r19)
   43bf4:	00000106 	br	43bfc <__call_exitprocs+0xb8>
   43bf8:	80000015 	stw	zero,0(r16)
   43bfc:	403ff226 	beq	r8,zero,43bc8 <__alt_data_end+0xfffdbbc8>
   43c00:	9f000117 	ldw	fp,4(r19)
   43c04:	a8000526 	beq	r21,zero,43c1c <__call_exitprocs+0xd8>
   43c08:	00800044 	movi	r2,1
   43c0c:	1592983a 	sll	r9,r2,r22
   43c10:	a9404017 	ldw	r5,256(r21)
   43c14:	494a703a 	and	r5,r9,r5
   43c18:	2800021e 	bne	r5,zero,43c24 <__call_exitprocs+0xe0>
   43c1c:	403ee83a 	callr	r8
   43c20:	00000906 	br	43c48 <__call_exitprocs+0x104>
   43c24:	a9004117 	ldw	r4,260(r21)
   43c28:	4908703a 	and	r4,r9,r4
   43c2c:	2000041e 	bne	r4,zero,43c40 <__call_exitprocs+0xfc>
   43c30:	b9400017 	ldw	r5,0(r23)
   43c34:	d9000017 	ldw	r4,0(sp)
   43c38:	403ee83a 	callr	r8
   43c3c:	00000206 	br	43c48 <__call_exitprocs+0x104>
   43c40:	b9000017 	ldw	r4,0(r23)
   43c44:	403ee83a 	callr	r8
   43c48:	99000117 	ldw	r4,4(r19)
   43c4c:	e13fcc1e 	bne	fp,r4,43b80 <__alt_data_end+0xfffdbb80>
   43c50:	89000017 	ldw	r4,0(r17)
   43c54:	993fdc26 	beq	r19,r4,43bc8 <__alt_data_end+0xfffdbbc8>
   43c58:	003fc906 	br	43b80 <__alt_data_end+0xfffdbb80>
   43c5c:	00800034 	movhi	r2,0
   43c60:	10800004 	addi	r2,r2,0
   43c64:	10000f26 	beq	r2,zero,43ca4 <__call_exitprocs+0x160>
   43c68:	99400117 	ldw	r5,4(r19)
   43c6c:	99000017 	ldw	r4,0(r19)
   43c70:	2800091e 	bne	r5,zero,43c98 <__call_exitprocs+0x154>
   43c74:	20000826 	beq	r4,zero,43c98 <__call_exitprocs+0x154>
   43c78:	89000015 	stw	r4,0(r17)
   43c7c:	a8000226 	beq	r21,zero,43c88 <__call_exitprocs+0x144>
   43c80:	a809883a 	mov	r4,r21
   43c84:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   43c88:	9809883a 	mov	r4,r19
   43c8c:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   43c90:	8cc00017 	ldw	r19,0(r17)
   43c94:	003fbd06 	br	43b8c <__alt_data_end+0xfffdbb8c>
   43c98:	9823883a 	mov	r17,r19
   43c9c:	2027883a 	mov	r19,r4
   43ca0:	003fba06 	br	43b8c <__alt_data_end+0xfffdbb8c>
   43ca4:	dfc00a17 	ldw	ra,40(sp)
   43ca8:	df000917 	ldw	fp,36(sp)
   43cac:	ddc00817 	ldw	r23,32(sp)
   43cb0:	dd800717 	ldw	r22,28(sp)
   43cb4:	dd400617 	ldw	r21,24(sp)
   43cb8:	dd000517 	ldw	r20,20(sp)
   43cbc:	dcc00417 	ldw	r19,16(sp)
   43cc0:	dc800317 	ldw	r18,12(sp)
   43cc4:	dc400217 	ldw	r17,8(sp)
   43cc8:	dc000117 	ldw	r16,4(sp)
   43ccc:	dec00b04 	addi	sp,sp,44
   43cd0:	f800283a 	ret

00043cd4 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   43cd4:	defffd04 	addi	sp,sp,-12
   43cd8:	df000215 	stw	fp,8(sp)
   43cdc:	df000204 	addi	fp,sp,8
   43ce0:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   43ce4:	0001883a 	nop
   43ce8:	e0bfff17 	ldw	r2,-4(fp)
   43cec:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
   43cf0:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   43cf4:	10000226 	beq	r2,zero,43d00 <_exit+0x2c>
    ALT_SIM_FAIL();
   43cf8:	002af070 	cmpltui	zero,zero,43969
   43cfc:	00000106 	br	43d04 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
   43d00:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   43d04:	003fff06 	br	43d04 <__alt_data_end+0xfffdbd04>
