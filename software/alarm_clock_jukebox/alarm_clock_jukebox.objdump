
alarm_clock_jukebox.elf:     file format elf32-littlenios2
alarm_clock_jukebox.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00040244

Program Header:
    LOAD off    0x00001000 vaddr 0x00040000 paddr 0x00040000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00040020 paddr 0x00040020 align 2**12
         filesz 0x00008074 memsz 0x00008074 flags r-x
    LOAD off    0x00009094 vaddr 0x00048094 paddr 0x00048434 align 2**12
         filesz 0x000003a0 memsz 0x000003a0 flags rw-
    LOAD off    0x000097d4 vaddr 0x000487d4 paddr 0x000487d4 align 2**12
         filesz 0x00000000 memsz 0x00000138 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00040000  00040000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000224  00040020  00040020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00005ee8  00040244  00040244  00001244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00001f68  0004612c  0004612c  0000712c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000003a0  00048094  00048434  00009094  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000138  000487d4  000487d4  000097d4  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  0004890c  0004890c  00009434  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00009434  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000790  00000000  00000000  00009458  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00009a22  00000000  00000000  00009be8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000035de  00000000  00000000  0001360a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00004216  00000000  00000000  00016be8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001414  00000000  00000000  0001ae00  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00002541  00000000  00000000  0001c214  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00003d87  00000000  00000000  0001e755  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000020  00000000  00000000  000224dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000007f8  00000000  00000000  00022500  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000250b6  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000a  00000000  00000000  000250b9  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000250c3  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000250c4  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  000250c5  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  000250c9  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  000250cd  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   0000000b  00000000  00000000  000250d1  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    0000000b  00000000  00000000  000250dc  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   0000000b  00000000  00000000  000250e7  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000b  00000000  00000000  000250f2  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000061  00000000  00000000  000250fd  2**0
                  CONTENTS, READONLY
 29 .jdi          0000599a  00000000  00000000  0002515e  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     000856a0  00000000  00000000  0002aaf8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00040000 l    d  .entry	00000000 .entry
00040020 l    d  .exceptions	00000000 .exceptions
00040244 l    d  .text	00000000 .text
0004612c l    d  .rodata	00000000 .rodata
00048094 l    d  .rwdata	00000000 .rwdata
000487d4 l    d  .bss	00000000 .bss
0004890c l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../alarm_clock_jukebox_bsp//obj/HAL/src/crt0.o
0004027c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 altera_avalon_pwm_routines.c
00000000 l    df *ABS*	00000000 display.c
00000000 l    df *ABS*	00000000 interrupt.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 pwm.c
00000000 l    df *ABS*	00000000 rtttl.c
00000000 l    df *ABS*	00000000 switches.c
000487e8 l     O .bss	00000006 mode.1651
00000000 l    df *ABS*	00000000 time_keeper.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
0004465c l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00048140 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00044fb8 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00045110 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00045244 l     F .text	00000034 alt_dev_reg
00048220 l     O .rwdata	0000002c jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_close.c
00045528 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00045654 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00045680 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00045830 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
00045970 l     F .text	0000003c alt_get_errno
000459ac l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00048808 g     O .bss	00000004 alt_instruction_exception_handler
000416b4 g     F .text	000000e8 writePWM
00040824 g     F .text	00000048 timerPWMRegisterISR
00041400 g     F .text	00000168 timerPWMISR
000450a4 g     F .text	0000006c alt_main
000445ac g     F .text	00000080 _puts_r
0004880c g     O .bss	00000100 alt_irq
00048434 g       *ABS*	00000000 __flash_rwdata_start
00044560 g     F .text	0000004c printf
00042814 g     F .text	00000084 getClockTime
00042a2c g     F .text	000000b0 upClockHour
000487e4 g     O .bss	00000004 p
0004075c g     F .text	00000048 buttonsRegisterISR
000415b4 g     F .text	0000002c downVolume
000432a8 g     F .text	000000dc .hidden __gtdf2
00045c28 g     F .text	00000024 altera_nios2_gen2_irq_init
00040000 g     F .entry	0000001c __reset
00040020 g       *ABS*	00000000 __flash_exceptions_start
000487f4 g     O .bss	00000004 errno
00048800 g     O .bss	00000004 alt_argv
000503f4 g       *ABS*	00000000 _gp
0004840d g     O .rwdata	00000001 time_format
00040938 g     F .text	00000030 alarmLEDon
00048274 g     O .rwdata	00000180 alt_fd_list
00045c4c g     F .text	00000090 alt_find_dev
000458f4 g     F .text	0000007c alt_io_redirect
0004462c g     F .text	00000014 puts
00045794 g     F .text	0000009c alt_exception_cause_generated_bad_addr
000453a8 g     F .text	000000ec altera_avalon_jtag_uart_read
00044524 g     F .text	0000003c _printf_r
000431ec g     F .text	00000064 .hidden __udivsi3
00043080 g     F .text	00000074 .hidden __fixunsdfsi
00045e88 g     F .text	00000090 alt_icache_flush
000483f4 g     O .rwdata	00000001 volume
00048094 g     O .rwdata	0000007c song
00040714 g     F .text	00000048 switchesRegisterISR
0004842c g     O .rwdata	00000004 alt_max_fd
00048404 g     O .rwdata	00000006 unused_switches
00042fd4 g     F .text	000000ac downAlarmHour
000418c8 g     F .text	00000044 check_return_code
00042ba8 g     F .text	000000c8 downClockMinute
00048410 g     O .rwdata	00000004 _global_impure_ptr
00042d50 g     F .text	00000084 getAlarmTime
00041aa0 g     F .text	0000008c note2freq
0004890c g       *ABS*	00000000 __bss_end
00044ec8 g     F .text	000000f0 alt_iic_isr_register
00040cec g     F .text	000002c4 switchesISR
00044418 g     F .text	000000a8 .hidden __floatunsidf
00044e7c g     F .text	0000004c alt_ic_irq_enabled
000487ee g     O .bss	00000003 alarm
000415e0 g     F .text	0000004c stopPWM
000487f8 g     O .bss	00000004 alt_irq_active
000400fc g     F .exceptions	000000d4 alt_irq_handler
0004824c g     O .rwdata	00000028 alt_dev_null
00045634 g     F .text	00000020 alt_dcache_flush_all
00044398 g     F .text	00000080 .hidden __fixdfsi
00040abc g     F .text	00000230 timerSecondISR
00048434 g       *ABS*	00000000 __ram_rwdata_end
00042dd4 g     F .text	000000a8 upAlarmMinute
00040000 g       *ABS*	00000000 __alt_mem_onchip_memory
00048424 g     O .rwdata	00000008 alt_dev_list
0004514c g     F .text	000000f8 write
00042c70 g     F .text	000000ac downClockHour
00048094 g       *ABS*	00000000 __ram_rodata_end
000408d8 g     F .text	00000030 timerPWMDisableInterrupt
0004612c g     O .rodata	0000000b COM_ANODE_SEG_TABLE
00042898 g     F .text	000000cc upClockSecond
00043250 g     F .text	00000058 .hidden __umodsi3
00040908 g     F .text	00000030 alarmLEDoff
00040968 g     F .text	0000004c alarmLEDtoggle
0004890c g       *ABS*	00000000 end
000487d4 g     O .bss	00000006 mode
000401d0 g     F .exceptions	00000074 alt_instruction_exception_entry
00042f2c g     F .text	000000a8 downAlarmMinute
00068000 g       *ABS*	00000000 __alt_stack_pointer
000444c0 g     F .text	00000064 .hidden __clzsi2
00045494 g     F .text	00000094 altera_avalon_jtag_uart_write
000446c8 g     F .text	00000524 ___vfprintf_internal_r
00045f68 g     F .text	00000190 __call_exitprocs
00041a18 g     F .text	00000044 upSong
00040244 g     F .text	0000003c _start
00040280 g     F .text	00000064 altera_avalon_pwm_init
000452b0 g     F .text	00000038 alt_sys_init
000483f8 g     O .rwdata	00000004 defdur
000426fc g     F .text	0000009c checkInvalidMode
00048094 g       *ABS*	00000000 __ram_rwdata_start
0004612c g       *ABS*	00000000 __ram_rodata_start
0004840a g     O .rwdata	00000003 reset_clock_value
000407a4 g     F .text	00000040 switchesEnableInterrupt
00041588 g     F .text	0000002c upVolume
000452e8 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00045de4 g     F .text	000000a4 alt_get_fd
00045f38 g     F .text	00000030 memcmp
0004890c g       *ABS*	00000000 __alt_stack_base
0004190c g     F .text	000000ec print_error
00043384 g     F .text	00000718 .hidden __muldf3
00042798 g     F .text	00000044 isPowerOfTwoOrZero
00045cdc g     F .text	00000108 alt_find_file
000456bc g     F .text	000000a4 alt_dev_llist_insert
000427dc g     F .text	00000038 resetClockTime
00041e18 g     F .text	00000668 getNote
00048400 g     O .rwdata	00000004 bpm
000402e4 g     F .text	00000054 altera_avalon_pwm_enable
00044c08 g     F .text	000000b8 __sfvwrite_small_dev
000487d4 g       *ABS*	00000000 __bss_start
000419f8 g     F .text	00000020 getSong
000409b4 g     F .text	00000108 main
00048110 g     O .rwdata	00000030 notefreq
00048804 g     O .bss	00000004 alt_envp
00045348 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0004086c g     F .text	0000006c timerPWMEnableInterrupt
000403e0 g     F .text	00000080 resetDisplay
00048430 g     O .rwdata	00000004 alt_errno
000430f4 g     F .text	00000084 .hidden __divsi3
00042adc g     F .text	000000cc downClockSecond
0004612c g       *ABS*	00000000 __flash_rodata_start
00040388 g     F .text	00000058 altera_avalon_pwm_change_duty_cycle
00045278 g     F .text	00000038 alt_irq_init
00045bc4 g     F .text	00000064 alt_release_fd
00047f5a g     O .rodata	00000100 .hidden __clz_tab
000487dc g     O .bss	00000001 song_index
00044cc0 g     F .text	00000058 _write_r
00042964 g     F .text	000000c8 upClockMinute
00048414 g     O .rwdata	00000004 _impure_ptr
000487fc g     O .bss	00000004 alt_argc
00040020 g       .exceptions	00000000 alt_irq_entry
000406e4 g     F .text	00000030 timerSecondEnableInterrupt
0004841c g     O .rwdata	00000008 alt_fs_list
00042480 g     F .text	0000027c determineMode
00040338 g     F .text	00000050 altera_avalon_pwm_disable
00040020 g       *ABS*	00000000 __ram_exceptions_start
00044d18 g     F .text	00000050 alt_ic_isr_register
00048434 g       *ABS*	00000000 _edata
0004890c g       *ABS*	00000000 _end
00040244 g       *ABS*	00000000 __ram_exceptions_end
000407e4 g     F .text	00000040 buttonsEnableInterrupt
00044df0 g     F .text	0000008c alt_ic_irq_disable
00045f18 g     F .text	00000020 exit
00043178 g     F .text	00000074 .hidden __modsi3
00068000 g       *ABS*	00000000 __alt_data_end
00040020 g     F .exceptions	00000000 alt_exception
0004069c g     F .text	00000048 timerSecondRegisterISR
00042e7c g     F .text	000000b0 upAlarmHour
000460f8 g     F .text	00000034 _exit
00041a5c g     F .text	00000044 downSong
00044640 g     F .text	0000001c strlen
00045a70 g     F .text	00000154 open
000432a8 g     F .text	000000dc .hidden __gedf2
00041b2c g     F .text	000002ec playSong
000487f1 g     O .bss	00000003 clock
00047efa g     O .rodata	00000060 mode_lookup_table
00045760 g     F .text	00000034 alt_icache_flush_all
00040fb0 g     F .text	00000450 buttonsISR
00048418 g     O .rwdata	00000004 alt_priority_mask
00044d68 g     F .text	00000088 alt_ic_irq_enable
00044bec g     F .text	0000001c __vfprintf_internal
00043a9c g     F .text	000008fc .hidden __subdf3
00045564 g     F .text	000000d0 close
0004179c g     F .text	0000012c testPWM
000483fc g     O .rwdata	00000004 defscale
00041568 g     F .text	00000020 getVolume
000487e0 g     O .bss	00000004 silence
00042d1c g     F .text	00000034 resetAlarmTime
00045020 g     F .text	00000084 alt_load
00040460 g     F .text	0000023c updateDisplay
0004162c g     F .text	00000088 default500HzSquareWave



Disassembly of section .entry:

00040000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   40000:	00820014 	movui	r2,2048
#endif

0:
    initi r2
   40004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   40008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   4000c:	00bffd16 	blt	zero,r2,40004 <__alt_data_end+0xfffd8004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   40010:	00400134 	movhi	at,4
    ori r1, r1, %lo(_start)
   40014:	08409114 	ori	at,at,580
    jmp r1
   40018:	0800683a 	jmp	at
   4001c:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>

Disassembly of section .exceptions:

00040020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   40020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   40024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   40028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   4002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   40030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   40034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   40038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   4003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   40040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   40044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   40048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   4004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   40050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   40054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   40058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   4005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   40060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   40064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   40068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   4006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   40070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   40074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   40078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   4007c:	10000326 	beq	r2,zero,4008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   40080:	20000226 	beq	r4,zero,4008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   40084:	00400fc0 	call	400fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   40088:	00000706 	br	400a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   4008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   40090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
   40094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
   40098:	00401d00 	call	401d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
   4009c:	1000021e 	bne	r2,zero,400a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
   400a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   400a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   400a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   400ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   400b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   400b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   400b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   400bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   400c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   400c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   400c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   400cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   400d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   400d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   400d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   400dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   400e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   400e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   400e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   400ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   400f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   400f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   400f8:	ef80083a 	eret

000400fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   400fc:	defff904 	addi	sp,sp,-28
   40100:	dfc00615 	stw	ra,24(sp)
   40104:	df000515 	stw	fp,20(sp)
   40108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   4010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   40110:	0005313a 	rdctl	r2,ipending
   40114:	e0bffe15 	stw	r2,-8(fp)

  return active;
   40118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   4011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
   40120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   40124:	00800044 	movi	r2,1
   40128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   4012c:	e0fffb17 	ldw	r3,-20(fp)
   40130:	e0bffc17 	ldw	r2,-16(fp)
   40134:	1884703a 	and	r2,r3,r2
   40138:	10001426 	beq	r2,zero,4018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   4013c:	00800174 	movhi	r2,5
   40140:	10a20304 	addi	r2,r2,-30708
   40144:	e0fffd17 	ldw	r3,-12(fp)
   40148:	180690fa 	slli	r3,r3,3
   4014c:	10c5883a 	add	r2,r2,r3
   40150:	10c00017 	ldw	r3,0(r2)
   40154:	00800174 	movhi	r2,5
   40158:	10a20304 	addi	r2,r2,-30708
   4015c:	e13ffd17 	ldw	r4,-12(fp)
   40160:	200890fa 	slli	r4,r4,3
   40164:	1105883a 	add	r2,r2,r4
   40168:	10800104 	addi	r2,r2,4
   4016c:	10800017 	ldw	r2,0(r2)
   40170:	1009883a 	mov	r4,r2
   40174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
   40178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   4017c:	0005313a 	rdctl	r2,ipending
   40180:	e0bfff15 	stw	r2,-4(fp)

  return active;
   40184:	e0bfff17 	ldw	r2,-4(fp)
   40188:	00000706 	br	401a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
   4018c:	e0bffc17 	ldw	r2,-16(fp)
   40190:	1085883a 	add	r2,r2,r2
   40194:	e0bffc15 	stw	r2,-16(fp)
      i++;
   40198:	e0bffd17 	ldw	r2,-12(fp)
   4019c:	10800044 	addi	r2,r2,1
   401a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   401a4:	003fe106 	br	4012c <__alt_data_end+0xfffd812c>

    active = alt_irq_pending ();
   401a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
   401ac:	e0bffb17 	ldw	r2,-20(fp)
   401b0:	103fdb1e 	bne	r2,zero,40120 <__alt_data_end+0xfffd8120>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   401b4:	0001883a 	nop
}
   401b8:	0001883a 	nop
   401bc:	e037883a 	mov	sp,fp
   401c0:	dfc00117 	ldw	ra,4(sp)
   401c4:	df000017 	ldw	fp,0(sp)
   401c8:	dec00204 	addi	sp,sp,8
   401cc:	f800283a 	ret

000401d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
   401d0:	defffb04 	addi	sp,sp,-20
   401d4:	dfc00415 	stw	ra,16(sp)
   401d8:	df000315 	stw	fp,12(sp)
   401dc:	df000304 	addi	fp,sp,12
   401e0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
   401e4:	000531fa 	rdctl	r2,exception
   401e8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
   401ec:	e0bffd17 	ldw	r2,-12(fp)
   401f0:	10801f0c 	andi	r2,r2,124
   401f4:	1004d0ba 	srli	r2,r2,2
   401f8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
   401fc:	0005333a 	rdctl	r2,badaddr
   40200:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   40204:	d0a10517 	ldw	r2,-31724(gp)
   40208:	10000726 	beq	r2,zero,40228 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   4020c:	d0a10517 	ldw	r2,-31724(gp)
   40210:	e0fffd17 	ldw	r3,-12(fp)
   40214:	e1bffe17 	ldw	r6,-8(fp)
   40218:	e17fff17 	ldw	r5,-4(fp)
   4021c:	1809883a 	mov	r4,r3
   40220:	103ee83a 	callr	r2
   40224:	00000206 	br	40230 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   40228:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
   4022c:	0005883a 	mov	r2,zero
}
   40230:	e037883a 	mov	sp,fp
   40234:	dfc00117 	ldw	ra,4(sp)
   40238:	df000017 	ldw	fp,0(sp)
   4023c:	dec00204 	addi	sp,sp,8
   40240:	f800283a 	ret

Disassembly of section .text:

00040244 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   40244:	06c001b4 	movhi	sp,6
    ori sp, sp, %lo(__alt_stack_pointer)
   40248:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
   4024c:	06800174 	movhi	gp,5
    ori gp, gp, %lo(_gp)
   40250:	d680fd14 	ori	gp,gp,1012
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   40254:	00800134 	movhi	r2,4
    ori r2, r2, %lo(__bss_start)
   40258:	10a1f514 	ori	r2,r2,34772

    movhi r3, %hi(__bss_end)
   4025c:	00c00134 	movhi	r3,4
    ori r3, r3, %lo(__bss_end)
   40260:	18e24314 	ori	r3,r3,35084

    beq r2, r3, 1f
   40264:	10c00326 	beq	r2,r3,40274 <_start+0x30>

0:
    stw zero, (r2)
   40268:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   4026c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   40270:	10fffd36 	bltu	r2,r3,40268 <__alt_data_end+0xfffd8268>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   40274:	00450200 	call	45020 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   40278:	00450a40 	call	450a4 <alt_main>

0004027c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   4027c:	003fff06 	br	4027c <__alt_data_end+0xfffd827c>

00040280 <altera_avalon_pwm_init>:

#include "altera_avalon_pwm_routines.h"


int altera_avalon_pwm_init(unsigned int address, unsigned int clock_divider, unsigned int duty_cycle)
{
   40280:	defffc04 	addi	sp,sp,-16
   40284:	df000315 	stw	fp,12(sp)
   40288:	df000304 	addi	fp,sp,12
   4028c:	e13ffd15 	stw	r4,-12(fp)
   40290:	e17ffe15 	stw	r5,-8(fp)
   40294:	e1bfff15 	stw	r6,-4(fp)
	if(duty_cycle > clock_divider)  //duty cycle reg must be less than or equal to clock divider
   40298:	e0bfff17 	ldw	r2,-4(fp)
   4029c:	e0fffe17 	ldw	r3,-8(fp)
   402a0:	1880022e 	bgeu	r3,r2,402ac <altera_avalon_pwm_init+0x2c>
	{
		return ALTERA_AVALON_PWM_DUTY_CYCLE_GREATER_THAN_CLOCK_CYCLE_ERROR;
   402a4:	00bfffc4 	movi	r2,-1
   402a8:	00000a06 	br	402d4 <altera_avalon_pwm_init+0x54>
	}
	else
	{
		IOWR_ALTERA_AVALON_PWM_CLOCK_DIVIDER(address, clock_divider - 1);
   402ac:	e0bffd17 	ldw	r2,-12(fp)
   402b0:	e0fffe17 	ldw	r3,-8(fp)
   402b4:	18ffffc4 	addi	r3,r3,-1
   402b8:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_PWM_DUTY_CYCLE(address, duty_cycle);
   402bc:	e0bffd17 	ldw	r2,-12(fp)
   402c0:	10800104 	addi	r2,r2,4
   402c4:	1007883a 	mov	r3,r2
   402c8:	e0bfff17 	ldw	r2,-4(fp)
   402cc:	18800035 	stwio	r2,0(r3)
	}
	 return ALTERA_AVALON_PWM_OK;
   402d0:	0005883a 	mov	r2,zero
}
   402d4:	e037883a 	mov	sp,fp
   402d8:	df000017 	ldw	fp,0(sp)
   402dc:	dec00104 	addi	sp,sp,4
   402e0:	f800283a 	ret

000402e4 <altera_avalon_pwm_enable>:

int altera_avalon_pwm_enable(unsigned int address)
{
   402e4:	defffe04 	addi	sp,sp,-8
   402e8:	df000115 	stw	fp,4(sp)
   402ec:	df000104 	addi	fp,sp,4
   402f0:	e13fff15 	stw	r4,-4(fp)
  IOWR_ALTERA_AVALON_PWM_ENABLE(address, ALTERA_AVALON_PWM_ENABLE_MSK);
   402f4:	e0bfff17 	ldw	r2,-4(fp)
   402f8:	10800204 	addi	r2,r2,8
   402fc:	1007883a 	mov	r3,r2
   40300:	00800044 	movi	r2,1
   40304:	18800035 	stwio	r2,0(r3)
  
  if(IORD_ALTERA_AVALON_PWM_ENABLE(address) != ALTERA_AVALON_PWM_ENABLED) //Confirm PWM is enabled
   40308:	e0bfff17 	ldw	r2,-4(fp)
   4030c:	10800204 	addi	r2,r2,8
   40310:	10800037 	ldwio	r2,0(r2)
   40314:	10800060 	cmpeqi	r2,r2,1
   40318:	1000021e 	bne	r2,zero,40324 <altera_avalon_pwm_enable+0x40>
  {
  	return ALTERA_AVALON_PWM_ENABLED_CONFIRMATION_ERROR;
   4031c:	00bfff84 	movi	r2,-2
   40320:	00000106 	br	40328 <altera_avalon_pwm_enable+0x44>
  }
  return ALTERA_AVALON_PWM_OK;
   40324:	0005883a 	mov	r2,zero
}
   40328:	e037883a 	mov	sp,fp
   4032c:	df000017 	ldw	fp,0(sp)
   40330:	dec00104 	addi	sp,sp,4
   40334:	f800283a 	ret

00040338 <altera_avalon_pwm_disable>:

int altera_avalon_pwm_disable(unsigned int address)
{
   40338:	defffe04 	addi	sp,sp,-8
   4033c:	df000115 	stw	fp,4(sp)
   40340:	df000104 	addi	fp,sp,4
   40344:	e13fff15 	stw	r4,-4(fp)
  IOWR_ALTERA_AVALON_PWM_ENABLE(address, ~ALTERA_AVALON_PWM_ENABLE_MSK);
   40348:	e0bfff17 	ldw	r2,-4(fp)
   4034c:	10800204 	addi	r2,r2,8
   40350:	1007883a 	mov	r3,r2
   40354:	00bfff84 	movi	r2,-2
   40358:	18800035 	stwio	r2,0(r3)

  if(IORD_ALTERA_AVALON_PWM_ENABLE(address) != ALTERA_AVALON_PWM_DISABLED)  //Confirm PWM is disabled 
   4035c:	e0bfff17 	ldw	r2,-4(fp)
   40360:	10800204 	addi	r2,r2,8
   40364:	10800037 	ldwio	r2,0(r2)
   40368:	10000226 	beq	r2,zero,40374 <altera_avalon_pwm_disable+0x3c>
  {
  	return ALTERA_AVALON_PWM_DISABLED_CONFIRMATION_ERROR;
   4036c:	00bfff44 	movi	r2,-3
   40370:	00000106 	br	40378 <altera_avalon_pwm_disable+0x40>
  }
  return ALTERA_AVALON_PWM_OK;
   40374:	0005883a 	mov	r2,zero
}
   40378:	e037883a 	mov	sp,fp
   4037c:	df000017 	ldw	fp,0(sp)
   40380:	dec00104 	addi	sp,sp,4
   40384:	f800283a 	ret

00040388 <altera_avalon_pwm_change_duty_cycle>:


int altera_avalon_pwm_change_duty_cycle(unsigned int address, unsigned int duty_cycle)
{
   40388:	defffd04 	addi	sp,sp,-12
   4038c:	df000215 	stw	fp,8(sp)
   40390:	df000204 	addi	fp,sp,8
   40394:	e13ffe15 	stw	r4,-8(fp)
   40398:	e17fff15 	stw	r5,-4(fp)
	if(duty_cycle > IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(address))  //duty cycle reg must be less than or equal to clock divider
   4039c:	e0bffe17 	ldw	r2,-8(fp)
   403a0:	10800037 	ldwio	r2,0(r2)
   403a4:	1007883a 	mov	r3,r2
   403a8:	e0bfff17 	ldw	r2,-4(fp)
   403ac:	1880022e 	bgeu	r3,r2,403b8 <altera_avalon_pwm_change_duty_cycle+0x30>
	{
		return ALTERA_AVALON_PWM_DUTY_CYCLE_GREATER_THAN_CLOCK_CYCLE_ERROR;
   403b0:	00bfffc4 	movi	r2,-1
   403b4:	00000606 	br	403d0 <altera_avalon_pwm_change_duty_cycle+0x48>
	}
	else
	{
    IOWR_ALTERA_AVALON_PWM_DUTY_CYCLE(address, duty_cycle);
   403b8:	e0bffe17 	ldw	r2,-8(fp)
   403bc:	10800104 	addi	r2,r2,4
   403c0:	1007883a 	mov	r3,r2
   403c4:	e0bfff17 	ldw	r2,-4(fp)
   403c8:	18800035 	stwio	r2,0(r3)
	}
  return ALTERA_AVALON_PWM_OK;
   403cc:	0005883a 	mov	r2,zero
}
   403d0:	e037883a 	mov	sp,fp
   403d4:	df000017 	ldw	fp,0(sp)
   403d8:	dec00104 	addi	sp,sp,4
   403dc:	f800283a 	ret

000403e0 <resetDisplay>:
#include "display.h"

void resetDisplay(void) {
   403e0:	deffff04 	addi	sp,sp,-4
   403e4:	df000015 	stw	fp,0(sp)
   403e8:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR1_BASE, RESET_DISPLAY_VALUE);
   403ec:	00c03004 	movi	r3,192
   403f0:	00800234 	movhi	r2,8
   403f4:	10841004 	addi	r2,r2,4160
   403f8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR0_BASE, RESET_DISPLAY_VALUE);
   403fc:	00c03004 	movi	r3,192
   40400:	00800234 	movhi	r2,8
   40404:	10843004 	addi	r2,r2,4288
   40408:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE1_BASE, RESET_DISPLAY_VALUE);
   4040c:	00c03004 	movi	r3,192
   40410:	00800234 	movhi	r2,8
   40414:	10841404 	addi	r2,r2,4176
   40418:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE0_BASE, RESET_DISPLAY_VALUE);
   4041c:	00c03004 	movi	r3,192
   40420:	00800234 	movhi	r2,8
   40424:	10842c04 	addi	r2,r2,4272
   40428:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND1_BASE, RESET_DISPLAY_VALUE);
   4042c:	00c03004 	movi	r3,192
   40430:	00800234 	movhi	r2,8
   40434:	10841804 	addi	r2,r2,4192
   40438:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND0_BASE, RESET_DISPLAY_VALUE);
   4043c:	00c03004 	movi	r3,192
   40440:	00800234 	movhi	r2,8
   40444:	10842804 	addi	r2,r2,4256
   40448:	10c00035 	stwio	r3,0(r2)
}
   4044c:	0001883a 	nop
   40450:	e037883a 	mov	sp,fp
   40454:	df000017 	ldw	fp,0(sp)
   40458:	dec00104 	addi	sp,sp,4
   4045c:	f800283a 	ret

00040460 <updateDisplay>:
bcd[2] = 512/100 = 5
bcd[1] = (512-5*100)/10 = 12/10 = 1
bcd[0] = (512 - (5*100 + 1*10))/1 = 2
*/
// for the moment, this is hard coded without any for loops
void updateDisplay(struct time time) {
   40460:	defffa04 	addi	sp,sp,-24
   40464:	dfc00515 	stw	ra,20(sp)
   40468:	df000415 	stw	fp,16(sp)
   4046c:	df000404 	addi	fp,sp,16
   40470:	e13fff15 	stw	r4,-4(fp)
  /* determine BCD values for hours, minutes, seconds...
  it's possible that the particular time struct member was set to a predefined
  DIGITS_OFF value, which signifies that the display should CLEAR the associated time unit digits..
  this is a sort of hacky way to check, but for right now it's fine.*/

  if (time.hour == DONT_DISPLAY) {
   40474:	e0bfff03 	ldbu	r2,-4(fp)
   40478:	10803fcc 	andi	r2,r2,255
   4047c:	10801918 	cmpnei	r2,r2,100
   40480:	1000051e 	bne	r2,zero,40498 <updateDisplay+0x38>
    bcd[5] = DIGITS_OFF;
   40484:	00800284 	movi	r2,10
   40488:	e0bffd45 	stb	r2,-11(fp)
    bcd[4] = DIGITS_OFF;
   4048c:	00800284 	movi	r2,10
   40490:	e0bffd05 	stb	r2,-12(fp)
   40494:	00000b06 	br	404c4 <updateDisplay+0x64>
  }
  else {
    bcd[5] = time.hour/10;
   40498:	e0bfff03 	ldbu	r2,-4(fp)
   4049c:	10803fcc 	andi	r2,r2,255
   404a0:	01400284 	movi	r5,10
   404a4:	1009883a 	mov	r4,r2
   404a8:	00431ec0 	call	431ec <__udivsi3>
   404ac:	e0bffd45 	stb	r2,-11(fp)
    bcd[4] = time.hour - bcd[5]*10;
   404b0:	e0bfff03 	ldbu	r2,-4(fp)
   404b4:	e0fffd43 	ldbu	r3,-11(fp)
   404b8:	18fffda4 	muli	r3,r3,-10
   404bc:	10c5883a 	add	r2,r2,r3
   404c0:	e0bffd05 	stb	r2,-12(fp)
  }
  if (time.minute == DONT_DISPLAY) {
   404c4:	e0bfff43 	ldbu	r2,-3(fp)
   404c8:	10803fcc 	andi	r2,r2,255
   404cc:	10801918 	cmpnei	r2,r2,100
   404d0:	1000051e 	bne	r2,zero,404e8 <updateDisplay+0x88>
    bcd[3] = DIGITS_OFF;
   404d4:	00800284 	movi	r2,10
   404d8:	e0bffcc5 	stb	r2,-13(fp)
    bcd[2] = DIGITS_OFF;
   404dc:	00800284 	movi	r2,10
   404e0:	e0bffc85 	stb	r2,-14(fp)
   404e4:	00000b06 	br	40514 <updateDisplay+0xb4>
  }
  else {
    bcd[3] = time.minute/10;
   404e8:	e0bfff43 	ldbu	r2,-3(fp)
   404ec:	10803fcc 	andi	r2,r2,255
   404f0:	01400284 	movi	r5,10
   404f4:	1009883a 	mov	r4,r2
   404f8:	00431ec0 	call	431ec <__udivsi3>
   404fc:	e0bffcc5 	stb	r2,-13(fp)
    bcd[2] = time.minute - bcd[3]*10;
   40500:	e0bfff43 	ldbu	r2,-3(fp)
   40504:	e0fffcc3 	ldbu	r3,-13(fp)
   40508:	18fffda4 	muli	r3,r3,-10
   4050c:	10c5883a 	add	r2,r2,r3
   40510:	e0bffc85 	stb	r2,-14(fp)
  }

  if (time.second == DONT_DISPLAY) {
   40514:	e0bfff83 	ldbu	r2,-2(fp)
   40518:	10803fcc 	andi	r2,r2,255
   4051c:	10801918 	cmpnei	r2,r2,100
   40520:	1000051e 	bne	r2,zero,40538 <updateDisplay+0xd8>
    bcd[1] = DIGITS_OFF;
   40524:	00800284 	movi	r2,10
   40528:	e0bffc45 	stb	r2,-15(fp)
    bcd[0] = DIGITS_OFF;
   4052c:	00800284 	movi	r2,10
   40530:	e0bffc05 	stb	r2,-16(fp)
   40534:	00000b06 	br	40564 <updateDisplay+0x104>
  }

  else {
    bcd[1] = time.second/10;
   40538:	e0bfff83 	ldbu	r2,-2(fp)
   4053c:	10803fcc 	andi	r2,r2,255
   40540:	01400284 	movi	r5,10
   40544:	1009883a 	mov	r4,r2
   40548:	00431ec0 	call	431ec <__udivsi3>
   4054c:	e0bffc45 	stb	r2,-15(fp)
    bcd[0] = time.second - bcd[1]*10;
   40550:	e0bfff83 	ldbu	r2,-2(fp)
   40554:	e0fffc43 	ldbu	r3,-15(fp)
   40558:	18fffda4 	muli	r3,r3,-10
   4055c:	10c5883a 	add	r2,r2,r3
   40560:	e0bffc05 	stb	r2,-16(fp)
  }

  // convert BCD values to LED segment values
  ledseg[5] = COM_ANODE_SEG_TABLE[(bcd[5])];
   40564:	e0bffd43 	ldbu	r2,-11(fp)
   40568:	10c03fcc 	andi	r3,r2,255
   4056c:	00800134 	movhi	r2,4
   40570:	10984b04 	addi	r2,r2,24876
   40574:	10c5883a 	add	r2,r2,r3
   40578:	10800003 	ldbu	r2,0(r2)
   4057c:	e0bffec5 	stb	r2,-5(fp)
  ledseg[4] = COM_ANODE_SEG_TABLE[(bcd[4])];
   40580:	e0bffd03 	ldbu	r2,-12(fp)
   40584:	10c03fcc 	andi	r3,r2,255
   40588:	00800134 	movhi	r2,4
   4058c:	10984b04 	addi	r2,r2,24876
   40590:	10c5883a 	add	r2,r2,r3
   40594:	10800003 	ldbu	r2,0(r2)
   40598:	e0bffe85 	stb	r2,-6(fp)
  ledseg[3] = COM_ANODE_SEG_TABLE[(bcd[3])];
   4059c:	e0bffcc3 	ldbu	r2,-13(fp)
   405a0:	10c03fcc 	andi	r3,r2,255
   405a4:	00800134 	movhi	r2,4
   405a8:	10984b04 	addi	r2,r2,24876
   405ac:	10c5883a 	add	r2,r2,r3
   405b0:	10800003 	ldbu	r2,0(r2)
   405b4:	e0bffe45 	stb	r2,-7(fp)
  ledseg[2] = COM_ANODE_SEG_TABLE[(bcd[2])];
   405b8:	e0bffc83 	ldbu	r2,-14(fp)
   405bc:	10c03fcc 	andi	r3,r2,255
   405c0:	00800134 	movhi	r2,4
   405c4:	10984b04 	addi	r2,r2,24876
   405c8:	10c5883a 	add	r2,r2,r3
   405cc:	10800003 	ldbu	r2,0(r2)
   405d0:	e0bffe05 	stb	r2,-8(fp)
  ledseg[1] = COM_ANODE_SEG_TABLE[(bcd[1])];
   405d4:	e0bffc43 	ldbu	r2,-15(fp)
   405d8:	10c03fcc 	andi	r3,r2,255
   405dc:	00800134 	movhi	r2,4
   405e0:	10984b04 	addi	r2,r2,24876
   405e4:	10c5883a 	add	r2,r2,r3
   405e8:	10800003 	ldbu	r2,0(r2)
   405ec:	e0bffdc5 	stb	r2,-9(fp)
  ledseg[0] = COM_ANODE_SEG_TABLE[(bcd[0])];
   405f0:	e0bffc03 	ldbu	r2,-16(fp)
   405f4:	10c03fcc 	andi	r3,r2,255
   405f8:	00800134 	movhi	r2,4
   405fc:	10984b04 	addi	r2,r2,24876
   40600:	10c5883a 	add	r2,r2,r3
   40604:	10800003 	ldbu	r2,0(r2)
   40608:	e0bffd85 	stb	r2,-10(fp)

  // write to display port
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR1_BASE, ledseg[5]);
   4060c:	e0bffec3 	ldbu	r2,-5(fp)
   40610:	10c03fcc 	andi	r3,r2,255
   40614:	00800234 	movhi	r2,8
   40618:	10841004 	addi	r2,r2,4160
   4061c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HOUR0_BASE, ledseg[4]);
   40620:	e0bffe83 	ldbu	r2,-6(fp)
   40624:	10c03fcc 	andi	r3,r2,255
   40628:	00800234 	movhi	r2,8
   4062c:	10843004 	addi	r2,r2,4288
   40630:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE1_BASE, ledseg[3]);
   40634:	e0bffe43 	ldbu	r2,-7(fp)
   40638:	10c03fcc 	andi	r3,r2,255
   4063c:	00800234 	movhi	r2,8
   40640:	10841404 	addi	r2,r2,4176
   40644:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(MINUTE0_BASE, ledseg[2]);
   40648:	e0bffe03 	ldbu	r2,-8(fp)
   4064c:	10c03fcc 	andi	r3,r2,255
   40650:	00800234 	movhi	r2,8
   40654:	10842c04 	addi	r2,r2,4272
   40658:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND1_BASE, ledseg[1]);
   4065c:	e0bffdc3 	ldbu	r2,-9(fp)
   40660:	10c03fcc 	andi	r3,r2,255
   40664:	00800234 	movhi	r2,8
   40668:	10841804 	addi	r2,r2,4192
   4066c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(SECOND0_BASE, ledseg[0]);
   40670:	e0bffd83 	ldbu	r2,-10(fp)
   40674:	10c03fcc 	andi	r3,r2,255
   40678:	00800234 	movhi	r2,8
   4067c:	10842804 	addi	r2,r2,4256
   40680:	10c00035 	stwio	r3,0(r2)
   40684:	0001883a 	nop
   40688:	e037883a 	mov	sp,fp
   4068c:	dfc00117 	ldw	ra,4(sp)
   40690:	df000017 	ldw	fp,0(sp)
   40694:	dec00204 	addi	sp,sp,8
   40698:	f800283a 	ret

0004069c <timerSecondRegisterISR>:

/* this registration functions receives a pointer to an ISR function which takes
in a pointer to a data structure (isr_context) as a parameter, and does not
return any value (void). ISRFunction() will be called once the timerSecond
interrupt fires, and this ISR resides in main.c */
uint8_t timerSecondRegisterISR(void (*timerSecondISR)(void *isr_context)) {
   4069c:	defffb04 	addi	sp,sp,-20
   406a0:	dfc00415 	stw	ra,16(sp)
   406a4:	df000315 	stw	fp,12(sp)
   406a8:	df000304 	addi	fp,sp,12
   406ac:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(TIMER_SECOND_IRQ_INTERRUPT_CONTROLLER_ID,
   406b0:	d8000015 	stw	zero,0(sp)
   406b4:	000f883a 	mov	r7,zero
   406b8:	e1bfff17 	ldw	r6,-4(fp)
   406bc:	01400044 	movi	r5,1
   406c0:	0009883a 	mov	r4,zero
   406c4:	0044d180 	call	44d18 <alt_ic_isr_register>
   406c8:	e0bffe05 	stb	r2,-8(fp)
                                            TIMER_SECOND_IRQ,
                                            timerSecondISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   406cc:	e0bffe03 	ldbu	r2,-8(fp)
}
   406d0:	e037883a 	mov	sp,fp
   406d4:	dfc00117 	ldw	ra,4(sp)
   406d8:	df000017 	ldw	fp,0(sp)
   406dc:	dec00204 	addi	sp,sp,8
   406e0:	f800283a 	ret

000406e4 <timerSecondEnableInterrupt>:

void timerSecondEnableInterrupt(void) {
   406e4:	deffff04 	addi	sp,sp,-4
   406e8:	df000015 	stw	fp,0(sp)
   406ec:	d839883a 	mov	fp,sp
 IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_SECOND_BASE,
   406f0:	00c001c4 	movi	r3,7
   406f4:	00800234 	movhi	r2,8
   406f8:	10840904 	addi	r2,r2,4132
   406fc:	10c00035 	stwio	r3,0(r2)
                 ALTERA_AVALON_TIMER_CONTROL_CONT_MSK  
               | ALTERA_AVALON_TIMER_CONTROL_START_MSK
               | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
}
   40700:	0001883a 	nop
   40704:	e037883a 	mov	sp,fp
   40708:	df000017 	ldw	fp,0(sp)
   4070c:	dec00104 	addi	sp,sp,4
   40710:	f800283a 	ret

00040714 <switchesRegisterISR>:

uint8_t switchesRegisterISR(void (*switchesISR)(void *isr_context)) {
   40714:	defffb04 	addi	sp,sp,-20
   40718:	dfc00415 	stw	ra,16(sp)
   4071c:	df000315 	stw	fp,12(sp)
   40720:	df000304 	addi	fp,sp,12
   40724:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(SWITCHES_IRQ_INTERRUPT_CONTROLLER_ID,
   40728:	d8000015 	stw	zero,0(sp)
   4072c:	000f883a 	mov	r7,zero
   40730:	e1bfff17 	ldw	r6,-4(fp)
   40734:	01400084 	movi	r5,2
   40738:	0009883a 	mov	r4,zero
   4073c:	0044d180 	call	44d18 <alt_ic_isr_register>
   40740:	e0bffe05 	stb	r2,-8(fp)
                                            SWITCHES_IRQ,
                                            switchesISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   40744:	e0bffe03 	ldbu	r2,-8(fp)
}
   40748:	e037883a 	mov	sp,fp
   4074c:	dfc00117 	ldw	ra,4(sp)
   40750:	df000017 	ldw	fp,0(sp)
   40754:	dec00204 	addi	sp,sp,8
   40758:	f800283a 	ret

0004075c <buttonsRegisterISR>:


uint8_t buttonsRegisterISR(void (*buttonsISR)(void *isr_context)) {
   4075c:	defffb04 	addi	sp,sp,-20
   40760:	dfc00415 	stw	ra,16(sp)
   40764:	df000315 	stw	fp,12(sp)
   40768:	df000304 	addi	fp,sp,12
   4076c:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(BUTTONS_IRQ_INTERRUPT_CONTROLLER_ID,
   40770:	d8000015 	stw	zero,0(sp)
   40774:	000f883a 	mov	r7,zero
   40778:	e1bfff17 	ldw	r6,-4(fp)
   4077c:	014000c4 	movi	r5,3
   40780:	0009883a 	mov	r4,zero
   40784:	0044d180 	call	44d18 <alt_ic_isr_register>
   40788:	e0bffe05 	stb	r2,-8(fp)
                                            BUTTONS_IRQ,
                                            buttonsISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   4078c:	e0bffe03 	ldbu	r2,-8(fp)
}
   40790:	e037883a 	mov	sp,fp
   40794:	dfc00117 	ldw	ra,4(sp)
   40798:	df000017 	ldw	fp,0(sp)
   4079c:	dec00204 	addi	sp,sp,8
   407a0:	f800283a 	ret

000407a4 <switchesEnableInterrupt>:


void switchesEnableInterrupt(void) {
   407a4:	deffff04 	addi	sp,sp,-4
   407a8:	df000015 	stw	fp,0(sp)
   407ac:	d839883a 	mov	fp,sp
  // enable all switches to fire interupts
  IOWR_ALTERA_AVALON_PIO_IRQ_MASK(SWITCHES_BASE, SWITCHES_INTERRUPT_MASK);
   407b0:	00ffffd4 	movui	r3,65535
   407b4:	00800234 	movhi	r2,8
   407b8:	10843a04 	addi	r2,r2,4328
   407bc:	10c00035 	stwio	r3,0(r2)
  
  // reset the edge capture register
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(SWITCHES_BASE, 0);
   407c0:	0007883a 	mov	r3,zero
   407c4:	00800234 	movhi	r2,8
   407c8:	10843b04 	addi	r2,r2,4332
   407cc:	10c00035 	stwio	r3,0(r2)
}
   407d0:	0001883a 	nop
   407d4:	e037883a 	mov	sp,fp
   407d8:	df000017 	ldw	fp,0(sp)
   407dc:	dec00104 	addi	sp,sp,4
   407e0:	f800283a 	ret

000407e4 <buttonsEnableInterrupt>:

void buttonsEnableInterrupt(void) {
   407e4:	deffff04 	addi	sp,sp,-4
   407e8:	df000015 	stw	fp,0(sp)
   407ec:	d839883a 	mov	fp,sp
  // enable all buttons to fire interupts
  IOWR_ALTERA_AVALON_PIO_IRQ_MASK(BUTTONS_BASE, BUTTONS_INTERRUPT_MASK);
   407f0:	00c000c4 	movi	r3,3
   407f4:	00800234 	movhi	r2,8
   407f8:	10841e04 	addi	r2,r2,4216
   407fc:	10c00035 	stwio	r3,0(r2)
  
  // reset the edge capture register
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   40800:	0007883a 	mov	r3,zero
   40804:	00800234 	movhi	r2,8
   40808:	10841f04 	addi	r2,r2,4220
   4080c:	10c00035 	stwio	r3,0(r2)
}
   40810:	0001883a 	nop
   40814:	e037883a 	mov	sp,fp
   40818:	df000017 	ldw	fp,0(sp)
   4081c:	dec00104 	addi	sp,sp,4
   40820:	f800283a 	ret

00040824 <timerPWMRegisterISR>:


uint8_t timerPWMRegisterISR(void (*timerPWMISR)(void *isr_context)) {
   40824:	defffb04 	addi	sp,sp,-20
   40828:	dfc00415 	stw	ra,16(sp)
   4082c:	df000315 	stw	fp,12(sp)
   40830:	df000304 	addi	fp,sp,12
   40834:	e13fff15 	stw	r4,-4(fp)
  uint8_t isr_register_status;

  isr_register_status = alt_ic_isr_register(TIMER_PWM_IRQ_INTERRUPT_CONTROLLER_ID,
   40838:	d8000015 	stw	zero,0(sp)
   4083c:	000f883a 	mov	r7,zero
   40840:	e1bfff17 	ldw	r6,-4(fp)
   40844:	01400104 	movi	r5,4
   40848:	0009883a 	mov	r4,zero
   4084c:	0044d180 	call	44d18 <alt_ic_isr_register>
   40850:	e0bffe05 	stb	r2,-8(fp)
                                            TIMER_PWM_IRQ,
                                            timerPWMISR,
                                            NULL,
                                            0x0);
  return isr_register_status;
   40854:	e0bffe03 	ldbu	r2,-8(fp)
}
   40858:	e037883a 	mov	sp,fp
   4085c:	dfc00117 	ldw	ra,4(sp)
   40860:	df000017 	ldw	fp,0(sp)
   40864:	dec00204 	addi	sp,sp,8
   40868:	f800283a 	ret

0004086c <timerPWMEnableInterrupt>:

void timerPWMEnableInterrupt(int timeout) {
   4086c:	defffd04 	addi	sp,sp,-12
   40870:	df000215 	stw	fp,8(sp)
   40874:	df000204 	addi	fp,sp,8
   40878:	e13fff15 	stw	r4,-4(fp)
  // timeout is in miliseconds -> convert to seconds
  // set period based on input timeout variable; writing to the period 
  // registers stops the counter which automatically loads reigster value
  uint32_t period = (NIOS_CLOCK_FREQ/1000)*timeout;
   4087c:	e0ffff17 	ldw	r3,-4(fp)
   40880:	00b0d414 	movui	r2,50000
   40884:	1885383a 	mul	r2,r3,r2
   40888:	e0bffe15 	stw	r2,-8(fp)

  //write to high and low registers
  IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_PWM_BASE, period);
   4088c:	e0fffe17 	ldw	r3,-8(fp)
   40890:	00800234 	movhi	r2,8
   40894:	10840204 	addi	r2,r2,4104
   40898:	10c00035 	stwio	r3,0(r2)
  // shift by 16 to take into account high bits
  IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_PWM_BASE, (period >> AVALON_TIMER_PERIOD_WIDTH));
   4089c:	e0bffe17 	ldw	r2,-8(fp)
   408a0:	1004d43a 	srli	r2,r2,16
   408a4:	1007883a 	mov	r3,r2
   408a8:	00800234 	movhi	r2,8
   408ac:	10840304 	addi	r2,r2,4108
   408b0:	10c00035 	stwio	r3,0(r2)

  // start timer and enable interrupt
  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_PWM_BASE, 
   408b4:	00c00144 	movi	r3,5
   408b8:	00800234 	movhi	r2,8
   408bc:	10840104 	addi	r2,r2,4100
   408c0:	10c00035 	stwio	r3,0(r2)
                 ALTERA_AVALON_TIMER_CONTROL_START_MSK
               | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
}
   408c4:	0001883a 	nop
   408c8:	e037883a 	mov	sp,fp
   408cc:	df000017 	ldw	fp,0(sp)
   408d0:	dec00104 	addi	sp,sp,4
   408d4:	f800283a 	ret

000408d8 <timerPWMDisableInterrupt>:

void timerPWMDisableInterrupt(void) {
   408d8:	deffff04 	addi	sp,sp,-4
   408dc:	df000015 	stw	fp,0(sp)
   408e0:	d839883a 	mov	fp,sp
  // set ITO to 0 (thus disabling interrupts)
  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_PWM_BASE, 0);
   408e4:	0007883a 	mov	r3,zero
   408e8:	00800234 	movhi	r2,8
   408ec:	10840104 	addi	r2,r2,4100
   408f0:	10c00035 	stwio	r3,0(r2)
}
   408f4:	0001883a 	nop
   408f8:	e037883a 	mov	sp,fp
   408fc:	df000017 	ldw	fp,0(sp)
   40900:	dec00104 	addi	sp,sp,4
   40904:	f800283a 	ret

00040908 <alarmLEDoff>:
#include "led.h"

void alarmLEDoff(void) {
   40908:	deffff04 	addi	sp,sp,-4
   4090c:	df000015 	stw	fp,0(sp)
   40910:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, LED_OFF);
   40914:	0007883a 	mov	r3,zero
   40918:	00800234 	movhi	r2,8
   4091c:	10842404 	addi	r2,r2,4240
   40920:	10c00035 	stwio	r3,0(r2)
}
   40924:	0001883a 	nop
   40928:	e037883a 	mov	sp,fp
   4092c:	df000017 	ldw	fp,0(sp)
   40930:	dec00104 	addi	sp,sp,4
   40934:	f800283a 	ret

00040938 <alarmLEDon>:

void alarmLEDon(void) {
   40938:	deffff04 	addi	sp,sp,-4
   4093c:	df000015 	stw	fp,0(sp)
   40940:	d839883a 	mov	fp,sp
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, LED_ON);
   40944:	00c00044 	movi	r3,1
   40948:	00800234 	movhi	r2,8
   4094c:	10842404 	addi	r2,r2,4240
   40950:	10c00035 	stwio	r3,0(r2)
}
   40954:	0001883a 	nop
   40958:	e037883a 	mov	sp,fp
   4095c:	df000017 	ldw	fp,0(sp)
   40960:	dec00104 	addi	sp,sp,4
   40964:	f800283a 	ret

00040968 <alarmLEDtoggle>:

void alarmLEDtoggle(void) {
   40968:	defffe04 	addi	sp,sp,-8
   4096c:	df000115 	stw	fp,4(sp)
   40970:	df000104 	addi	fp,sp,4
  volatile uint8_t led_state;
  led_state = IORD_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE);
   40974:	00800234 	movhi	r2,8
   40978:	10842404 	addi	r2,r2,4240
   4097c:	10800037 	ldwio	r2,0(r2)
   40980:	e0bfff05 	stb	r2,-4(fp)
  IOWR_ALTERA_AVALON_PIO_DATA(LED_ALARM_BASE, !led_state);
   40984:	e0bfff03 	ldbu	r2,-4(fp)
   40988:	10803fcc 	andi	r2,r2,255
   4098c:	1005003a 	cmpeq	r2,r2,zero
   40990:	10c03fcc 	andi	r3,r2,255
   40994:	00800234 	movhi	r2,8
   40998:	10842404 	addi	r2,r2,4240
   4099c:	10c00035 	stwio	r3,0(r2)
   409a0:	0001883a 	nop
   409a4:	e037883a 	mov	sp,fp
   409a8:	df000017 	ldw	fp,0(sp)
   409ac:	dec00104 	addi	sp,sp,4
   409b0:	f800283a 	ret

000409b4 <main>:
/* the mode struct is global so that the callback functions 
in main.c can access it and determine the appropiate courses
of action */
struct mode mode;

int main(void) {
   409b4:	defffe04 	addi	sp,sp,-8
   409b8:	dfc00115 	stw	ra,4(sp)
   409bc:	df000015 	stw	fp,0(sp)
   409c0:	d839883a 	mov	fp,sp

  // initialization to "CLOCK" mode
  mode.invalid = FALSE;
   409c4:	d020f805 	stb	zero,-31776(gp)
  mode.display = DISP_CLOCK;
   409c8:	d020f845 	stb	zero,-31775(gp)
  mode.alarm = OFF;
   409cc:	d020f885 	stb	zero,-31774(gp)
  mode.config.on = FALSE;
   409d0:	d020f8c5 	stb	zero,-31773(gp)
  mode.config.hour = FALSE;
   409d4:	d020f905 	stb	zero,-31772(gp)
  mode.config.minute = FALSE;
   409d8:	d020f945 	stb	zero,-31771(gp)

  alarmLEDoff();
   409dc:	00409080 	call	40908 <alarmLEDoff>
  resetClockTime();
   409e0:	00427dc0 	call	427dc <resetClockTime>
  resetAlarmTime();
   409e4:	0042d1c0 	call	42d1c <resetAlarmTime>
  resetDisplay();
   409e8:	00403e00 	call	403e0 <resetDisplay>

  /* the callback ISR is passed in for the registration. When the timer peripheral
  fires its interrupt, timerSecondISR() will be called
  timerSecondISR can be preceded with or without & (both pass in the function address); 
  because a function’s name can also be used to get function's address */
  if (timerSecondRegisterISR(&timerSecondISR) == ISR_REGISTRATION_SUCCESS) {
   409ec:	01000134 	movhi	r4,4
   409f0:	2102af04 	addi	r4,r4,2748
   409f4:	004069c0 	call	4069c <timerSecondRegisterISR>
   409f8:	10803fcc 	andi	r2,r2,255
   409fc:	1000051e 	bne	r2,zero,40a14 <main+0x60>
    printf("timerSecondISR successively registered!\n");
   40a00:	01000134 	movhi	r4,4
   40a04:	21184e04 	addi	r4,r4,24888
   40a08:	004462c0 	call	4462c <puts>
    timerSecondEnableInterrupt();
   40a0c:	00406e40 	call	406e4 <timerSecondEnableInterrupt>
   40a10:	00000306 	br	40a20 <main+0x6c>
  }
  else {
   printf("ERROR: timerSecondISR unsuccessively registered!\n");
   40a14:	01000134 	movhi	r4,4
   40a18:	21185804 	addi	r4,r4,24928
   40a1c:	004462c0 	call	4462c <puts>
  }

  if (switchesRegisterISR(&switchesISR) == ISR_REGISTRATION_SUCCESS) {
   40a20:	01000134 	movhi	r4,4
   40a24:	21033b04 	addi	r4,r4,3308
   40a28:	00407140 	call	40714 <switchesRegisterISR>
   40a2c:	10803fcc 	andi	r2,r2,255
   40a30:	1000051e 	bne	r2,zero,40a48 <main+0x94>
    printf("switchesISR successively registered!\n");
   40a34:	01000134 	movhi	r4,4
   40a38:	21186504 	addi	r4,r4,24980
   40a3c:	004462c0 	call	4462c <puts>
    switchesEnableInterrupt();
   40a40:	00407a40 	call	407a4 <switchesEnableInterrupt>
   40a44:	00000306 	br	40a54 <main+0xa0>
  }
  else {
   printf("ERROR: switchesISR unsuccessively registered!\n");
   40a48:	01000134 	movhi	r4,4
   40a4c:	21186f04 	addi	r4,r4,25020
   40a50:	004462c0 	call	4462c <puts>
  }

  if (buttonsRegisterISR(&buttonsISR) == ISR_REGISTRATION_SUCCESS) {
   40a54:	01000134 	movhi	r4,4
   40a58:	2103ec04 	addi	r4,r4,4016
   40a5c:	004075c0 	call	4075c <buttonsRegisterISR>
   40a60:	10803fcc 	andi	r2,r2,255
   40a64:	1000051e 	bne	r2,zero,40a7c <main+0xc8>
    printf("buttonsISR successively registered!\n");
   40a68:	01000134 	movhi	r4,4
   40a6c:	21187b04 	addi	r4,r4,25068
   40a70:	004462c0 	call	4462c <puts>
    buttonsEnableInterrupt();
   40a74:	00407e40 	call	407e4 <buttonsEnableInterrupt>
   40a78:	00000306 	br	40a88 <main+0xd4>
  }
  else {
   printf("ERROR: buttonsISR unsuccessively registered!\n");
   40a7c:	01000134 	movhi	r4,4
   40a80:	21188404 	addi	r4,r4,25104
   40a84:	004462c0 	call	4462c <puts>
  }

  if (timerPWMRegisterISR(&timerPWMISR) == ISR_REGISTRATION_SUCCESS) {
   40a88:	01000134 	movhi	r4,4
   40a8c:	21050004 	addi	r4,r4,5120
   40a90:	00408240 	call	40824 <timerPWMRegisterISR>
   40a94:	10803fcc 	andi	r2,r2,255
   40a98:	1000041e 	bne	r2,zero,40aac <main+0xf8>
    printf("timerPWMISR successively registered!\n");
   40a9c:	01000134 	movhi	r4,4
   40aa0:	21189004 	addi	r4,r4,25152
   40aa4:	004462c0 	call	4462c <puts>
   40aa8:	00000306 	br	40ab8 <main+0x104>
  }
  else {
   printf("ERROR: timerPWMISR unsuccessively registered!\n");
   40aac:	01000134 	movhi	r4,4
   40ab0:	21189a04 	addi	r4,r4,25192
   40ab4:	004462c0 	call	4462c <puts>
  }



  while(1) {}  
   40ab8:	003fff06 	br	40ab8 <__alt_data_end+0xfffd8ab8>

00040abc <timerSecondISR>:


/* This is the main ISR that is called whenever the second timer fires its interrupt. 
This ISR lets us update the time of the clock and depending on whether or not the user
is in config mode, carry the time digits. */
void timerSecondISR(void* isr_context) {
   40abc:	defff804 	addi	sp,sp,-32
   40ac0:	dfc00715 	stw	ra,28(sp)
   40ac4:	df000615 	stw	fp,24(sp)
   40ac8:	df000604 	addi	fp,sp,24
   40acc:	e13fff15 	stw	r4,-4(fp)

  /* The TO (timeout) bit is set to 1 when the internal counter reaches zero. Once set by a
  timeout event, the TO bit stays set until explicitly cleared by a master peripheral. 
  The TO bit is cleared by writing 0 to the status register. */
  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_SECOND_BASE, 0);
   40ad0:	0007883a 	mov	r3,zero
   40ad4:	00800234 	movhi	r2,8
   40ad8:	10840804 	addi	r2,r2,4128
   40adc:	10c00035 	stwio	r3,0(r2)

  // temporary time struct for data transfer between modules and printf debugging
  struct time clock;
 
  if (mode.display == DISP_CLOCK) {
   40ae0:	d0a0f843 	ldbu	r2,-31775(gp)
   40ae4:	10803fcc 	andi	r2,r2,255
   40ae8:	1000611e 	bne	r2,zero,40c70 <timerSecondISR+0x1b4>

    if (mode.config.on == TRUE) {
   40aec:	d0a0f8c3 	ldbu	r2,-31773(gp)
   40af0:	10803fcc 	andi	r2,r2,255
   40af4:	10800058 	cmpnei	r2,r2,1
   40af8:	10000e1e 	bne	r2,zero,40b34 <timerSecondISR+0x78>
      // since we're in config, we don't want to carry the digits
      clock = upClockSecond(CARRY_OFF);
   40afc:	0009883a 	mov	r4,zero
   40b00:	00428980 	call	42898 <upClockSecond>
   40b04:	e0bffa05 	stb	r2,-24(fp)
   40b08:	1006d23a 	srli	r3,r2,8
   40b0c:	1809883a 	mov	r4,r3
   40b10:	00ffffc4 	movi	r3,-1
   40b14:	20c6703a 	and	r3,r4,r3
   40b18:	e0fffa45 	stb	r3,-23(fp)
   40b1c:	1004d43a 	srli	r2,r2,16
   40b20:	1007883a 	mov	r3,r2
   40b24:	00bfffc4 	movi	r2,-1
   40b28:	1884703a 	and	r2,r3,r2
   40b2c:	e0bffa85 	stb	r2,-22(fp)
   40b30:	00004c06 	br	40c64 <timerSecondISR+0x1a8>
    }
    else if (mode.config.on == FALSE) {
   40b34:	d0a0f8c3 	ldbu	r2,-31773(gp)
   40b38:	10803fcc 	andi	r2,r2,255
   40b3c:	1000461e 	bne	r2,zero,40c58 <timerSecondISR+0x19c>

      /* since we're not in config, the time should normally count and carry.
      This also means that if the alarm is turned ON, we need to check if it */
      clock = upClockSecond(CARRY_ON);
   40b40:	01000044 	movi	r4,1
   40b44:	00428980 	call	42898 <upClockSecond>
   40b48:	e0bffa05 	stb	r2,-24(fp)
   40b4c:	1006d23a 	srli	r3,r2,8
   40b50:	1809883a 	mov	r4,r3
   40b54:	00ffffc4 	movi	r3,-1
   40b58:	20c6703a 	and	r3,r4,r3
   40b5c:	e0fffa45 	stb	r3,-23(fp)
   40b60:	1004d43a 	srli	r2,r2,16
   40b64:	1007883a 	mov	r3,r2
   40b68:	00bfffc4 	movi	r2,-1
   40b6c:	1884703a 	and	r2,r3,r2
   40b70:	e0bffa85 	stb	r2,-22(fp)

      if (mode.alarm == ON) {
   40b74:	d0a0f883 	ldbu	r2,-31774(gp)
   40b78:	10803fcc 	andi	r2,r2,255
   40b7c:	10800058 	cmpnei	r2,r2,1
   40b80:	1000381e 	bne	r2,zero,40c64 <timerSecondISR+0x1a8>
        // however, we do need to check whether or not the alarm should go off
        struct time alarm;
        alarm = getAlarmTime();
   40b84:	0042d500 	call	42d50 <getAlarmTime>
   40b88:	e0bffac5 	stb	r2,-21(fp)
   40b8c:	1006d23a 	srli	r3,r2,8
   40b90:	1809883a 	mov	r4,r3
   40b94:	00ffffc4 	movi	r3,-1
   40b98:	20c6703a 	and	r3,r4,r3
   40b9c:	e0fffb05 	stb	r3,-20(fp)
   40ba0:	1004d43a 	srli	r2,r2,16
   40ba4:	1007883a 	mov	r3,r2
   40ba8:	00bfffc4 	movi	r2,-1
   40bac:	1884703a 	and	r2,r3,r2
   40bb0:	e0bffb45 	stb	r2,-19(fp)

        /* to avoid executing the following block of code everytime and to only call playSong() once, 
        we have to check whether or not the time is currently at XX:XX:00. 
        At 0 seconds, thats when the alarm will be activated */
        if ( (clock.second == 0) && (alarm.hour == clock.hour) && (alarm.minute == clock.minute) ) {
   40bb4:	e0bffa83 	ldbu	r2,-22(fp)
   40bb8:	10803fcc 	andi	r2,r2,255
   40bbc:	1000291e 	bne	r2,zero,40c64 <timerSecondISR+0x1a8>
   40bc0:	e0fffac3 	ldbu	r3,-21(fp)
   40bc4:	e0bffa03 	ldbu	r2,-24(fp)
   40bc8:	18c03fcc 	andi	r3,r3,255
   40bcc:	10803fcc 	andi	r2,r2,255
   40bd0:	1880241e 	bne	r3,r2,40c64 <timerSecondISR+0x1a8>
   40bd4:	e0fffb03 	ldbu	r3,-20(fp)
   40bd8:	e0bffa43 	ldbu	r2,-23(fp)
   40bdc:	18c03fcc 	andi	r3,r3,255
   40be0:	10803fcc 	andi	r2,r2,255
   40be4:	18801f1e 	bne	r3,r2,40c64 <timerSecondISR+0x1a8>
          // start the alarm!
          struct note_info note;
          note = playSong();
   40be8:	e0bffc04 	addi	r2,fp,-16
   40bec:	1009883a 	mov	r4,r2
   40bf0:	0041b2c0 	call	41b2c <playSong>

          printf("BEEP! BEEP! BEEP! Alarm has gone off...\n");
   40bf4:	01000134 	movhi	r4,4
   40bf8:	2118a604 	addi	r4,r4,25240
   40bfc:	004462c0 	call	4462c <puts>
          printf("note.frequency == %d\n",note.frequency);
   40c00:	e0bffc17 	ldw	r2,-16(fp)
   40c04:	100b883a 	mov	r5,r2
   40c08:	01000134 	movhi	r4,4
   40c0c:	2118b004 	addi	r4,r4,25280
   40c10:	00445600 	call	44560 <printf>
          printf("note.duration == %d\n",note.duration);
   40c14:	e0bffd17 	ldw	r2,-12(fp)
   40c18:	100b883a 	mov	r5,r2
   40c1c:	01000134 	movhi	r4,4
   40c20:	2118b604 	addi	r4,r4,25304
   40c24:	00445600 	call	44560 <printf>
          printf("note.endofsong == %d\n",note.endofsong);
   40c28:	e0bffe17 	ldw	r2,-8(fp)
   40c2c:	100b883a 	mov	r5,r2
   40c30:	01000134 	movhi	r4,4
   40c34:	2118bc04 	addi	r4,r4,25328
   40c38:	00445600 	call	44560 <printf>
          writePWM(note.frequency);
   40c3c:	e0bffc17 	ldw	r2,-16(fp)
   40c40:	1009883a 	mov	r4,r2
   40c44:	00416b40 	call	416b4 <writePWM>
          timerPWMEnableInterrupt(note.duration);
   40c48:	e0bffd17 	ldw	r2,-12(fp)
   40c4c:	1009883a 	mov	r4,r2
   40c50:	004086c0 	call	4086c <timerPWMEnableInterrupt>
   40c54:	00000306 	br	40c64 <timerSecondISR+0x1a8>
        }
      }

    }
    else {
      printf("ERROR: mode.config.on has an invalid value\n");
   40c58:	01000134 	movhi	r4,4
   40c5c:	2118c204 	addi	r4,r4,25352
   40c60:	004462c0 	call	4462c <puts>
    }

    // since the time is being displayed, we'll have to update the display
    updateDisplay(clock);
   40c64:	e13ffa17 	ldw	r4,-24(fp)
   40c68:	00404600 	call	40460 <updateDisplay>
   40c6c:	00000d06 	br	40ca4 <timerSecondISR+0x1e8>

  }
  else {
    // since the current time is not being displayed, we don't update the display
    clock = upClockSecond(CARRY_ON);
   40c70:	01000044 	movi	r4,1
   40c74:	00428980 	call	42898 <upClockSecond>
   40c78:	e0bffa05 	stb	r2,-24(fp)
   40c7c:	1006d23a 	srli	r3,r2,8
   40c80:	1809883a 	mov	r4,r3
   40c84:	00ffffc4 	movi	r3,-1
   40c88:	20c6703a 	and	r3,r4,r3
   40c8c:	e0fffa45 	stb	r3,-23(fp)
   40c90:	1004d43a 	srli	r2,r2,16
   40c94:	1007883a 	mov	r3,r2
   40c98:	00bfffc4 	movi	r2,-1
   40c9c:	1884703a 	and	r2,r3,r2
   40ca0:	e0bffa85 	stb	r2,-22(fp)
  }

  // for debugging purposes:
  printf("The clock time is currently: %d:%d:%d\n",clock.hour,clock.minute,clock.second);
   40ca4:	e0bffa03 	ldbu	r2,-24(fp)
   40ca8:	10803fcc 	andi	r2,r2,255
   40cac:	e0fffa43 	ldbu	r3,-23(fp)
   40cb0:	18c03fcc 	andi	r3,r3,255
   40cb4:	e13ffa83 	ldbu	r4,-22(fp)
   40cb8:	21003fcc 	andi	r4,r4,255
   40cbc:	200f883a 	mov	r7,r4
   40cc0:	180d883a 	mov	r6,r3
   40cc4:	100b883a 	mov	r5,r2
   40cc8:	01000134 	movhi	r4,4
   40ccc:	2118cd04 	addi	r4,r4,25396
   40cd0:	00445600 	call	44560 <printf>
}
   40cd4:	0001883a 	nop
   40cd8:	e037883a 	mov	sp,fp
   40cdc:	dfc00117 	ldw	ra,4(sp)
   40ce0:	df000017 	ldw	fp,0(sp)
   40ce4:	dec00204 	addi	sp,sp,8
   40ce8:	f800283a 	ret

00040cec <switchesISR>:


/* This ISR lets us determine what mode the user is currently requesting.
Once this mode is determined, the system will update the display to match what was requested,
and perform other actions such as turn on/off the alarm and on/off a song*/
void switchesISR(void* isr_context) {
   40cec:	defff704 	addi	sp,sp,-36
   40cf0:	dfc00815 	stw	ra,32(sp)
   40cf4:	df000715 	stw	fp,28(sp)
   40cf8:	df000704 	addi	fp,sp,28
   40cfc:	e13fff15 	stw	r4,-4(fp)

  // reset edge capture register by writing to it 
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(SWITCHES_BASE, 0);
   40d00:	0007883a 	mov	r3,zero
   40d04:	00800234 	movhi	r2,8
   40d08:	10843b04 	addi	r2,r2,4332
   40d0c:	10c00035 	stwio	r3,0(r2)

  /* temporary mode struct for data transfer between modules and for testing
  the requested mode based on the switches state */
  struct mode mode_request;

  mode_request = determineMode();
   40d10:	00424800 	call	42480 <determineMode>
   40d14:	1009883a 	mov	r4,r2
   40d18:	180b883a 	mov	r5,r3
   40d1c:	e13ff905 	stb	r4,-28(fp)
   40d20:	2004d23a 	srli	r2,r4,8
   40d24:	1007883a 	mov	r3,r2
   40d28:	00bfffc4 	movi	r2,-1
   40d2c:	1884703a 	and	r2,r3,r2
   40d30:	e0bff945 	stb	r2,-27(fp)
   40d34:	2004d43a 	srli	r2,r4,16
   40d38:	1007883a 	mov	r3,r2
   40d3c:	00bfffc4 	movi	r2,-1
   40d40:	1884703a 	and	r2,r3,r2
   40d44:	e0bff985 	stb	r2,-26(fp)
   40d48:	2004d63a 	srli	r2,r4,24
   40d4c:	e0bff9c5 	stb	r2,-25(fp)
   40d50:	e17ffa05 	stb	r5,-24(fp)
   40d54:	2804d23a 	srli	r2,r5,8
   40d58:	1007883a 	mov	r3,r2
   40d5c:	00bfffc4 	movi	r2,-1
   40d60:	1884703a 	and	r2,r3,r2
   40d64:	e0bffa45 	stb	r2,-23(fp)

  /* if an invalid mode is requested, nothing needs to change except for the mode struct
  if however a valid mode is requested, we have to determine what display to change to
  and/or if the alarm needs to be turned on/off */
  if (mode_request.invalid == FALSE) {
   40d68:	e0bff903 	ldbu	r2,-28(fp)
   40d6c:	10803fcc 	andi	r2,r2,255
   40d70:	10007a1e 	bne	r2,zero,40f5c <switchesISR+0x270>

    /* if we're already displaying the same mode that was requested, we don't need 
    need to update the display. Thus we can skip the following if statement*/
    if (mode_request.display != mode.display) {
   40d74:	e0fff943 	ldbu	r3,-27(fp)
   40d78:	d0a0f843 	ldbu	r2,-31775(gp)
   40d7c:	18c03fcc 	andi	r3,r3,255
   40d80:	10803fcc 	andi	r2,r2,255
   40d84:	18806226 	beq	r3,r2,40f10 <switchesISR+0x224>
      although the struct's name is time, the information located 
      in this struct is not necessarily time data. This struct could contain
      volume or song information as well. */
      struct time display;

      switch(mode_request.display) {
   40d88:	e0bff943 	ldbu	r2,-27(fp)
   40d8c:	10803fcc 	andi	r2,r2,255
   40d90:	10c00060 	cmpeqi	r3,r2,1
   40d94:	1800161e 	bne	r3,zero,40df0 <switchesISR+0x104>
   40d98:	10c00088 	cmpgei	r3,r2,2
   40d9c:	1800021e 	bne	r3,zero,40da8 <switchesISR+0xbc>
   40da0:	10000626 	beq	r2,zero,40dbc <switchesISR+0xd0>
   40da4:	00004806 	br	40ec8 <switchesISR+0x1dc>
   40da8:	10c000a0 	cmpeqi	r3,r2,2
   40dac:	18001d1e 	bne	r3,zero,40e24 <switchesISR+0x138>
   40db0:	108000e0 	cmpeqi	r2,r2,3
   40db4:	1000221e 	bne	r2,zero,40e40 <switchesISR+0x154>
   40db8:	00004306 	br	40ec8 <switchesISR+0x1dc>
        case DISP_CLOCK: 
          display = getClockTime();
   40dbc:	00428140 	call	42814 <getClockTime>
   40dc0:	e0bffa85 	stb	r2,-22(fp)
   40dc4:	1006d23a 	srli	r3,r2,8
   40dc8:	1809883a 	mov	r4,r3
   40dcc:	00ffffc4 	movi	r3,-1
   40dd0:	20c6703a 	and	r3,r4,r3
   40dd4:	e0fffac5 	stb	r3,-21(fp)
   40dd8:	1004d43a 	srli	r2,r2,16
   40ddc:	1007883a 	mov	r3,r2
   40de0:	00bfffc4 	movi	r2,-1
   40de4:	1884703a 	and	r2,r3,r2
   40de8:	e0bffb05 	stb	r2,-20(fp)
          break;
   40dec:	00003906 	br	40ed4 <switchesISR+0x1e8>

        case DISP_ALARM:
          display = getAlarmTime();
   40df0:	0042d500 	call	42d50 <getAlarmTime>
   40df4:	e0bffa85 	stb	r2,-22(fp)
   40df8:	1006d23a 	srli	r3,r2,8
   40dfc:	1809883a 	mov	r4,r3
   40e00:	00ffffc4 	movi	r3,-1
   40e04:	20c6703a 	and	r3,r4,r3
   40e08:	e0fffac5 	stb	r3,-21(fp)
   40e0c:	1004d43a 	srli	r2,r2,16
   40e10:	1007883a 	mov	r3,r2
   40e14:	00bfffc4 	movi	r2,-1
   40e18:	1884703a 	and	r2,r3,r2
   40e1c:	e0bffb05 	stb	r2,-20(fp)
          break;
   40e20:	00002c06 	br	40ed4 <switchesISR+0x1e8>

        case DISP_VOLUME:
          /* the current volume will be displayed on the "second" 
          7 segment displays. For the moment this means that we're not going
          to check if the volume exceeds 99 (max number that can be displayed with 2 digits) */
          display.hour = DONT_DISPLAY;
   40e24:	00801904 	movi	r2,100
   40e28:	e0bffa85 	stb	r2,-22(fp)
          display.minute = DONT_DISPLAY;
   40e2c:	00801904 	movi	r2,100
   40e30:	e0bffac5 	stb	r2,-21(fp)
          display.second = getVolume();
   40e34:	00415680 	call	41568 <getVolume>
   40e38:	e0bffb05 	stb	r2,-20(fp)
          break;
   40e3c:	00002506 	br	40ed4 <switchesISR+0x1e8>

        case DISP_SONG:
          /* the current song will be displayed on the "second" 
          7 segment displays. For the moment this means that we're not going
          to check if the song index exceeds 99 (max number that can be displayed with 2 digits) */
          display.hour = DONT_DISPLAY;
   40e40:	00801904 	movi	r2,100
   40e44:	e0bffa85 	stb	r2,-22(fp)
          display.minute = DONT_DISPLAY;
   40e48:	00801904 	movi	r2,100
   40e4c:	e0bffac5 	stb	r2,-21(fp)
          display.second = getSong();
   40e50:	00419f80 	call	419f8 <getSong>
   40e54:	e0bffb05 	stb	r2,-20(fp)

          struct note_info note;
          note = playSong();
   40e58:	e0bffc04 	addi	r2,fp,-16
   40e5c:	1009883a 	mov	r4,r2
   40e60:	0041b2c0 	call	41b2c <playSong>

          printf("switch to song display mode...\n");
   40e64:	01000134 	movhi	r4,4
   40e68:	2118d704 	addi	r4,r4,25436
   40e6c:	004462c0 	call	4462c <puts>
          printf("note.frequency == %d\n",note.frequency);
   40e70:	e0bffc17 	ldw	r2,-16(fp)
   40e74:	100b883a 	mov	r5,r2
   40e78:	01000134 	movhi	r4,4
   40e7c:	2118b004 	addi	r4,r4,25280
   40e80:	00445600 	call	44560 <printf>
          printf("note.duration == %d\n",note.duration);
   40e84:	e0bffd17 	ldw	r2,-12(fp)
   40e88:	100b883a 	mov	r5,r2
   40e8c:	01000134 	movhi	r4,4
   40e90:	2118b604 	addi	r4,r4,25304
   40e94:	00445600 	call	44560 <printf>
          printf("note.endofsong == %d\n",note.endofsong);
   40e98:	e0bffe17 	ldw	r2,-8(fp)
   40e9c:	100b883a 	mov	r5,r2
   40ea0:	01000134 	movhi	r4,4
   40ea4:	2118bc04 	addi	r4,r4,25328
   40ea8:	00445600 	call	44560 <printf>
          writePWM(note.frequency);
   40eac:	e0bffc17 	ldw	r2,-16(fp)
   40eb0:	1009883a 	mov	r4,r2
   40eb4:	00416b40 	call	416b4 <writePWM>
          timerPWMEnableInterrupt(note.duration);
   40eb8:	e0bffd17 	ldw	r2,-12(fp)
   40ebc:	1009883a 	mov	r4,r2
   40ec0:	004086c0 	call	4086c <timerPWMEnableInterrupt>

          

          break;
   40ec4:	00000306 	br	40ed4 <switchesISR+0x1e8>

        default:
          printf("ERORR: An invalid display mode is requested\n");
   40ec8:	01000134 	movhi	r4,4
   40ecc:	2118df04 	addi	r4,r4,25468
   40ed0:	004462c0 	call	4462c <puts>
      }

      // since the display mode was changed, we'll have to update the display
      updateDisplay(display);  
   40ed4:	e0bffa8b 	ldhu	r2,-22(fp)
   40ed8:	e0fffb0b 	ldhu	r3,-20(fp)
   40edc:	18c03fcc 	andi	r3,r3,255
   40ee0:	1806943a 	slli	r3,r3,16
   40ee4:	1888b03a 	or	r4,r3,r2
   40ee8:	0007883a 	mov	r3,zero
   40eec:	00804034 	movhi	r2,256
   40ef0:	10bfffc4 	addi	r2,r2,-1
   40ef4:	2084703a 	and	r2,r4,r2
   40ef8:	18ffc02c 	andhi	r3,r3,65280
   40efc:	1884b03a 	or	r2,r3,r2
   40f00:	1007883a 	mov	r3,r2
   40f04:	1809883a 	mov	r4,r3
   40f08:	00404600 	call	40460 <updateDisplay>
   40f0c:	00000306 	br	40f1c <switchesISR+0x230>
    }

    // (mode_request.display == mode.display)
    else { 
      printf("The requested display mode is already active\n");
   40f10:	01000134 	movhi	r4,4
   40f14:	2118ea04 	addi	r4,r4,25512
   40f18:	004462c0 	call	4462c <puts>
    }

    // update the alarm mode if necessary
    if (mode_request.alarm == OFF) {
   40f1c:	e0bff983 	ldbu	r2,-26(fp)
   40f20:	10803fcc 	andi	r2,r2,255
   40f24:	10000b1e 	bne	r2,zero,40f54 <switchesISR+0x268>
      alarmLEDoff();
   40f28:	00409080 	call	40908 <alarmLEDoff>
      /* only stop the song if we're not in the song selection display.
      otherwise, the song that is being sampled while on this display will suddenly
      stop playing. A song should only stop playing if an armed alarm went off,
      and then a user decides to turn off said alarm, OR if a user changes from
      the song display menu to any other menu */
      if (mode_request.display != DISP_SONG) {
   40f2c:	e0bff943 	ldbu	r2,-27(fp)
   40f30:	10803fcc 	andi	r2,r2,255
   40f34:	108000e0 	cmpeqi	r2,r2,3
   40f38:	10000b1e 	bne	r2,zero,40f68 <switchesISR+0x27c>
          printf("song stopped because alarm is off and not in song display mode!\n");
   40f3c:	01000134 	movhi	r4,4
   40f40:	2118f604 	addi	r4,r4,25560
   40f44:	004462c0 	call	4462c <puts>

        stopPWM();
   40f48:	00415e00 	call	415e0 <stopPWM>
        // turn off PWM interrupt timer
        timerPWMDisableInterrupt();
   40f4c:	00408d80 	call	408d8 <timerPWMDisableInterrupt>
   40f50:	00000506 	br	40f68 <switchesISR+0x27c>
      }
    }

    // (mode_request.alarm == ON)
    else {
      alarmLEDon();
   40f54:	00409380 	call	40938 <alarmLEDon>
   40f58:	00000306 	br	40f68 <switchesISR+0x27c>
    }
  }

  // (mode_request.invalid == TRUE)
  else {
    printf("ERROR: An invalid mode was requested\n");
   40f5c:	01000134 	movhi	r4,4
   40f60:	21190604 	addi	r4,r4,25624
   40f64:	004462c0 	call	4462c <puts>
  }

  // make sure to update the mode struct before leaving ISR
  mode = mode_request;
   40f68:	e0bff903 	ldbu	r2,-28(fp)
   40f6c:	d0a0f805 	stb	r2,-31776(gp)
   40f70:	e0bff943 	ldbu	r2,-27(fp)
   40f74:	d0a0f845 	stb	r2,-31775(gp)
   40f78:	e0bff983 	ldbu	r2,-26(fp)
   40f7c:	d0a0f885 	stb	r2,-31774(gp)
   40f80:	e0bff9c3 	ldbu	r2,-25(fp)
   40f84:	d0a0f8c5 	stb	r2,-31773(gp)
   40f88:	e0bffa03 	ldbu	r2,-24(fp)
   40f8c:	d0a0f905 	stb	r2,-31772(gp)
   40f90:	e0bffa43 	ldbu	r2,-23(fp)
   40f94:	d0a0f945 	stb	r2,-31771(gp)
  return;
   40f98:	0001883a 	nop

}
   40f9c:	e037883a 	mov	sp,fp
   40fa0:	dfc00117 	ldw	ra,4(sp)
   40fa4:	df000017 	ldw	fp,0(sp)
   40fa8:	dec00204 	addi	sp,sp,8
   40fac:	f800283a 	ret

00040fb0 <buttonsISR>:


/* This ISR lets us determine what sort of operation the user wants to perform for the
correctly active display mode (increase/decrease clock time, song select, etc.).
Once the requested operation is determined, the system will update the display to match what was requested */
void buttonsISR(void* isr_context) {
   40fb0:	defff904 	addi	sp,sp,-28
   40fb4:	dfc00615 	stw	ra,24(sp)
   40fb8:	df000515 	stw	fp,20(sp)
   40fbc:	df000504 	addi	fp,sp,20
   40fc0:	e13fff15 	stw	r4,-4(fp)

  // if the user is not currently configuring something (time, alarm, etc), then a button press won't do anything
  if (mode.config.on == FALSE) {
   40fc4:	d0a0f8c3 	ldbu	r2,-31773(gp)
   40fc8:	10803fcc 	andi	r2,r2,255
   40fcc:	1000081e 	bne	r2,zero,40ff0 <buttonsISR+0x40>
    printf("ERROR: Not currently in config mode! Button press ignored\n");
   40fd0:	01000134 	movhi	r4,4
   40fd4:	21191004 	addi	r4,r4,25664
   40fd8:	004462c0 	call	4462c <puts>
    // we can't forget to reset edge capture register by writing to it though!
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   40fdc:	0007883a 	mov	r3,zero
   40fe0:	00800234 	movhi	r2,8
   40fe4:	10841f04 	addi	r2,r2,4220
   40fe8:	10c00035 	stwio	r3,0(r2)
    return;
   40fec:	0000ff06 	br	413ec <buttonsISR+0x43c>
  }
  else {
    // determine the operation requested based on the buttons state
    uint8_t buttons_state = IORD_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE);
   40ff0:	00800234 	movhi	r2,8
   40ff4:	10841f04 	addi	r2,r2,4220
   40ff8:	10800037 	ldwio	r2,0(r2)
   40ffc:	e0bffb05 	stb	r2,-20(fp)
      struct time display;

      /* what happens next is entirely dependant on what the current display mode is, whether or not 
      the button press was an UP or DOWN operation, and finally if the config was for the minute or hour time units.
      This scary case statement figures it out */
      switch(mode.display) {
   41000:	d0a0f843 	ldbu	r2,-31775(gp)
   41004:	10803fcc 	andi	r2,r2,255
   41008:	10c00060 	cmpeqi	r3,r2,1
   4100c:	1800551e 	bne	r3,zero,41164 <buttonsISR+0x1b4>
   41010:	10c00088 	cmpgei	r3,r2,2
   41014:	1800021e 	bne	r3,zero,41020 <buttonsISR+0x70>
   41018:	10000626 	beq	r2,zero,41034 <buttonsISR+0x84>
   4101c:	0000d606 	br	41378 <buttonsISR+0x3c8>
   41020:	10c000a0 	cmpeqi	r3,r2,2
   41024:	1800991e 	bne	r3,zero,4128c <buttonsISR+0x2dc>
   41028:	108000e0 	cmpeqi	r2,r2,3
   4102c:	1000a71e 	bne	r2,zero,412cc <buttonsISR+0x31c>
   41030:	0000d106 	br	41378 <buttonsISR+0x3c8>

        case DISP_CLOCK: 

          if (buttons_state == UP) {
   41034:	e0bffb03 	ldbu	r2,-20(fp)
   41038:	10800098 	cmpnei	r2,r2,2
   4103c:	1000231e 	bne	r2,zero,410cc <buttonsISR+0x11c>
            if (mode.config.hour == TRUE) {
   41040:	d0a0f903 	ldbu	r2,-31772(gp)
   41044:	10803fcc 	andi	r2,r2,255
   41048:	10800058 	cmpnei	r2,r2,1
   4104c:	10000d1e 	bne	r2,zero,41084 <buttonsISR+0xd4>
              display = upClockHour();
   41050:	0042a2c0 	call	42a2c <upClockHour>
   41054:	e0bffb45 	stb	r2,-19(fp)
   41058:	1006d23a 	srli	r3,r2,8
   4105c:	1809883a 	mov	r4,r3
   41060:	00ffffc4 	movi	r3,-1
   41064:	20c6703a 	and	r3,r4,r3
   41068:	e0fffb85 	stb	r3,-18(fp)
   4106c:	1004d43a 	srli	r2,r2,16
   41070:	1007883a 	mov	r3,r2
   41074:	00bfffc4 	movi	r2,-1
   41078:	1884703a 	and	r2,r3,r2
   4107c:	e0bffbc5 	stb	r2,-17(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   41080:	0000c106 	br	41388 <buttonsISR+0x3d8>

          if (buttons_state == UP) {
            if (mode.config.hour == TRUE) {
              display = upClockHour();
            }
            else if (mode.config.minute == TRUE) {
   41084:	d0a0f943 	ldbu	r2,-31771(gp)
   41088:	10803fcc 	andi	r2,r2,255
   4108c:	10800058 	cmpnei	r2,r2,1
   41090:	1000bd1e 	bne	r2,zero,41388 <buttonsISR+0x3d8>
              display = upClockMinute(CARRY_OFF);
   41094:	0009883a 	mov	r4,zero
   41098:	00429640 	call	42964 <upClockMinute>
   4109c:	e0bffb45 	stb	r2,-19(fp)
   410a0:	1006d23a 	srli	r3,r2,8
   410a4:	1809883a 	mov	r4,r3
   410a8:	00ffffc4 	movi	r3,-1
   410ac:	20c6703a 	and	r3,r4,r3
   410b0:	e0fffb85 	stb	r3,-18(fp)
   410b4:	1004d43a 	srli	r2,r2,16
   410b8:	1007883a 	mov	r3,r2
   410bc:	00bfffc4 	movi	r2,-1
   410c0:	1884703a 	and	r2,r3,r2
   410c4:	e0bffbc5 	stb	r2,-17(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   410c8:	0000af06 	br	41388 <buttonsISR+0x3d8>
            }
            else if (mode.config.minute == TRUE) {
              display = upClockMinute(CARRY_OFF);
            }
          }
          else if (buttons_state == DOWN) {
   410cc:	e0bffb03 	ldbu	r2,-20(fp)
   410d0:	10800058 	cmpnei	r2,r2,1
   410d4:	1000ac1e 	bne	r2,zero,41388 <buttonsISR+0x3d8>
            if (mode.config.hour == TRUE) {
   410d8:	d0a0f903 	ldbu	r2,-31772(gp)
   410dc:	10803fcc 	andi	r2,r2,255
   410e0:	10800058 	cmpnei	r2,r2,1
   410e4:	10000d1e 	bne	r2,zero,4111c <buttonsISR+0x16c>
              display = downClockHour();
   410e8:	0042c700 	call	42c70 <downClockHour>
   410ec:	e0bffb45 	stb	r2,-19(fp)
   410f0:	1006d23a 	srli	r3,r2,8
   410f4:	1809883a 	mov	r4,r3
   410f8:	00ffffc4 	movi	r3,-1
   410fc:	20c6703a 	and	r3,r4,r3
   41100:	e0fffb85 	stb	r3,-18(fp)
   41104:	1004d43a 	srli	r2,r2,16
   41108:	1007883a 	mov	r3,r2
   4110c:	00bfffc4 	movi	r2,-1
   41110:	1884703a 	and	r2,r3,r2
   41114:	e0bffbc5 	stb	r2,-17(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   41118:	00009b06 	br	41388 <buttonsISR+0x3d8>
          }
          else if (buttons_state == DOWN) {
            if (mode.config.hour == TRUE) {
              display = downClockHour();
            }
            else if (mode.config.minute == TRUE) {
   4111c:	d0a0f943 	ldbu	r2,-31771(gp)
   41120:	10803fcc 	andi	r2,r2,255
   41124:	10800058 	cmpnei	r2,r2,1
   41128:	1000971e 	bne	r2,zero,41388 <buttonsISR+0x3d8>
              display = downClockMinute(CARRY_OFF);
   4112c:	0009883a 	mov	r4,zero
   41130:	0042ba80 	call	42ba8 <downClockMinute>
   41134:	e0bffb45 	stb	r2,-19(fp)
   41138:	1006d23a 	srli	r3,r2,8
   4113c:	1809883a 	mov	r4,r3
   41140:	00ffffc4 	movi	r3,-1
   41144:	20c6703a 	and	r3,r4,r3
   41148:	e0fffb85 	stb	r3,-18(fp)
   4114c:	1004d43a 	srli	r2,r2,16
   41150:	1007883a 	mov	r3,r2
   41154:	00bfffc4 	movi	r2,-1
   41158:	1884703a 	and	r2,r3,r2
   4115c:	e0bffbc5 	stb	r2,-17(fp)
            }
          }
          break;
   41160:	00008906 	br	41388 <buttonsISR+0x3d8>

        case DISP_ALARM:

          if (buttons_state == UP) {
   41164:	e0bffb03 	ldbu	r2,-20(fp)
   41168:	10800098 	cmpnei	r2,r2,2
   4116c:	1000221e 	bne	r2,zero,411f8 <buttonsISR+0x248>
            if (mode.config.hour == TRUE) {
   41170:	d0a0f903 	ldbu	r2,-31772(gp)
   41174:	10803fcc 	andi	r2,r2,255
   41178:	10800058 	cmpnei	r2,r2,1
   4117c:	10000d1e 	bne	r2,zero,411b4 <buttonsISR+0x204>
              display = upAlarmHour();
   41180:	0042e7c0 	call	42e7c <upAlarmHour>
   41184:	e0bffb45 	stb	r2,-19(fp)
   41188:	1006d23a 	srli	r3,r2,8
   4118c:	1809883a 	mov	r4,r3
   41190:	00ffffc4 	movi	r3,-1
   41194:	20c6703a 	and	r3,r4,r3
   41198:	e0fffb85 	stb	r3,-18(fp)
   4119c:	1004d43a 	srli	r2,r2,16
   411a0:	1007883a 	mov	r3,r2
   411a4:	00bfffc4 	movi	r2,-1
   411a8:	1884703a 	and	r2,r3,r2
   411ac:	e0bffbc5 	stb	r2,-17(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   411b0:	00007706 	br	41390 <buttonsISR+0x3e0>

          if (buttons_state == UP) {
            if (mode.config.hour == TRUE) {
              display = upAlarmHour();
            }
            else if (mode.config.minute == TRUE) {
   411b4:	d0a0f943 	ldbu	r2,-31771(gp)
   411b8:	10803fcc 	andi	r2,r2,255
   411bc:	10800058 	cmpnei	r2,r2,1
   411c0:	1000731e 	bne	r2,zero,41390 <buttonsISR+0x3e0>
              display = upAlarmMinute();
   411c4:	0042dd40 	call	42dd4 <upAlarmMinute>
   411c8:	e0bffb45 	stb	r2,-19(fp)
   411cc:	1006d23a 	srli	r3,r2,8
   411d0:	1809883a 	mov	r4,r3
   411d4:	00ffffc4 	movi	r3,-1
   411d8:	20c6703a 	and	r3,r4,r3
   411dc:	e0fffb85 	stb	r3,-18(fp)
   411e0:	1004d43a 	srli	r2,r2,16
   411e4:	1007883a 	mov	r3,r2
   411e8:	00bfffc4 	movi	r2,-1
   411ec:	1884703a 	and	r2,r3,r2
   411f0:	e0bffbc5 	stb	r2,-17(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   411f4:	00006606 	br	41390 <buttonsISR+0x3e0>
            }
            else if (mode.config.minute == TRUE) {
              display = upAlarmMinute();
            }
          }
          else if (buttons_state == DOWN) {
   411f8:	e0bffb03 	ldbu	r2,-20(fp)
   411fc:	10800058 	cmpnei	r2,r2,1
   41200:	1000631e 	bne	r2,zero,41390 <buttonsISR+0x3e0>
            if (mode.config.hour == TRUE) {
   41204:	d0a0f903 	ldbu	r2,-31772(gp)
   41208:	10803fcc 	andi	r2,r2,255
   4120c:	10800058 	cmpnei	r2,r2,1
   41210:	10000d1e 	bne	r2,zero,41248 <buttonsISR+0x298>
              display = downAlarmHour();
   41214:	0042fd40 	call	42fd4 <downAlarmHour>
   41218:	e0bffb45 	stb	r2,-19(fp)
   4121c:	1006d23a 	srli	r3,r2,8
   41220:	1809883a 	mov	r4,r3
   41224:	00ffffc4 	movi	r3,-1
   41228:	20c6703a 	and	r3,r4,r3
   4122c:	e0fffb85 	stb	r3,-18(fp)
   41230:	1004d43a 	srli	r2,r2,16
   41234:	1007883a 	mov	r3,r2
   41238:	00bfffc4 	movi	r2,-1
   4123c:	1884703a 	and	r2,r3,r2
   41240:	e0bffbc5 	stb	r2,-17(fp)
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   41244:	00005206 	br	41390 <buttonsISR+0x3e0>
          }
          else if (buttons_state == DOWN) {
            if (mode.config.hour == TRUE) {
              display = downAlarmHour();
            }
            else if (mode.config.minute == TRUE) {
   41248:	d0a0f943 	ldbu	r2,-31771(gp)
   4124c:	10803fcc 	andi	r2,r2,255
   41250:	10800058 	cmpnei	r2,r2,1
   41254:	10004e1e 	bne	r2,zero,41390 <buttonsISR+0x3e0>
              display = downAlarmMinute();
   41258:	0042f2c0 	call	42f2c <downAlarmMinute>
   4125c:	e0bffb45 	stb	r2,-19(fp)
   41260:	1006d23a 	srli	r3,r2,8
   41264:	1809883a 	mov	r4,r3
   41268:	00ffffc4 	movi	r3,-1
   4126c:	20c6703a 	and	r3,r4,r3
   41270:	e0fffb85 	stb	r3,-18(fp)
   41274:	1004d43a 	srli	r2,r2,16
   41278:	1007883a 	mov	r3,r2
   4127c:	00bfffc4 	movi	r2,-1
   41280:	1884703a 	and	r2,r3,r2
   41284:	e0bffbc5 	stb	r2,-17(fp)
            }
          }
          break;
   41288:	00004106 	br	41390 <buttonsISR+0x3e0>


        case DISP_VOLUME:

          display.hour = DONT_DISPLAY;
   4128c:	00801904 	movi	r2,100
   41290:	e0bffb45 	stb	r2,-19(fp)
          display.minute = DONT_DISPLAY;
   41294:	00801904 	movi	r2,100
   41298:	e0bffb85 	stb	r2,-18(fp)
          if (buttons_state == UP) {
   4129c:	e0bffb03 	ldbu	r2,-20(fp)
   412a0:	10800098 	cmpnei	r2,r2,2
   412a4:	1000031e 	bne	r2,zero,412b4 <buttonsISR+0x304>
            display.second = upVolume();
   412a8:	00415880 	call	41588 <upVolume>
   412ac:	e0bffbc5 	stb	r2,-17(fp)
          }
          else if (buttons_state == DOWN) {
            display.second = downVolume();
          }
          
          break;
   412b0:	00003906 	br	41398 <buttonsISR+0x3e8>
          display.hour = DONT_DISPLAY;
          display.minute = DONT_DISPLAY;
          if (buttons_state == UP) {
            display.second = upVolume();
          }
          else if (buttons_state == DOWN) {
   412b4:	e0bffb03 	ldbu	r2,-20(fp)
   412b8:	10800058 	cmpnei	r2,r2,1
   412bc:	1000361e 	bne	r2,zero,41398 <buttonsISR+0x3e8>
            display.second = downVolume();
   412c0:	00415b40 	call	415b4 <downVolume>
   412c4:	e0bffbc5 	stb	r2,-17(fp)
          }
          
          break;
   412c8:	00003306 	br	41398 <buttonsISR+0x3e8>

        case DISP_SONG:

          display.hour = DONT_DISPLAY;
   412cc:	00801904 	movi	r2,100
   412d0:	e0bffb45 	stb	r2,-19(fp)
          display.minute = DONT_DISPLAY;
   412d4:	00801904 	movi	r2,100
   412d8:	e0bffb85 	stb	r2,-18(fp)
          if (buttons_state == UP) {
   412dc:	e0bffb03 	ldbu	r2,-20(fp)
   412e0:	10800098 	cmpnei	r2,r2,2
   412e4:	1000031e 	bne	r2,zero,412f4 <buttonsISR+0x344>
            display.second = upSong();
   412e8:	0041a180 	call	41a18 <upSong>
   412ec:	e0bffbc5 	stb	r2,-17(fp)
   412f0:	00000506 	br	41308 <buttonsISR+0x358>
          }
          else if (buttons_state == DOWN) {
   412f4:	e0bffb03 	ldbu	r2,-20(fp)
   412f8:	10800058 	cmpnei	r2,r2,1
   412fc:	1000021e 	bne	r2,zero,41308 <buttonsISR+0x358>
            display.second = downSong();
   41300:	0041a5c0 	call	41a5c <downSong>
   41304:	e0bffbc5 	stb	r2,-17(fp)
          }

          struct note_info note;
          note = playSong();
   41308:	e0bffc04 	addi	r2,fp,-16
   4130c:	1009883a 	mov	r4,r2
   41310:	0041b2c0 	call	41b2c <playSong>

          printf("button input while in display song mode...\n");
   41314:	01000134 	movhi	r4,4
   41318:	21191f04 	addi	r4,r4,25724
   4131c:	004462c0 	call	4462c <puts>
          printf("note.frequency == %d\n",note.frequency);
   41320:	e0bffc17 	ldw	r2,-16(fp)
   41324:	100b883a 	mov	r5,r2
   41328:	01000134 	movhi	r4,4
   4132c:	2118b004 	addi	r4,r4,25280
   41330:	00445600 	call	44560 <printf>
          printf("note.duration == %d\n",note.duration);
   41334:	e0bffd17 	ldw	r2,-12(fp)
   41338:	100b883a 	mov	r5,r2
   4133c:	01000134 	movhi	r4,4
   41340:	2118b604 	addi	r4,r4,25304
   41344:	00445600 	call	44560 <printf>
          printf("note.endofsong == %d\n",note.endofsong);
   41348:	e0bffe17 	ldw	r2,-8(fp)
   4134c:	100b883a 	mov	r5,r2
   41350:	01000134 	movhi	r4,4
   41354:	2118bc04 	addi	r4,r4,25328
   41358:	00445600 	call	44560 <printf>
          writePWM(note.frequency);
   4135c:	e0bffc17 	ldw	r2,-16(fp)
   41360:	1009883a 	mov	r4,r2
   41364:	00416b40 	call	416b4 <writePWM>
          timerPWMEnableInterrupt(note.duration);
   41368:	e0bffd17 	ldw	r2,-12(fp)
   4136c:	1009883a 	mov	r4,r2
   41370:	004086c0 	call	4086c <timerPWMEnableInterrupt>

          break;
   41374:	00000906 	br	4139c <buttonsISR+0x3ec>

        default:
          // if the switches.c module didn't mess up, this should never print!
          printf("ERORR: The system is currently in an invalid display mode!!\n");
   41378:	01000134 	movhi	r4,4
   4137c:	21192a04 	addi	r4,r4,25768
   41380:	004462c0 	call	4462c <puts>
   41384:	00000506 	br	4139c <buttonsISR+0x3ec>
            }
            else if (mode.config.minute == TRUE) {
              display = downClockMinute(CARRY_OFF);
            }
          }
          break;
   41388:	0001883a 	nop
   4138c:	00000306 	br	4139c <buttonsISR+0x3ec>
            }
            else if (mode.config.minute == TRUE) {
              display = downAlarmMinute();
            }
          }
          break;
   41390:	0001883a 	nop
   41394:	00000106 	br	4139c <buttonsISR+0x3ec>
          }
          else if (buttons_state == DOWN) {
            display.second = downVolume();
          }
          
          break;
   41398:	0001883a 	nop
          // if the switches.c module didn't mess up, this should never print!
          printf("ERORR: The system is currently in an invalid display mode!!\n");
      }

      // since the display mode was changed, we'll have to update the display
      updateDisplay(display);  
   4139c:	e0bffb43 	ldbu	r2,-19(fp)
   413a0:	e0fffb83 	ldbu	r3,-18(fp)
   413a4:	1806923a 	slli	r3,r3,8
   413a8:	1884b03a 	or	r2,r3,r2
   413ac:	e0fffbc3 	ldbu	r3,-17(fp)
   413b0:	1806943a 	slli	r3,r3,16
   413b4:	1888b03a 	or	r4,r3,r2
   413b8:	0007883a 	mov	r3,zero
   413bc:	00804034 	movhi	r2,256
   413c0:	10bfffc4 	addi	r2,r2,-1
   413c4:	2084703a 	and	r2,r4,r2
   413c8:	18ffc02c 	andhi	r3,r3,65280
   413cc:	1884b03a 	or	r2,r3,r2
   413d0:	1007883a 	mov	r3,r2
   413d4:	1809883a 	mov	r4,r3
   413d8:	00404600 	call	40460 <updateDisplay>
    }

  // we can't forget to reset edge capture register by writing to it!
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
   413dc:	0007883a 	mov	r3,zero
   413e0:	00800234 	movhi	r2,8
   413e4:	10841f04 	addi	r2,r2,4220
   413e8:	10c00035 	stwio	r3,0(r2)

}
   413ec:	e037883a 	mov	sp,fp
   413f0:	dfc00117 	ldw	ra,4(sp)
   413f4:	df000017 	ldw	fp,0(sp)
   413f8:	dec00204 	addi	sp,sp,8
   413fc:	f800283a 	ret

00041400 <timerPWMISR>:


void timerPWMISR(void* isr_context) {
   41400:	defff704 	addi	sp,sp,-36
   41404:	dfc00815 	stw	ra,32(sp)
   41408:	df000715 	stw	fp,28(sp)
   4140c:	df000704 	addi	fp,sp,28
   41410:	e13ffc15 	stw	r4,-16(fp)

  printf("timerPWMISR has fired!\n");
   41414:	01000134 	movhi	r4,4
   41418:	21193904 	addi	r4,r4,25828
   4141c:	004462c0 	call	4462c <puts>

  /* The TO (timeout) bit is set to 1 when the internal counter reaches zero. Once set by a
  timeout event, the TO bit stays set until explicitly cleared by a master peripheral. 
  The TO bit is cleared by writing 0 to the status register. */
  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_PWM_BASE, 0);
   41420:	0007883a 	mov	r3,zero
   41424:	00800234 	movhi	r2,8
   41428:	10840004 	addi	r2,r2,4096
   4142c:	10c00035 	stwio	r3,0(r2)

  struct note_info note;

  note = getNote();
   41430:	e13ff904 	addi	r4,fp,-28
   41434:	0041e180 	call	41e18 <getNote>
  printf("note.frequency == %d\n",note.frequency);
   41438:	e0bff917 	ldw	r2,-28(fp)
   4143c:	100b883a 	mov	r5,r2
   41440:	01000134 	movhi	r4,4
   41444:	2118b004 	addi	r4,r4,25280
   41448:	00445600 	call	44560 <printf>
  printf("note.duration == %d\n",note.duration);
   4144c:	e0bffa17 	ldw	r2,-24(fp)
   41450:	100b883a 	mov	r5,r2
   41454:	01000134 	movhi	r4,4
   41458:	2118b604 	addi	r4,r4,25304
   4145c:	00445600 	call	44560 <printf>
  printf("note.endofsong == %d\n",note.endofsong);
   41460:	e0bffb17 	ldw	r2,-20(fp)
   41464:	100b883a 	mov	r5,r2
   41468:	01000134 	movhi	r4,4
   4146c:	2118bc04 	addi	r4,r4,25328
   41470:	00445600 	call	44560 <printf>

  if (note.endofsong == FALSE) {
   41474:	e0bffb17 	ldw	r2,-20(fp)
   41478:	1000071e 	bne	r2,zero,41498 <timerPWMISR+0x98>
    writePWM(note.frequency);
   4147c:	e0bff917 	ldw	r2,-28(fp)
   41480:	1009883a 	mov	r4,r2
   41484:	00416b40 	call	416b4 <writePWM>
    timerPWMEnableInterrupt(note.duration);
   41488:	e0bffa17 	ldw	r2,-24(fp)
   4148c:	1009883a 	mov	r4,r2
   41490:	004086c0 	call	4086c <timerPWMEnableInterrupt>
      writePWM(note.frequency);
      timerPWMEnableInterrupt(note.duration);  
    }
  }

}
   41494:	00002e06 	br	41550 <timerPWMISR+0x150>

  if (note.endofsong == FALSE) {
    writePWM(note.frequency);
    timerPWMEnableInterrupt(note.duration);
  }
  else if (note.endofsong == TRUE) {
   41498:	e0bffb17 	ldw	r2,-20(fp)
   4149c:	10800058 	cmpnei	r2,r2,1
   414a0:	10002b1e 	bne	r2,zero,41550 <timerPWMISR+0x150>
    if (mode.display == DISP_SONG) {
   414a4:	d0a0f843 	ldbu	r2,-31775(gp)
   414a8:	10803fcc 	andi	r2,r2,255
   414ac:	108000d8 	cmpnei	r2,r2,3
   414b0:	1000061e 	bne	r2,zero,414cc <timerPWMISR+0xcc>
      printf("song played through once while in display song mode...\n");
   414b4:	01000134 	movhi	r4,4
   414b8:	21193f04 	addi	r4,r4,25852
   414bc:	004462c0 	call	4462c <puts>
      stopPWM();
   414c0:	00415e00 	call	415e0 <stopPWM>
      timerPWMDisableInterrupt();
   414c4:	00408d80 	call	408d8 <timerPWMDisableInterrupt>
      writePWM(note.frequency);
      timerPWMEnableInterrupt(note.duration);  
    }
  }

}
   414c8:	00002106 	br	41550 <timerPWMISR+0x150>
      printf("song played through once while in display song mode...\n");
      stopPWM();
      timerPWMDisableInterrupt();
    }
    else {
      printf("Turn off alarm to stop the song!\n");
   414cc:	01000134 	movhi	r4,4
   414d0:	21194d04 	addi	r4,r4,25908
   414d4:	004462c0 	call	4462c <puts>
      note = playSong();
   414d8:	e0bffd04 	addi	r2,fp,-12
   414dc:	1009883a 	mov	r4,r2
   414e0:	0041b2c0 	call	41b2c <playSong>
   414e4:	e0bffd17 	ldw	r2,-12(fp)
   414e8:	e0bff915 	stw	r2,-28(fp)
   414ec:	e0bffe17 	ldw	r2,-8(fp)
   414f0:	e0bffa15 	stw	r2,-24(fp)
   414f4:	e0bfff17 	ldw	r2,-4(fp)
   414f8:	e0bffb15 	stw	r2,-20(fp)
      printf("note.frequency == %d\n",note.frequency);
   414fc:	e0bff917 	ldw	r2,-28(fp)
   41500:	100b883a 	mov	r5,r2
   41504:	01000134 	movhi	r4,4
   41508:	2118b004 	addi	r4,r4,25280
   4150c:	00445600 	call	44560 <printf>
      printf("note.duration == %d\n",note.duration);
   41510:	e0bffa17 	ldw	r2,-24(fp)
   41514:	100b883a 	mov	r5,r2
   41518:	01000134 	movhi	r4,4
   4151c:	2118b604 	addi	r4,r4,25304
   41520:	00445600 	call	44560 <printf>
      printf("note.endofsong == %d\n",note.endofsong);
   41524:	e0bffb17 	ldw	r2,-20(fp)
   41528:	100b883a 	mov	r5,r2
   4152c:	01000134 	movhi	r4,4
   41530:	2118bc04 	addi	r4,r4,25328
   41534:	00445600 	call	44560 <printf>
      writePWM(note.frequency);
   41538:	e0bff917 	ldw	r2,-28(fp)
   4153c:	1009883a 	mov	r4,r2
   41540:	00416b40 	call	416b4 <writePWM>
      timerPWMEnableInterrupt(note.duration);  
   41544:	e0bffa17 	ldw	r2,-24(fp)
   41548:	1009883a 	mov	r4,r2
   4154c:	004086c0 	call	4086c <timerPWMEnableInterrupt>
    }
  }

}
   41550:	0001883a 	nop
   41554:	e037883a 	mov	sp,fp
   41558:	dfc00117 	ldw	ra,4(sp)
   4155c:	df000017 	ldw	fp,0(sp)
   41560:	dec00204 	addi	sp,sp,8
   41564:	f800283a 	ret

00041568 <getVolume>:
#include "pwm.h"

uint8_t volume = 5;

uint8_t getVolume(void) {
   41568:	deffff04 	addi	sp,sp,-4
   4156c:	df000015 	stw	fp,0(sp)
   41570:	d839883a 	mov	fp,sp
  return volume;
   41574:	d0a00003 	ldbu	r2,-32768(gp)
}
   41578:	e037883a 	mov	sp,fp
   4157c:	df000017 	ldw	fp,0(sp)
   41580:	dec00104 	addi	sp,sp,4
   41584:	f800283a 	ret

00041588 <upVolume>:
uint8_t upVolume(void) {
   41588:	deffff04 	addi	sp,sp,-4
   4158c:	df000015 	stw	fp,0(sp)
   41590:	d839883a 	mov	fp,sp
  volume++;
   41594:	d0a00003 	ldbu	r2,-32768(gp)
   41598:	10800044 	addi	r2,r2,1
   4159c:	d0a00005 	stb	r2,-32768(gp)
  return volume;
   415a0:	d0a00003 	ldbu	r2,-32768(gp)
}
   415a4:	e037883a 	mov	sp,fp
   415a8:	df000017 	ldw	fp,0(sp)
   415ac:	dec00104 	addi	sp,sp,4
   415b0:	f800283a 	ret

000415b4 <downVolume>:
uint8_t downVolume(void) {
   415b4:	deffff04 	addi	sp,sp,-4
   415b8:	df000015 	stw	fp,0(sp)
   415bc:	d839883a 	mov	fp,sp
  volume--;
   415c0:	d0a00003 	ldbu	r2,-32768(gp)
   415c4:	10bfffc4 	addi	r2,r2,-1
   415c8:	d0a00005 	stb	r2,-32768(gp)
  return volume;
   415cc:	d0a00003 	ldbu	r2,-32768(gp)
}
   415d0:	e037883a 	mov	sp,fp
   415d4:	df000017 	ldw	fp,0(sp)
   415d8:	dec00104 	addi	sp,sp,4
   415dc:	f800283a 	ret

000415e0 <stopPWM>:

void stopPWM(void) {
   415e0:	defffd04 	addi	sp,sp,-12
   415e4:	dfc00215 	stw	ra,8(sp)
   415e8:	df000115 	stw	fp,4(sp)
   415ec:	df000104 	addi	fp,sp,4
  int return_code = ALTERA_AVALON_PWM_OK;
   415f0:	e03fff15 	stw	zero,-4(fp)
  //Disable PWM and Check Return Code
  return_code = altera_avalon_pwm_disable(PWM_BASE); 
   415f4:	01000234 	movhi	r4,8
   415f8:	21043c04 	addi	r4,r4,4336
   415fc:	00403380 	call	40338 <altera_avalon_pwm_disable>
   41600:	e0bfff15 	stw	r2,-4(fp)
  check_return_code(PWM_BASE, return_code);
   41604:	e17fff17 	ldw	r5,-4(fp)
   41608:	01000234 	movhi	r4,8
   4160c:	21043c04 	addi	r4,r4,4336
   41610:	00418c80 	call	418c8 <check_return_code>
}
   41614:	0001883a 	nop
   41618:	e037883a 	mov	sp,fp
   4161c:	dfc00117 	ldw	ra,4(sp)
   41620:	df000017 	ldw	fp,0(sp)
   41624:	dec00204 	addi	sp,sp,8
   41628:	f800283a 	ret

0004162c <default500HzSquareWave>:



void default500HzSquareWave(void) {
   4162c:	defffb04 	addi	sp,sp,-20
   41630:	dfc00415 	stw	ra,16(sp)
   41634:	df000315 	stw	fp,12(sp)
   41638:	df000304 	addi	fp,sp,12

 unsigned int clock_divide = 100000;
   4163c:	008000b4 	movhi	r2,2
   41640:	10a1a804 	addi	r2,r2,-31072
   41644:	e0bffd15 	stw	r2,-12(fp)
 unsigned int duty_cycle =    50000;
   41648:	00b0d414 	movui	r2,50000
   4164c:	e0bffe15 	stw	r2,-8(fp)
 int return_code = ALTERA_AVALON_PWM_OK;
   41650:	e03fff15 	stw	zero,-4(fp)
 
 //Initialize PWM and Check Return Code
 return_code = altera_avalon_pwm_init(PWM_BASE, clock_divide, duty_cycle);  
   41654:	e1bffe17 	ldw	r6,-8(fp)
   41658:	e17ffd17 	ldw	r5,-12(fp)
   4165c:	01000234 	movhi	r4,8
   41660:	21043c04 	addi	r4,r4,4336
   41664:	00402800 	call	40280 <altera_avalon_pwm_init>
   41668:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   4166c:	e17fff17 	ldw	r5,-4(fp)
   41670:	01000234 	movhi	r4,8
   41674:	21043c04 	addi	r4,r4,4336
   41678:	00418c80 	call	418c8 <check_return_code>
 
 //Enable PWM and Check Return Code
 return_code = altera_avalon_pwm_enable(PWM_BASE); 
   4167c:	01000234 	movhi	r4,8
   41680:	21043c04 	addi	r4,r4,4336
   41684:	00402e40 	call	402e4 <altera_avalon_pwm_enable>
   41688:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   4168c:	e17fff17 	ldw	r5,-4(fp)
   41690:	01000234 	movhi	r4,8
   41694:	21043c04 	addi	r4,r4,4336
   41698:	00418c80 	call	418c8 <check_return_code>
}
   4169c:	0001883a 	nop
   416a0:	e037883a 	mov	sp,fp
   416a4:	dfc00117 	ldw	ra,4(sp)
   416a8:	df000017 	ldw	fp,0(sp)
   416ac:	dec00204 	addi	sp,sp,8
   416b0:	f800283a 	ret

000416b4 <writePWM>:

void writePWM(int frequency) {
   416b4:	defffa04 	addi	sp,sp,-24
   416b8:	dfc00515 	stw	ra,20(sp)
   416bc:	df000415 	stw	fp,16(sp)
   416c0:	df000404 	addi	fp,sp,16
   416c4:	e13fff15 	stw	r4,-4(fp)

  if (frequency == 0) {
   416c8:	e0bfff17 	ldw	r2,-4(fp)
   416cc:	1000021e 	bne	r2,zero,416d8 <writePWM+0x24>
    // this happens if the note is supposed to be a pause
    stopPWM();
   416d0:	00415e00 	call	415e0 <stopPWM>
    //Enable PWM and Check Return Code
    return_code = altera_avalon_pwm_enable(PWM_BASE); 
    check_return_code(PWM_BASE, return_code);
  }

}
   416d4:	00002b06 	br	41784 <writePWM+0xd0>
    // this happens if the note is supposed to be a pause
    stopPWM();
  }
  else {
    // conversion of input frequency to PWM clock cycle divide value
    unsigned int clock_divide = NIOS_CLOCK_FREQ/frequency;
   416d8:	e17fff17 	ldw	r5,-4(fp)
   416dc:	0100bef4 	movhi	r4,763
   416e0:	213c2004 	addi	r4,r4,-3968
   416e4:	00430f40 	call	430f4 <__divsi3>
   416e8:	e0bffc15 	stw	r2,-16(fp)

    // 5% duty cycle by default
    unsigned int duty_cycle =    clock_divide*0.05;
   416ec:	e13ffc17 	ldw	r4,-16(fp)
   416f0:	00444180 	call	44418 <__floatunsidf>
   416f4:	1011883a 	mov	r8,r2
   416f8:	1813883a 	mov	r9,r3
   416fc:	01a666b4 	movhi	r6,39322
   41700:	31a66684 	addi	r6,r6,-26214
   41704:	01cfeab4 	movhi	r7,16298
   41708:	39e66644 	addi	r7,r7,-26215
   4170c:	4009883a 	mov	r4,r8
   41710:	480b883a 	mov	r5,r9
   41714:	00433840 	call	43384 <__muldf3>
   41718:	1009883a 	mov	r4,r2
   4171c:	180b883a 	mov	r5,r3
   41720:	2005883a 	mov	r2,r4
   41724:	2807883a 	mov	r3,r5
   41728:	1009883a 	mov	r4,r2
   4172c:	180b883a 	mov	r5,r3
   41730:	00430800 	call	43080 <__fixunsdfsi>
   41734:	e0bffd15 	stw	r2,-12(fp)

    int return_code = ALTERA_AVALON_PWM_OK;
   41738:	e03ffe15 	stw	zero,-8(fp)
    
    //Initialize PWM and Check Return Code
    return_code = altera_avalon_pwm_init(PWM_BASE, clock_divide, duty_cycle);  
   4173c:	e1bffd17 	ldw	r6,-12(fp)
   41740:	e17ffc17 	ldw	r5,-16(fp)
   41744:	01000234 	movhi	r4,8
   41748:	21043c04 	addi	r4,r4,4336
   4174c:	00402800 	call	40280 <altera_avalon_pwm_init>
   41750:	e0bffe15 	stw	r2,-8(fp)
    check_return_code(PWM_BASE, return_code);
   41754:	e17ffe17 	ldw	r5,-8(fp)
   41758:	01000234 	movhi	r4,8
   4175c:	21043c04 	addi	r4,r4,4336
   41760:	00418c80 	call	418c8 <check_return_code>
    
    //Enable PWM and Check Return Code
    return_code = altera_avalon_pwm_enable(PWM_BASE); 
   41764:	01000234 	movhi	r4,8
   41768:	21043c04 	addi	r4,r4,4336
   4176c:	00402e40 	call	402e4 <altera_avalon_pwm_enable>
   41770:	e0bffe15 	stw	r2,-8(fp)
    check_return_code(PWM_BASE, return_code);
   41774:	e17ffe17 	ldw	r5,-8(fp)
   41778:	01000234 	movhi	r4,8
   4177c:	21043c04 	addi	r4,r4,4336
   41780:	00418c80 	call	418c8 <check_return_code>
  }

}
   41784:	0001883a 	nop
   41788:	e037883a 	mov	sp,fp
   4178c:	dfc00117 	ldw	ra,4(sp)
   41790:	df000017 	ldw	fp,0(sp)
   41794:	dec00204 	addi	sp,sp,8
   41798:	f800283a 	ret

0004179c <testPWM>:

void testPWM(void) {
   4179c:	defffc04 	addi	sp,sp,-16
   417a0:	dfc00315 	stw	ra,12(sp)
   417a4:	df000215 	stw	fp,8(sp)
   417a8:	df000204 	addi	fp,sp,8
 
 unsigned int duty_cycle;
 int return_code = ALTERA_AVALON_PWM_OK;
   417ac:	e03fff15 	stw	zero,-4(fp)
 
 printf("Period = %u\n", IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE) );
   417b0:	00800234 	movhi	r2,8
   417b4:	10843c04 	addi	r2,r2,4336
   417b8:	10800037 	ldwio	r2,0(r2)
   417bc:	100b883a 	mov	r5,r2
   417c0:	01000134 	movhi	r4,4
   417c4:	21195604 	addi	r4,r4,25944
   417c8:	00445600 	call	44560 <printf>
 printf("Duty cycle = %u\n", IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(PWM_BASE) );
   417cc:	00800234 	movhi	r2,8
   417d0:	10843d04 	addi	r2,r2,4340
   417d4:	10800037 	ldwio	r2,0(r2)
   417d8:	100b883a 	mov	r5,r2
   417dc:	01000134 	movhi	r4,4
   417e0:	21195a04 	addi	r4,r4,25960
   417e4:	00445600 	call	44560 <printf>
 
 //Initialize PWM and Check Return Code
 return_code = altera_avalon_pwm_init(PWM_BASE, 500000, 1);  
   417e8:	01800044 	movi	r6,1
   417ec:	01400234 	movhi	r5,8
   417f0:	29684804 	addi	r5,r5,-24288
   417f4:	01000234 	movhi	r4,8
   417f8:	21043c04 	addi	r4,r4,4336
   417fc:	00402800 	call	40280 <altera_avalon_pwm_init>
   41800:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   41804:	e17fff17 	ldw	r5,-4(fp)
   41808:	01000234 	movhi	r4,8
   4180c:	21043c04 	addi	r4,r4,4336
   41810:	00418c80 	call	418c8 <check_return_code>
 
 //Enable PWM and Check Return Code
 return_code = altera_avalon_pwm_enable(PWM_BASE); 
   41814:	01000234 	movhi	r4,8
   41818:	21043c04 	addi	r4,r4,4336
   4181c:	00402e40 	call	402e4 <altera_avalon_pwm_enable>
   41820:	e0bfff15 	stw	r2,-4(fp)
 check_return_code(PWM_BASE, return_code);
   41824:	e17fff17 	ldw	r5,-4(fp)
   41828:	01000234 	movhi	r4,8
   4182c:	21043c04 	addi	r4,r4,4336
   41830:	00418c80 	call	418c8 <check_return_code>

//init duty_cycle with the value written to duty_cycle register during initialization
 duty_cycle = IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(PWM_BASE);
   41834:	00800234 	movhi	r2,8
   41838:	10843d04 	addi	r2,r2,4340
   4183c:	10800037 	ldwio	r2,0(r2)
   41840:	e0bffe15 	stw	r2,-8(fp)
 
 
 while(1)
   {
     while(duty_cycle++ < IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE))
   41844:	00000906 	br	4186c <testPWM+0xd0>
     {
      	return_code = altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
   41848:	e17ffe17 	ldw	r5,-8(fp)
   4184c:	01000234 	movhi	r4,8
   41850:	21043c04 	addi	r4,r4,4336
   41854:	00403880 	call	40388 <altera_avalon_pwm_change_duty_cycle>
   41858:	e0bfff15 	stw	r2,-4(fp)
      	check_return_code(PWM_BASE, return_code);
   4185c:	e17fff17 	ldw	r5,-4(fp)
   41860:	01000234 	movhi	r4,8
   41864:	21043c04 	addi	r4,r4,4336
   41868:	00418c80 	call	418c8 <check_return_code>
 duty_cycle = IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(PWM_BASE);
 
 
 while(1)
   {
     while(duty_cycle++ < IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE))
   4186c:	e0fffe17 	ldw	r3,-8(fp)
   41870:	18800044 	addi	r2,r3,1
   41874:	e0bffe15 	stw	r2,-8(fp)
   41878:	00800234 	movhi	r2,8
   4187c:	10843c04 	addi	r2,r2,4336
   41880:	10800037 	ldwio	r2,0(r2)
   41884:	18bff036 	bltu	r3,r2,41848 <__alt_data_end+0xfffd9848>
     {
      	return_code = altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
      	check_return_code(PWM_BASE, return_code);
     }          
     while(--duty_cycle > 1)
   41888:	00000406 	br	4189c <testPWM+0x100>
      	altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
   4188c:	e17ffe17 	ldw	r5,-8(fp)
   41890:	01000234 	movhi	r4,8
   41894:	21043c04 	addi	r4,r4,4336
   41898:	00403880 	call	40388 <altera_avalon_pwm_change_duty_cycle>
     while(duty_cycle++ < IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(PWM_BASE))
     {
      	return_code = altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
      	check_return_code(PWM_BASE, return_code);
     }          
     while(--duty_cycle > 1)
   4189c:	e0bffe17 	ldw	r2,-8(fp)
   418a0:	10bfffc4 	addi	r2,r2,-1
   418a4:	e0bffe15 	stw	r2,-8(fp)
   418a8:	e0bffe17 	ldw	r2,-8(fp)
   418ac:	108000a8 	cmpgeui	r2,r2,2
   418b0:	103ff61e 	bne	r2,zero,4188c <__alt_data_end+0xfffd988c>
      	altera_avalon_pwm_change_duty_cycle(PWM_BASE, duty_cycle);
        check_return_code(PWM_BASE, return_code);
   418b4:	e17fff17 	ldw	r5,-4(fp)
   418b8:	01000234 	movhi	r4,8
   418bc:	21043c04 	addi	r4,r4,4336
   418c0:	00418c80 	call	418c8 <check_return_code>
   }
   418c4:	003fdf06 	br	41844 <__alt_data_end+0xfffd9844>

000418c8 <check_return_code>:
}

void check_return_code(unsigned int address, int return_code)
{
   418c8:	defffc04 	addi	sp,sp,-16
   418cc:	dfc00315 	stw	ra,12(sp)
   418d0:	df000215 	stw	fp,8(sp)
   418d4:	df000204 	addi	fp,sp,8
   418d8:	e13ffe15 	stw	r4,-8(fp)
   418dc:	e17fff15 	stw	r5,-4(fp)
	if(return_code != ALTERA_AVALON_PWM_OK)
   418e0:	e0bfff17 	ldw	r2,-4(fp)
   418e4:	10000326 	beq	r2,zero,418f4 <check_return_code+0x2c>
      		print_error(address, return_code);	
   418e8:	e17fff17 	ldw	r5,-4(fp)
   418ec:	e13ffe17 	ldw	r4,-8(fp)
   418f0:	004190c0 	call	4190c <print_error>
}
   418f4:	0001883a 	nop
   418f8:	e037883a 	mov	sp,fp
   418fc:	dfc00117 	ldw	ra,4(sp)
   41900:	df000017 	ldw	fp,0(sp)
   41904:	dec00204 	addi	sp,sp,8
   41908:	f800283a 	ret

0004190c <print_error>:

void print_error(unsigned int address, int return_code)
{
   4190c:	defffc04 	addi	sp,sp,-16
   41910:	dfc00315 	stw	ra,12(sp)
   41914:	df000215 	stw	fp,8(sp)
   41918:	df000204 	addi	fp,sp,8
   4191c:	e13ffe15 	stw	r4,-8(fp)
   41920:	e17fff15 	stw	r5,-4(fp)
	printf("Program Terminated Due to an error with Avalon PWM located at 0x%x:\n", address);
   41924:	e17ffe17 	ldw	r5,-8(fp)
   41928:	01000134 	movhi	r4,4
   4192c:	21195f04 	addi	r4,r4,25980
   41930:	00445600 	call	44560 <printf>
	switch(return_code)
   41934:	e0bfff17 	ldw	r2,-4(fp)
   41938:	10ffffa0 	cmpeqi	r3,r2,-2
   4193c:	1800161e 	bne	r3,zero,41998 <print_error+0x8c>
   41940:	10ffffe0 	cmpeqi	r3,r2,-1
   41944:	1800031e 	bne	r3,zero,41954 <print_error+0x48>
   41948:	10bfff60 	cmpeqi	r2,r2,-3
   4194c:	10001d1e 	bne	r2,zero,419c4 <print_error+0xb8>
   41950:	00002706 	br	419f0 <print_error+0xe4>
	{
	case ALTERA_AVALON_PWM_DUTY_CYCLE_GREATER_THAN_CLOCK_CYCLE_ERROR:
		printf("The value in the clock cycle register must be greater than the value in the duty cycle register\n");
   41954:	01000134 	movhi	r4,4
   41958:	21197104 	addi	r4,r4,26052
   4195c:	004462c0 	call	4462c <puts>
		printf("Value in the Clock Divide Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_CLOCK_DIVIDER(address)); 
   41960:	e0bffe17 	ldw	r2,-8(fp)
   41964:	10800037 	ldwio	r2,0(r2)
   41968:	100b883a 	mov	r5,r2
   4196c:	01000134 	movhi	r4,4
   41970:	21198904 	addi	r4,r4,26148
   41974:	00445600 	call	44560 <printf>
		printf("Value in the Duty Cycle Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_DUTY_CYCLE(address));
   41978:	e0bffe17 	ldw	r2,-8(fp)
   4197c:	10800104 	addi	r2,r2,4
   41980:	10800037 	ldwio	r2,0(r2)
   41984:	100b883a 	mov	r5,r2
   41988:	01000134 	movhi	r4,4
   4198c:	21199404 	addi	r4,r4,26192
   41990:	00445600 	call	44560 <printf>
		break;
   41994:	00001706 	br	419f4 <print_error+0xe8>
  case ALTERA_AVALON_PWM_ENABLED_CONFIRMATION_ERROR:
    printf("Unable to confirm that the PWM is enabled\n");
   41998:	01000134 	movhi	r4,4
   4199c:	21199e04 	addi	r4,r4,26232
   419a0:	004462c0 	call	4462c <puts>
		printf("Value in the Enable Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_ENABLE(address)); 
   419a4:	e0bffe17 	ldw	r2,-8(fp)
   419a8:	10800204 	addi	r2,r2,8
   419ac:	10800037 	ldwio	r2,0(r2)
   419b0:	100b883a 	mov	r5,r2
   419b4:	01000134 	movhi	r4,4
   419b8:	2119a904 	addi	r4,r4,26276
   419bc:	00445600 	call	44560 <printf>
    break;
   419c0:	00000c06 	br	419f4 <print_error+0xe8>
  case ALTERA_AVALON_PWM_DISABLED_CONFIRMATION_ERROR:
  	printf("Unable to confirm that the PWM is disabled\n");
   419c4:	01000134 	movhi	r4,4
   419c8:	2119b204 	addi	r4,r4,26312
   419cc:	004462c0 	call	4462c <puts>
		printf("Value in the Enable Register: 0x%x\n", IORD_ALTERA_AVALON_PWM_ENABLE(address)); 
   419d0:	e0bffe17 	ldw	r2,-8(fp)
   419d4:	10800204 	addi	r2,r2,8
   419d8:	10800037 	ldwio	r2,0(r2)
   419dc:	100b883a 	mov	r5,r2
   419e0:	01000134 	movhi	r4,4
   419e4:	2119a904 	addi	r4,r4,26276
   419e8:	00445600 	call	44560 <printf>
  	break;
   419ec:	00000106 	br	419f4 <print_error+0xe8>
  default:
  	break; 		     
   419f0:	0001883a 	nop
	}
while(1);
   419f4:	003fff06 	br	419f4 <__alt_data_end+0xfffd99f4>

000419f8 <getSong>:
int defscale = 6;
int bpm = 63;
int silence = 0;
char *p;

uint8_t getSong(void) {
   419f8:	deffff04 	addi	sp,sp,-4
   419fc:	df000015 	stw	fp,0(sp)
   41a00:	d839883a 	mov	fp,sp
  return song_index;
   41a04:	d0a0fa03 	ldbu	r2,-31768(gp)
}
   41a08:	e037883a 	mov	sp,fp
   41a0c:	df000017 	ldw	fp,0(sp)
   41a10:	dec00104 	addi	sp,sp,4
   41a14:	f800283a 	ret

00041a18 <upSong>:

uint8_t upSong(void) {
   41a18:	deffff04 	addi	sp,sp,-4
   41a1c:	df000015 	stw	fp,0(sp)
   41a20:	d839883a 	mov	fp,sp
  if (song_index == sizeof(song)) {
   41a24:	d0a0fa03 	ldbu	r2,-31768(gp)
   41a28:	10803fcc 	andi	r2,r2,255
   41a2c:	10801f18 	cmpnei	r2,r2,124
   41a30:	1000021e 	bne	r2,zero,41a3c <upSong+0x24>
    song_index = 0;
   41a34:	d020fa05 	stb	zero,-31768(gp)
   41a38:	00000306 	br	41a48 <upSong+0x30>
  }
  else {
    song_index++;
   41a3c:	d0a0fa03 	ldbu	r2,-31768(gp)
   41a40:	10800044 	addi	r2,r2,1
   41a44:	d0a0fa05 	stb	r2,-31768(gp)
  }
  return song_index;
   41a48:	d0a0fa03 	ldbu	r2,-31768(gp)
}
   41a4c:	e037883a 	mov	sp,fp
   41a50:	df000017 	ldw	fp,0(sp)
   41a54:	dec00104 	addi	sp,sp,4
   41a58:	f800283a 	ret

00041a5c <downSong>:

uint8_t downSong(void) {
   41a5c:	deffff04 	addi	sp,sp,-4
   41a60:	df000015 	stw	fp,0(sp)
   41a64:	d839883a 	mov	fp,sp
  if (song_index == 0) {
   41a68:	d0a0fa03 	ldbu	r2,-31768(gp)
   41a6c:	10803fcc 	andi	r2,r2,255
   41a70:	1000031e 	bne	r2,zero,41a80 <downSong+0x24>
    song_index = sizeof(song);
   41a74:	00801f04 	movi	r2,124
   41a78:	d0a0fa05 	stb	r2,-31768(gp)
   41a7c:	00000306 	br	41a8c <downSong+0x30>
  }
  else {
    song_index--;
   41a80:	d0a0fa03 	ldbu	r2,-31768(gp)
   41a84:	10bfffc4 	addi	r2,r2,-1
   41a88:	d0a0fa05 	stb	r2,-31768(gp)
  }
  return song_index;
   41a8c:	d0a0fa03 	ldbu	r2,-31768(gp)
}
   41a90:	e037883a 	mov	sp,fp
   41a94:	df000017 	ldw	fp,0(sp)
   41a98:	dec00104 	addi	sp,sp,4
   41a9c:	f800283a 	ret

00041aa0 <note2freq>:

int note2freq(int note) {
   41aa0:	defffc04 	addi	sp,sp,-16
   41aa4:	dfc00315 	stw	ra,12(sp)
   41aa8:	df000215 	stw	fp,8(sp)
   41aac:	dc000115 	stw	r16,4(sp)
   41ab0:	df000204 	addi	fp,sp,8
   41ab4:	e13ffe15 	stw	r4,-8(fp)
  return notefreq[note % 12] / (1 << (9 - (note / 12)));
   41ab8:	e0bffe17 	ldw	r2,-8(fp)
   41abc:	01400304 	movi	r5,12
   41ac0:	1009883a 	mov	r4,r2
   41ac4:	00431780 	call	43178 <__modsi3>
   41ac8:	1007883a 	mov	r3,r2
   41acc:	00800174 	movhi	r2,5
   41ad0:	10a04404 	addi	r2,r2,-32496
   41ad4:	18c7883a 	add	r3,r3,r3
   41ad8:	18c7883a 	add	r3,r3,r3
   41adc:	10c5883a 	add	r2,r2,r3
   41ae0:	14000017 	ldw	r16,0(r2)
   41ae4:	e0bffe17 	ldw	r2,-8(fp)
   41ae8:	01400304 	movi	r5,12
   41aec:	1009883a 	mov	r4,r2
   41af0:	00430f40 	call	430f4 <__divsi3>
   41af4:	1007883a 	mov	r3,r2
   41af8:	00800244 	movi	r2,9
   41afc:	10c5c83a 	sub	r2,r2,r3
   41b00:	00c00044 	movi	r3,1
   41b04:	1884983a 	sll	r2,r3,r2
   41b08:	100b883a 	mov	r5,r2
   41b0c:	8009883a 	mov	r4,r16
   41b10:	00430f40 	call	430f4 <__divsi3>
}
   41b14:	e6ffff04 	addi	sp,fp,-4
   41b18:	dfc00217 	ldw	ra,8(sp)
   41b1c:	df000117 	ldw	fp,4(sp)
   41b20:	dc000017 	ldw	r16,0(sp)
   41b24:	dec00304 	addi	sp,sp,12
   41b28:	f800283a 	ret

00041b2c <playSong>:

struct note_info playSong(void) {
   41b2c:	defff804 	addi	sp,sp,-32
   41b30:	dfc00715 	stw	ra,28(sp)
   41b34:	df000615 	stw	fp,24(sp)
   41b38:	df000604 	addi	fp,sp,24
   41b3c:	e13fff15 	stw	r4,-4(fp)

  p = song[song_index];
   41b40:	d0a0fa03 	ldbu	r2,-31768(gp)
   41b44:	10c03fcc 	andi	r3,r2,255
   41b48:	00800174 	movhi	r2,5
   41b4c:	10a02504 	addi	r2,r2,-32620
   41b50:	18c7883a 	add	r3,r3,r3
   41b54:	18c7883a 	add	r3,r3,r3
   41b58:	10c5883a 	add	r2,r2,r3
   41b5c:	10800017 	ldw	r2,0(r2)
   41b60:	d0a0fc15 	stw	r2,-31760(gp)
  
  // Skip name
  while (*p && *p != ':') p++;
   41b64:	00000306 	br	41b74 <playSong+0x48>
   41b68:	d0a0fc17 	ldw	r2,-31760(gp)
   41b6c:	10800044 	addi	r2,r2,1
   41b70:	d0a0fc15 	stw	r2,-31760(gp)
   41b74:	d0a0fc17 	ldw	r2,-31760(gp)
   41b78:	10800003 	ldbu	r2,0(r2)
   41b7c:	10803fcc 	andi	r2,r2,255
   41b80:	1080201c 	xori	r2,r2,128
   41b84:	10bfe004 	addi	r2,r2,-128
   41b88:	10000726 	beq	r2,zero,41ba8 <playSong+0x7c>
   41b8c:	d0a0fc17 	ldw	r2,-31760(gp)
   41b90:	10800003 	ldbu	r2,0(r2)
   41b94:	10803fcc 	andi	r2,r2,255
   41b98:	1080201c 	xori	r2,r2,128
   41b9c:	10bfe004 	addi	r2,r2,-128
   41ba0:	10800e98 	cmpnei	r2,r2,58
   41ba4:	103ff01e 	bne	r2,zero,41b68 <__alt_data_end+0xfffd9b68>
  if (!*p) {printf("ERROR in rtttl.c: 0 after name:\n"); return;}
   41ba8:	d0a0fc17 	ldw	r2,-31760(gp)
   41bac:	10800003 	ldbu	r2,0(r2)
   41bb0:	10803fcc 	andi	r2,r2,255
   41bb4:	1080201c 	xori	r2,r2,128
   41bb8:	10bfe004 	addi	r2,r2,-128
   41bbc:	1000041e 	bne	r2,zero,41bd0 <playSong+0xa4>
   41bc0:	01000134 	movhi	r4,4
   41bc4:	211f9604 	addi	r4,r4,32344
   41bc8:	004462c0 	call	4462c <puts>
   41bcc:	00008c06 	br	41e00 <playSong+0x2d4>
  p++;
   41bd0:	d0a0fc17 	ldw	r2,-31760(gp)
   41bd4:	10800044 	addi	r2,r2,1
   41bd8:	d0a0fc15 	stw	r2,-31760(gp)

  // Parse defaults
  while (*p) {
   41bdc:	00007206 	br	41da8 <playSong+0x27c>
    char param;
    int value;

    while (*p == ' ') p++;
   41be0:	d0a0fc17 	ldw	r2,-31760(gp)
   41be4:	10800044 	addi	r2,r2,1
   41be8:	d0a0fc15 	stw	r2,-31760(gp)
   41bec:	d0a0fc17 	ldw	r2,-31760(gp)
   41bf0:	10800003 	ldbu	r2,0(r2)
   41bf4:	10803fcc 	andi	r2,r2,255
   41bf8:	1080201c 	xori	r2,r2,128
   41bfc:	10bfe004 	addi	r2,r2,-128
   41c00:	10800820 	cmpeqi	r2,r2,32
   41c04:	103ff61e 	bne	r2,zero,41be0 <__alt_data_end+0xfffd9be0>
    if (!*p) {printf("ERROR in rtttl.c: defaults: never found\n"); return;}
   41c08:	d0a0fc17 	ldw	r2,-31760(gp)
   41c0c:	10800003 	ldbu	r2,0(r2)
   41c10:	10803fcc 	andi	r2,r2,255
   41c14:	1080201c 	xori	r2,r2,128
   41c18:	10bfe004 	addi	r2,r2,-128
   41c1c:	1000041e 	bne	r2,zero,41c30 <playSong+0x104>
   41c20:	01000134 	movhi	r4,4
   41c24:	211f9e04 	addi	r4,r4,32376
   41c28:	004462c0 	call	4462c <puts>
   41c2c:	00007406 	br	41e00 <playSong+0x2d4>
    if (*p == ':') break;
   41c30:	d0a0fc17 	ldw	r2,-31760(gp)
   41c34:	10800003 	ldbu	r2,0(r2)
   41c38:	10803fcc 	andi	r2,r2,255
   41c3c:	1080201c 	xori	r2,r2,128
   41c40:	10bfe004 	addi	r2,r2,-128
   41c44:	10800e98 	cmpnei	r2,r2,58
   41c48:	10005e26 	beq	r2,zero,41dc4 <playSong+0x298>

    param = *p++;
   41c4c:	d0a0fc17 	ldw	r2,-31760(gp)
   41c50:	10c00044 	addi	r3,r2,1
   41c54:	d0e0fc15 	stw	r3,-31760(gp)
   41c58:	10800003 	ldbu	r2,0(r2)
   41c5c:	e0bffb05 	stb	r2,-20(fp)
    if (*p != '=') {printf("ERROR in rtttl.c: = never found\n"); return;}
   41c60:	d0a0fc17 	ldw	r2,-31760(gp)
   41c64:	10800003 	ldbu	r2,0(r2)
   41c68:	10803fcc 	andi	r2,r2,255
   41c6c:	1080201c 	xori	r2,r2,128
   41c70:	10bfe004 	addi	r2,r2,-128
   41c74:	10800f60 	cmpeqi	r2,r2,61
   41c78:	1000041e 	bne	r2,zero,41c8c <playSong+0x160>
   41c7c:	01000134 	movhi	r4,4
   41c80:	211fa804 	addi	r4,r4,32416
   41c84:	004462c0 	call	4462c <puts>
   41c88:	00005d06 	br	41e00 <playSong+0x2d4>
    
    p++;
   41c8c:	d0a0fc17 	ldw	r2,-31760(gp)
   41c90:	10800044 	addi	r2,r2,1
   41c94:	d0a0fc15 	stw	r2,-31760(gp)
    value = 0;
   41c98:	e03ffa15 	stw	zero,-24(fp)
    while (*p >= '0' && *p <= '9') value = value * 10 + (*p++ - '0');
   41c9c:	00000c06 	br	41cd0 <playSong+0x1a4>
   41ca0:	e0bffa17 	ldw	r2,-24(fp)
   41ca4:	10c002a4 	muli	r3,r2,10
   41ca8:	d0a0fc17 	ldw	r2,-31760(gp)
   41cac:	11000044 	addi	r4,r2,1
   41cb0:	d120fc15 	stw	r4,-31760(gp)
   41cb4:	10800003 	ldbu	r2,0(r2)
   41cb8:	10803fcc 	andi	r2,r2,255
   41cbc:	1080201c 	xori	r2,r2,128
   41cc0:	10bfe004 	addi	r2,r2,-128
   41cc4:	10bff404 	addi	r2,r2,-48
   41cc8:	1885883a 	add	r2,r3,r2
   41ccc:	e0bffa15 	stw	r2,-24(fp)
   41cd0:	d0a0fc17 	ldw	r2,-31760(gp)
   41cd4:	10800003 	ldbu	r2,0(r2)
   41cd8:	10803fcc 	andi	r2,r2,255
   41cdc:	1080201c 	xori	r2,r2,128
   41ce0:	10bfe004 	addi	r2,r2,-128
   41ce4:	10800c10 	cmplti	r2,r2,48
   41ce8:	1000071e 	bne	r2,zero,41d08 <playSong+0x1dc>
   41cec:	d0a0fc17 	ldw	r2,-31760(gp)
   41cf0:	10800003 	ldbu	r2,0(r2)
   41cf4:	10803fcc 	andi	r2,r2,255
   41cf8:	1080201c 	xori	r2,r2,128
   41cfc:	10bfe004 	addi	r2,r2,-128
   41d00:	10800e90 	cmplti	r2,r2,58
   41d04:	103fe61e 	bne	r2,zero,41ca0 <__alt_data_end+0xfffd9ca0>

    switch (param) {
   41d08:	e0bffb07 	ldb	r2,-20(fp)
   41d0c:	10c01920 	cmpeqi	r3,r2,100
   41d10:	1800051e 	bne	r3,zero,41d28 <playSong+0x1fc>
   41d14:	10c01be0 	cmpeqi	r3,r2,111
   41d18:	1800081e 	bne	r3,zero,41d3c <playSong+0x210>
   41d1c:	108018a0 	cmpeqi	r2,r2,98
   41d20:	1000091e 	bne	r2,zero,41d48 <playSong+0x21c>
   41d24:	00000b06 	br	41d54 <playSong+0x228>
      case 'd': defdur = 32 / value; break;
   41d28:	e17ffa17 	ldw	r5,-24(fp)
   41d2c:	01000804 	movi	r4,32
   41d30:	00430f40 	call	430f4 <__divsi3>
   41d34:	d0a00115 	stw	r2,-32764(gp)
   41d38:	00000606 	br	41d54 <playSong+0x228>
      case 'o': defscale = value; break;
   41d3c:	e0bffa17 	ldw	r2,-24(fp)
   41d40:	d0a00215 	stw	r2,-32760(gp)
   41d44:	00000306 	br	41d54 <playSong+0x228>
      case 'b': bpm = value; break;
   41d48:	e0bffa17 	ldw	r2,-24(fp)
   41d4c:	d0a00315 	stw	r2,-32756(gp)
   41d50:	0001883a 	nop
    }

    while (*p == ' ') p++;
   41d54:	00000306 	br	41d64 <playSong+0x238>
   41d58:	d0a0fc17 	ldw	r2,-31760(gp)
   41d5c:	10800044 	addi	r2,r2,1
   41d60:	d0a0fc15 	stw	r2,-31760(gp)
   41d64:	d0a0fc17 	ldw	r2,-31760(gp)
   41d68:	10800003 	ldbu	r2,0(r2)
   41d6c:	10803fcc 	andi	r2,r2,255
   41d70:	1080201c 	xori	r2,r2,128
   41d74:	10bfe004 	addi	r2,r2,-128
   41d78:	10800820 	cmpeqi	r2,r2,32
   41d7c:	103ff61e 	bne	r2,zero,41d58 <__alt_data_end+0xfffd9d58>
    if (*p == ',') p++;
   41d80:	d0a0fc17 	ldw	r2,-31760(gp)
   41d84:	10800003 	ldbu	r2,0(r2)
   41d88:	10803fcc 	andi	r2,r2,255
   41d8c:	1080201c 	xori	r2,r2,128
   41d90:	10bfe004 	addi	r2,r2,-128
   41d94:	10800b18 	cmpnei	r2,r2,44
   41d98:	1000031e 	bne	r2,zero,41da8 <playSong+0x27c>
   41d9c:	d0a0fc17 	ldw	r2,-31760(gp)
   41da0:	10800044 	addi	r2,r2,1
   41da4:	d0a0fc15 	stw	r2,-31760(gp)
  while (*p && *p != ':') p++;
  if (!*p) {printf("ERROR in rtttl.c: 0 after name:\n"); return;}
  p++;

  // Parse defaults
  while (*p) {
   41da8:	d0a0fc17 	ldw	r2,-31760(gp)
   41dac:	10800003 	ldbu	r2,0(r2)
   41db0:	10803fcc 	andi	r2,r2,255
   41db4:	1080201c 	xori	r2,r2,128
   41db8:	10bfe004 	addi	r2,r2,-128
   41dbc:	103f8b1e 	bne	r2,zero,41bec <__alt_data_end+0xfffd9bec>
   41dc0:	00000106 	br	41dc8 <playSong+0x29c>
    char param;
    int value;

    while (*p == ' ') p++;
    if (!*p) {printf("ERROR in rtttl.c: defaults: never found\n"); return;}
    if (*p == ':') break;
   41dc4:	0001883a 	nop
    }

    while (*p == ' ') p++;
    if (*p == ',') p++;
  }
  p++;
   41dc8:	d0a0fc17 	ldw	r2,-31760(gp)
   41dcc:	10800044 	addi	r2,r2,1
   41dd0:	d0a0fc15 	stw	r2,-31760(gp)

  // get the first note of the song
  struct note_info payload;
  payload = getNote();
   41dd4:	e0bffc04 	addi	r2,fp,-16
   41dd8:	1009883a 	mov	r4,r2
   41ddc:	0041e180 	call	41e18 <getNote>
  return payload;
   41de0:	e0bfff17 	ldw	r2,-4(fp)
   41de4:	e0fffc17 	ldw	r3,-16(fp)
   41de8:	10c00015 	stw	r3,0(r2)
   41dec:	e0fffd17 	ldw	r3,-12(fp)
   41df0:	10c00115 	stw	r3,4(r2)
   41df4:	e0fffe17 	ldw	r3,-8(fp)
   41df8:	10c00215 	stw	r3,8(r2)
   41dfc:	00000006 	br	41e00 <playSong+0x2d4>

}
   41e00:	e0bfff17 	ldw	r2,-4(fp)
   41e04:	e037883a 	mov	sp,fp
   41e08:	dfc00117 	ldw	ra,4(sp)
   41e0c:	df000017 	ldw	fp,0(sp)
   41e10:	dec00204 	addi	sp,sp,8
   41e14:	f800283a 	ret

00041e18 <getNote>:

// used to get the first note of the song and the subsequent ones
struct note_info getNote(void) {
   41e18:	defff404 	addi	sp,sp,-48
   41e1c:	dfc00b15 	stw	ra,44(sp)
   41e20:	df000a15 	stw	fp,40(sp)
   41e24:	df000a04 	addi	fp,sp,40
   41e28:	e13fff15 	stw	r4,-4(fp)

  int note = -1;
   41e2c:	00bfffc4 	movi	r2,-1
   41e30:	e0bff615 	stw	r2,-40(fp)
  int scale = defscale;
   41e34:	d0a00217 	ldw	r2,-32760(gp)
   41e38:	e0bff715 	stw	r2,-36(fp)
  int dur = defdur;
   41e3c:	d0a00117 	ldw	r2,-32764(gp)
   41e40:	e0bff815 	stw	r2,-32(fp)
  int ms;
  int freq;
  struct note_info payload;

  if (!*p) {printf("End of song!\n");payload.endofsong = TRUE; return payload;}
   41e44:	d0a0fc17 	ldw	r2,-31760(gp)
   41e48:	10800003 	ldbu	r2,0(r2)
   41e4c:	10803fcc 	andi	r2,r2,255
   41e50:	1080201c 	xori	r2,r2,128
   41e54:	10bfe004 	addi	r2,r2,-128
   41e58:	1000101e 	bne	r2,zero,41e9c <getNote+0x84>
   41e5c:	01000134 	movhi	r4,4
   41e60:	211fb004 	addi	r4,r4,32448
   41e64:	004462c0 	call	4462c <puts>
   41e68:	00800044 	movi	r2,1
   41e6c:	e0bffe15 	stw	r2,-8(fp)
   41e70:	e0bfff17 	ldw	r2,-4(fp)
   41e74:	e0fffc17 	ldw	r3,-16(fp)
   41e78:	10c00015 	stw	r3,0(r2)
   41e7c:	e0fffd17 	ldw	r3,-12(fp)
   41e80:	10c00115 	stw	r3,4(r2)
   41e84:	e0fffe17 	ldw	r3,-8(fp)
   41e88:	10c00215 	stw	r3,8(r2)
   41e8c:	00017606 	br	42468 <getNote+0x650>

  else {


    // Skip whitespace
    while (*p == ' ') p++;
   41e90:	d0a0fc17 	ldw	r2,-31760(gp)
   41e94:	10800044 	addi	r2,r2,1
   41e98:	d0a0fc15 	stw	r2,-31760(gp)
   41e9c:	d0a0fc17 	ldw	r2,-31760(gp)
   41ea0:	10800003 	ldbu	r2,0(r2)
   41ea4:	10803fcc 	andi	r2,r2,255
   41ea8:	1080201c 	xori	r2,r2,128
   41eac:	10bfe004 	addi	r2,r2,-128
   41eb0:	10800820 	cmpeqi	r2,r2,32
   41eb4:	103ff61e 	bne	r2,zero,41e90 <__alt_data_end+0xfffd9e90>
    if (!*p) {printf("ERROR in rtttl.c: 0 found during getNote\n"); return;}
   41eb8:	d0a0fc17 	ldw	r2,-31760(gp)
   41ebc:	10800003 	ldbu	r2,0(r2)
   41ec0:	10803fcc 	andi	r2,r2,255
   41ec4:	1080201c 	xori	r2,r2,128
   41ec8:	10bfe004 	addi	r2,r2,-128
   41ecc:	1000041e 	bne	r2,zero,41ee0 <getNote+0xc8>
   41ed0:	01000134 	movhi	r4,4
   41ed4:	211fb404 	addi	r4,r4,32464
   41ed8:	004462c0 	call	4462c <puts>
   41edc:	00016206 	br	42468 <getNote+0x650>

    // Parse duration
    if (*p >= '0' && *p <= '9') {
   41ee0:	d0a0fc17 	ldw	r2,-31760(gp)
   41ee4:	10800003 	ldbu	r2,0(r2)
   41ee8:	10803fcc 	andi	r2,r2,255
   41eec:	1080201c 	xori	r2,r2,128
   41ef0:	10bfe004 	addi	r2,r2,-128
   41ef4:	10800c10 	cmplti	r2,r2,48
   41ef8:	1000271e 	bne	r2,zero,41f98 <getNote+0x180>
   41efc:	d0a0fc17 	ldw	r2,-31760(gp)
   41f00:	10800003 	ldbu	r2,0(r2)
   41f04:	10803fcc 	andi	r2,r2,255
   41f08:	1080201c 	xori	r2,r2,128
   41f0c:	10bfe004 	addi	r2,r2,-128
   41f10:	10800e88 	cmpgei	r2,r2,58
   41f14:	1000201e 	bne	r2,zero,41f98 <getNote+0x180>
      int value = 0;
   41f18:	e03ffa15 	stw	zero,-24(fp)
      while (*p >= '0' && *p <= '9') value = value * 10 + (*p++ - '0');
   41f1c:	00000c06 	br	41f50 <getNote+0x138>
   41f20:	e0bffa17 	ldw	r2,-24(fp)
   41f24:	10c002a4 	muli	r3,r2,10
   41f28:	d0a0fc17 	ldw	r2,-31760(gp)
   41f2c:	11000044 	addi	r4,r2,1
   41f30:	d120fc15 	stw	r4,-31760(gp)
   41f34:	10800003 	ldbu	r2,0(r2)
   41f38:	10803fcc 	andi	r2,r2,255
   41f3c:	1080201c 	xori	r2,r2,128
   41f40:	10bfe004 	addi	r2,r2,-128
   41f44:	10bff404 	addi	r2,r2,-48
   41f48:	1885883a 	add	r2,r3,r2
   41f4c:	e0bffa15 	stw	r2,-24(fp)
   41f50:	d0a0fc17 	ldw	r2,-31760(gp)
   41f54:	10800003 	ldbu	r2,0(r2)
   41f58:	10803fcc 	andi	r2,r2,255
   41f5c:	1080201c 	xori	r2,r2,128
   41f60:	10bfe004 	addi	r2,r2,-128
   41f64:	10800c10 	cmplti	r2,r2,48
   41f68:	1000071e 	bne	r2,zero,41f88 <getNote+0x170>
   41f6c:	d0a0fc17 	ldw	r2,-31760(gp)
   41f70:	10800003 	ldbu	r2,0(r2)
   41f74:	10803fcc 	andi	r2,r2,255
   41f78:	1080201c 	xori	r2,r2,128
   41f7c:	10bfe004 	addi	r2,r2,-128
   41f80:	10800e90 	cmplti	r2,r2,58
   41f84:	103fe61e 	bne	r2,zero,41f20 <__alt_data_end+0xfffd9f20>

      dur = 32 / value;
   41f88:	e17ffa17 	ldw	r5,-24(fp)
   41f8c:	01000804 	movi	r4,32
   41f90:	00430f40 	call	430f4 <__divsi3>
   41f94:	e0bff815 	stw	r2,-32(fp)
    }

    // Parse note
    switch (*p) {
   41f98:	d0a0fc17 	ldw	r2,-31760(gp)
   41f9c:	10800003 	ldbu	r2,0(r2)
   41fa0:	10803fcc 	andi	r2,r2,255
   41fa4:	1080201c 	xori	r2,r2,128
   41fa8:	10bfe004 	addi	r2,r2,-128
   41fac:	10c01c68 	cmpgeui	r3,r2,113
   41fb0:	18009e1e 	bne	r3,zero,4222c <getNote+0x414>
   41fb4:	100690ba 	slli	r3,r2,2
   41fb8:	00800134 	movhi	r2,4
   41fbc:	1087f304 	addi	r2,r2,8140
   41fc0:	1885883a 	add	r2,r3,r2
   41fc4:	10800017 	ldw	r2,0(r2)
   41fc8:	1000683a 	jmp	r2
   41fcc:	00042190 	cmplti	zero,zero,4230
   41fd0:	0004222c 	andhi	zero,zero,4232
   41fd4:	0004222c 	andhi	zero,zero,4232
   41fd8:	0004222c 	andhi	zero,zero,4232
   41fdc:	0004222c 	andhi	zero,zero,4232
   41fe0:	0004222c 	andhi	zero,zero,4232
   41fe4:	0004222c 	andhi	zero,zero,4232
   41fe8:	0004222c 	andhi	zero,zero,4232
   41fec:	0004222c 	andhi	zero,zero,4232
   41ff0:	0004222c 	andhi	zero,zero,4232
   41ff4:	0004222c 	andhi	zero,zero,4232
   41ff8:	0004222c 	andhi	zero,zero,4232
   41ffc:	0004222c 	andhi	zero,zero,4232
   42000:	0004222c 	andhi	zero,zero,4232
   42004:	0004222c 	andhi	zero,zero,4232
   42008:	0004222c 	andhi	zero,zero,4232
   4200c:	0004222c 	andhi	zero,zero,4232
   42010:	0004222c 	andhi	zero,zero,4232
   42014:	0004222c 	andhi	zero,zero,4232
   42018:	0004222c 	andhi	zero,zero,4232
   4201c:	0004222c 	andhi	zero,zero,4232
   42020:	0004222c 	andhi	zero,zero,4232
   42024:	0004222c 	andhi	zero,zero,4232
   42028:	0004222c 	andhi	zero,zero,4232
   4202c:	0004222c 	andhi	zero,zero,4232
   42030:	0004222c 	andhi	zero,zero,4232
   42034:	0004222c 	andhi	zero,zero,4232
   42038:	0004222c 	andhi	zero,zero,4232
   4203c:	0004222c 	andhi	zero,zero,4232
   42040:	0004222c 	andhi	zero,zero,4232
   42044:	0004222c 	andhi	zero,zero,4232
   42048:	0004222c 	andhi	zero,zero,4232
   4204c:	0004222c 	andhi	zero,zero,4232
   42050:	0004222c 	andhi	zero,zero,4232
   42054:	0004222c 	andhi	zero,zero,4232
   42058:	0004222c 	andhi	zero,zero,4232
   4205c:	0004222c 	andhi	zero,zero,4232
   42060:	0004222c 	andhi	zero,zero,4232
   42064:	0004222c 	andhi	zero,zero,4232
   42068:	0004222c 	andhi	zero,zero,4232
   4206c:	0004222c 	andhi	zero,zero,4232
   42070:	0004222c 	andhi	zero,zero,4232
   42074:	0004222c 	andhi	zero,zero,4232
   42078:	0004222c 	andhi	zero,zero,4232
   4207c:	0004222c 	andhi	zero,zero,4232
   42080:	0004222c 	andhi	zero,zero,4232
   42084:	0004222c 	andhi	zero,zero,4232
   42088:	0004222c 	andhi	zero,zero,4232
   4208c:	0004222c 	andhi	zero,zero,4232
   42090:	0004222c 	andhi	zero,zero,4232
   42094:	0004222c 	andhi	zero,zero,4232
   42098:	0004222c 	andhi	zero,zero,4232
   4209c:	0004222c 	andhi	zero,zero,4232
   420a0:	0004222c 	andhi	zero,zero,4232
   420a4:	0004222c 	andhi	zero,zero,4232
   420a8:	0004222c 	andhi	zero,zero,4232
   420ac:	0004222c 	andhi	zero,zero,4232
   420b0:	0004222c 	andhi	zero,zero,4232
   420b4:	0004222c 	andhi	zero,zero,4232
   420b8:	0004222c 	andhi	zero,zero,4232
   420bc:	0004222c 	andhi	zero,zero,4232
   420c0:	0004222c 	andhi	zero,zero,4232
   420c4:	0004222c 	andhi	zero,zero,4232
   420c8:	0004222c 	andhi	zero,zero,4232
   420cc:	0004222c 	andhi	zero,zero,4232
   420d0:	000421fc 	xorhi	zero,zero,4231
   420d4:	00042214 	movui	zero,4232
   420d8:	000421c4 	movi	zero,4231
   420dc:	000421cc 	andi	zero,zero,4231
   420e0:	000421d8 	cmpnei	zero,zero,4231
   420e4:	000421e4 	muli	zero,zero,4231
   420e8:	000421f0 	cmpltui	zero,zero,4231
   420ec:	00042208 	cmpgei	zero,zero,4232
   420f0:	0004222c 	andhi	zero,zero,4232
   420f4:	0004222c 	andhi	zero,zero,4232
   420f8:	0004222c 	andhi	zero,zero,4232
   420fc:	0004222c 	andhi	zero,zero,4232
   42100:	0004222c 	andhi	zero,zero,4232
   42104:	0004222c 	andhi	zero,zero,4232
   42108:	0004222c 	andhi	zero,zero,4232
   4210c:	00042220 	cmpeqi	zero,zero,4232
   42110:	0004222c 	andhi	zero,zero,4232
   42114:	0004222c 	andhi	zero,zero,4232
   42118:	0004222c 	andhi	zero,zero,4232
   4211c:	0004222c 	andhi	zero,zero,4232
   42120:	0004222c 	andhi	zero,zero,4232
   42124:	0004222c 	andhi	zero,zero,4232
   42128:	0004222c 	andhi	zero,zero,4232
   4212c:	0004222c 	andhi	zero,zero,4232
   42130:	0004222c 	andhi	zero,zero,4232
   42134:	0004222c 	andhi	zero,zero,4232
   42138:	0004222c 	andhi	zero,zero,4232
   4213c:	0004222c 	andhi	zero,zero,4232
   42140:	0004222c 	andhi	zero,zero,4232
   42144:	0004222c 	andhi	zero,zero,4232
   42148:	0004222c 	andhi	zero,zero,4232
   4214c:	0004222c 	andhi	zero,zero,4232
   42150:	000421fc 	xorhi	zero,zero,4231
   42154:	00042214 	movui	zero,4232
   42158:	000421c4 	movi	zero,4231
   4215c:	000421cc 	andi	zero,zero,4231
   42160:	000421d8 	cmpnei	zero,zero,4231
   42164:	000421e4 	muli	zero,zero,4231
   42168:	000421f0 	cmpltui	zero,zero,4231
   4216c:	00042208 	cmpgei	zero,zero,4232
   42170:	0004222c 	andhi	zero,zero,4232
   42174:	0004222c 	andhi	zero,zero,4232
   42178:	0004222c 	andhi	zero,zero,4232
   4217c:	0004222c 	andhi	zero,zero,4232
   42180:	0004222c 	andhi	zero,zero,4232
   42184:	0004222c 	andhi	zero,zero,4232
   42188:	0004222c 	andhi	zero,zero,4232
   4218c:	00042220 	cmpeqi	zero,zero,4232
      case 0: printf("End of song!\n"); payload.endofsong = TRUE; return payload; // i *think* means the null-terminated character is reached
   42190:	01000134 	movhi	r4,4
   42194:	211fb004 	addi	r4,r4,32448
   42198:	004462c0 	call	4462c <puts>
   4219c:	00800044 	movi	r2,1
   421a0:	e0bffe15 	stw	r2,-8(fp)
   421a4:	e0bfff17 	ldw	r2,-4(fp)
   421a8:	e0fffc17 	ldw	r3,-16(fp)
   421ac:	10c00015 	stw	r3,0(r2)
   421b0:	e0fffd17 	ldw	r3,-12(fp)
   421b4:	10c00115 	stw	r3,4(r2)
   421b8:	e0fffe17 	ldw	r3,-8(fp)
   421bc:	10c00215 	stw	r3,8(r2)
   421c0:	0000a906 	br	42468 <getNote+0x650>
      case 'C': case 'c': note = 0; break;
   421c4:	e03ff615 	stw	zero,-40(fp)
   421c8:	00001806 	br	4222c <getNote+0x414>
      case 'D': case 'd': note = 2; break;
   421cc:	00800084 	movi	r2,2
   421d0:	e0bff615 	stw	r2,-40(fp)
   421d4:	00001506 	br	4222c <getNote+0x414>
      case 'E': case 'e': note = 4; break;
   421d8:	00800104 	movi	r2,4
   421dc:	e0bff615 	stw	r2,-40(fp)
   421e0:	00001206 	br	4222c <getNote+0x414>
      case 'F': case 'f': note = 5; break;
   421e4:	00800144 	movi	r2,5
   421e8:	e0bff615 	stw	r2,-40(fp)
   421ec:	00000f06 	br	4222c <getNote+0x414>
      case 'G': case 'g': note = 7; break;
   421f0:	008001c4 	movi	r2,7
   421f4:	e0bff615 	stw	r2,-40(fp)
   421f8:	00000c06 	br	4222c <getNote+0x414>
      case 'A': case 'a': note = 9; break;
   421fc:	00800244 	movi	r2,9
   42200:	e0bff615 	stw	r2,-40(fp)
   42204:	00000906 	br	4222c <getNote+0x414>
      case 'H': case 'h': note = 11; break;
   42208:	008002c4 	movi	r2,11
   4220c:	e0bff615 	stw	r2,-40(fp)
   42210:	00000606 	br	4222c <getNote+0x414>
      case 'B': case 'b': note = 11; break;
   42214:	008002c4 	movi	r2,11
   42218:	e0bff615 	stw	r2,-40(fp)
   4221c:	00000306 	br	4222c <getNote+0x414>
      case 'P': case 'p': note = -1; break;
   42220:	00bfffc4 	movi	r2,-1
   42224:	e0bff615 	stw	r2,-40(fp)
   42228:	0001883a 	nop
    }
    p++;
   4222c:	d0a0fc17 	ldw	r2,-31760(gp)
   42230:	10800044 	addi	r2,r2,1
   42234:	d0a0fc15 	stw	r2,-31760(gp)
    if (*p == '#') {
   42238:	d0a0fc17 	ldw	r2,-31760(gp)
   4223c:	10800003 	ldbu	r2,0(r2)
   42240:	10803fcc 	andi	r2,r2,255
   42244:	1080201c 	xori	r2,r2,128
   42248:	10bfe004 	addi	r2,r2,-128
   4224c:	108008d8 	cmpnei	r2,r2,35
   42250:	1000061e 	bne	r2,zero,4226c <getNote+0x454>
      note++;
   42254:	e0bff617 	ldw	r2,-40(fp)
   42258:	10800044 	addi	r2,r2,1
   4225c:	e0bff615 	stw	r2,-40(fp)
      p++;
   42260:	d0a0fc17 	ldw	r2,-31760(gp)
   42264:	10800044 	addi	r2,r2,1
   42268:	d0a0fc15 	stw	r2,-31760(gp)
    }
    if (*p == 'b') {
   4226c:	d0a0fc17 	ldw	r2,-31760(gp)
   42270:	10800003 	ldbu	r2,0(r2)
   42274:	10803fcc 	andi	r2,r2,255
   42278:	1080201c 	xori	r2,r2,128
   4227c:	10bfe004 	addi	r2,r2,-128
   42280:	10801898 	cmpnei	r2,r2,98
   42284:	1000061e 	bne	r2,zero,422a0 <getNote+0x488>
      note--;
   42288:	e0bff617 	ldw	r2,-40(fp)
   4228c:	10bfffc4 	addi	r2,r2,-1
   42290:	e0bff615 	stw	r2,-40(fp)
      p++;
   42294:	d0a0fc17 	ldw	r2,-31760(gp)
   42298:	10800044 	addi	r2,r2,1
   4229c:	d0a0fc15 	stw	r2,-31760(gp)
    }

    // Parse special duration
    if (*p == '.') {
   422a0:	d0a0fc17 	ldw	r2,-31760(gp)
   422a4:	10800003 	ldbu	r2,0(r2)
   422a8:	10803fcc 	andi	r2,r2,255
   422ac:	1080201c 	xori	r2,r2,128
   422b0:	10bfe004 	addi	r2,r2,-128
   422b4:	10800b98 	cmpnei	r2,r2,46
   422b8:	10000b1e 	bne	r2,zero,422e8 <getNote+0x4d0>
      dur += dur / 2;
   422bc:	e0bff817 	ldw	r2,-32(fp)
   422c0:	1006d7fa 	srli	r3,r2,31
   422c4:	1885883a 	add	r2,r3,r2
   422c8:	1005d07a 	srai	r2,r2,1
   422cc:	1007883a 	mov	r3,r2
   422d0:	e0bff817 	ldw	r2,-32(fp)
   422d4:	10c5883a 	add	r2,r2,r3
   422d8:	e0bff815 	stw	r2,-32(fp)
      p++;
   422dc:	d0a0fc17 	ldw	r2,-31760(gp)
   422e0:	10800044 	addi	r2,r2,1
   422e4:	d0a0fc15 	stw	r2,-31760(gp)
    }

    // Parse scale
    if (*p >= '0' && *p <= '9') scale = (*p++ - '0');
   422e8:	d0a0fc17 	ldw	r2,-31760(gp)
   422ec:	10800003 	ldbu	r2,0(r2)
   422f0:	10803fcc 	andi	r2,r2,255
   422f4:	1080201c 	xori	r2,r2,128
   422f8:	10bfe004 	addi	r2,r2,-128
   422fc:	10800c10 	cmplti	r2,r2,48
   42300:	1000101e 	bne	r2,zero,42344 <getNote+0x52c>
   42304:	d0a0fc17 	ldw	r2,-31760(gp)
   42308:	10800003 	ldbu	r2,0(r2)
   4230c:	10803fcc 	andi	r2,r2,255
   42310:	1080201c 	xori	r2,r2,128
   42314:	10bfe004 	addi	r2,r2,-128
   42318:	10800e88 	cmpgei	r2,r2,58
   4231c:	1000091e 	bne	r2,zero,42344 <getNote+0x52c>
   42320:	d0a0fc17 	ldw	r2,-31760(gp)
   42324:	10c00044 	addi	r3,r2,1
   42328:	d0e0fc15 	stw	r3,-31760(gp)
   4232c:	10800003 	ldbu	r2,0(r2)
   42330:	10803fcc 	andi	r2,r2,255
   42334:	1080201c 	xori	r2,r2,128
   42338:	10bfe004 	addi	r2,r2,-128
   4233c:	10bff404 	addi	r2,r2,-48
   42340:	e0bff715 	stw	r2,-36(fp)

    // Parse special duration (again...)
    if (*p == '.') {
   42344:	d0a0fc17 	ldw	r2,-31760(gp)
   42348:	10800003 	ldbu	r2,0(r2)
   4234c:	10803fcc 	andi	r2,r2,255
   42350:	1080201c 	xori	r2,r2,128
   42354:	10bfe004 	addi	r2,r2,-128
   42358:	10800b98 	cmpnei	r2,r2,46
   4235c:	10000f1e 	bne	r2,zero,4239c <getNote+0x584>
      dur += dur / 2;
   42360:	e0bff817 	ldw	r2,-32(fp)
   42364:	1006d7fa 	srli	r3,r2,31
   42368:	1885883a 	add	r2,r3,r2
   4236c:	1005d07a 	srai	r2,r2,1
   42370:	1007883a 	mov	r3,r2
   42374:	e0bff817 	ldw	r2,-32(fp)
   42378:	10c5883a 	add	r2,r2,r3
   4237c:	e0bff815 	stw	r2,-32(fp)
      p++;
   42380:	d0a0fc17 	ldw	r2,-31760(gp)
   42384:	10800044 	addi	r2,r2,1
   42388:	d0a0fc15 	stw	r2,-31760(gp)
    }

    // Skip delimiter
    while (*p == ' ') p++;
   4238c:	00000306 	br	4239c <getNote+0x584>
   42390:	d0a0fc17 	ldw	r2,-31760(gp)
   42394:	10800044 	addi	r2,r2,1
   42398:	d0a0fc15 	stw	r2,-31760(gp)
   4239c:	d0a0fc17 	ldw	r2,-31760(gp)
   423a0:	10800003 	ldbu	r2,0(r2)
   423a4:	10803fcc 	andi	r2,r2,255
   423a8:	1080201c 	xori	r2,r2,128
   423ac:	10bfe004 	addi	r2,r2,-128
   423b0:	10800820 	cmpeqi	r2,r2,32
   423b4:	103ff61e 	bne	r2,zero,42390 <__alt_data_end+0xfffda390>
    if (*p == ',') p++;
   423b8:	d0a0fc17 	ldw	r2,-31760(gp)
   423bc:	10800003 	ldbu	r2,0(r2)
   423c0:	10803fcc 	andi	r2,r2,255
   423c4:	1080201c 	xori	r2,r2,128
   423c8:	10bfe004 	addi	r2,r2,-128
   423cc:	10800b18 	cmpnei	r2,r2,44
   423d0:	1000031e 	bne	r2,zero,423e0 <getNote+0x5c8>
   423d4:	d0a0fc17 	ldw	r2,-31760(gp)
   423d8:	10800044 	addi	r2,r2,1
   423dc:	d0a0fc15 	stw	r2,-31760(gp)

    // Play note
    ms = dur * 60000 / (bpm * 8);
   423e0:	e0fff817 	ldw	r3,-32(fp)
   423e4:	00ba9814 	movui	r2,60000
   423e8:	1887383a 	mul	r3,r3,r2
   423ec:	d0a00317 	ldw	r2,-32756(gp)
   423f0:	100490fa 	slli	r2,r2,3
   423f4:	100b883a 	mov	r5,r2
   423f8:	1809883a 	mov	r4,r3
   423fc:	00430f40 	call	430f4 <__divsi3>
   42400:	e0bffb15 	stw	r2,-20(fp)
    if (note == -1) {
   42404:	e0bff617 	ldw	r2,-40(fp)
   42408:	10bfffd8 	cmpnei	r2,r2,-1
   4240c:	1000021e 	bne	r2,zero,42418 <getNote+0x600>
      freq = 0;
   42410:	e03ff915 	stw	zero,-28(fp)
   42414:	00000806 	br	42438 <getNote+0x620>
    } else {
      freq = note2freq((scale + 1) * 12 + note);
   42418:	e0bff717 	ldw	r2,-36(fp)
   4241c:	10800044 	addi	r2,r2,1
   42420:	10c00324 	muli	r3,r2,12
   42424:	e0bff617 	ldw	r2,-40(fp)
   42428:	1885883a 	add	r2,r3,r2
   4242c:	1009883a 	mov	r4,r2
   42430:	0041aa00 	call	41aa0 <note2freq>
   42434:	e0bff915 	stw	r2,-28(fp)
    }


    payload.frequency = freq;
   42438:	e0bff917 	ldw	r2,-28(fp)
   4243c:	e0bffc15 	stw	r2,-16(fp)
    payload.duration = ms;
   42440:	e0bffb17 	ldw	r2,-20(fp)
   42444:	e0bffd15 	stw	r2,-12(fp)
    payload.endofsong = FALSE;
   42448:	e03ffe15 	stw	zero,-8(fp)
    
    return payload;   
   4244c:	e0bfff17 	ldw	r2,-4(fp)
   42450:	e0fffc17 	ldw	r3,-16(fp)
   42454:	10c00015 	stw	r3,0(r2)
   42458:	e0fffd17 	ldw	r3,-12(fp)
   4245c:	10c00115 	stw	r3,4(r2)
   42460:	e0fffe17 	ldw	r3,-8(fp)
   42464:	10c00215 	stw	r3,8(r2)
    
  }
   42468:	e0bfff17 	ldw	r2,-4(fp)
   4246c:	e037883a 	mov	sp,fp
   42470:	dfc00117 	ldw	ra,4(sp)
   42474:	df000017 	ldw	fp,0(sp)
   42478:	dec00204 	addi	sp,sp,8
   4247c:	f800283a 	ret

00042480 <determineMode>:
#include "switches.h" 

struct mode determineMode(void) {
   42480:	defff904 	addi	sp,sp,-28
   42484:	dfc00615 	stw	ra,24(sp)
   42488:	df000515 	stw	fp,20(sp)
   4248c:	dc400415 	stw	r17,16(sp)
   42490:	dc000315 	stw	r16,12(sp)
   42494:	df000504 	addi	fp,sp,20
  ISR, the current mode is known allowing us to determine if an 
  invalid mode was requested */
  static struct mode mode;

  // this variable lets us test whether or not an invalid mode was requested
  volatile uint16_t switches_state_request = IORD_ALTERA_AVALON_PIO_DATA(SWITCHES_BASE);
   42498:	00800234 	movhi	r2,8
   4249c:	10843804 	addi	r2,r2,4320
   424a0:	10800037 	ldwio	r2,0(r2)
   424a4:	e0bffd0d 	sth	r2,-12(fp)

  // check if the request is invalid
  if (checkInvalidMode(switches_state_request) == INVALID) {
   424a8:	e0bffd0b 	ldhu	r2,-12(fp)
   424ac:	10bfffcc 	andi	r2,r2,65535
   424b0:	1009883a 	mov	r4,r2
   424b4:	00426fc0 	call	426fc <checkInvalidMode>
   424b8:	10803fcc 	andi	r2,r2,255
   424bc:	10800058 	cmpnei	r2,r2,1
   424c0:	10000f1e 	bne	r2,zero,42500 <determineMode+0x80>
    mode.invalid = TRUE;
   424c4:	00800044 	movi	r2,1
   424c8:	d0a0fd05 	stb	r2,-31756(gp)
    return mode;
   424cc:	d0a0fd03 	ldbu	r2,-31756(gp)
   424d0:	e0bffb45 	stb	r2,-19(fp)
   424d4:	d0a0fd43 	ldbu	r2,-31755(gp)
   424d8:	e0bffb85 	stb	r2,-18(fp)
   424dc:	d0a0fd83 	ldbu	r2,-31754(gp)
   424e0:	e0bffbc5 	stb	r2,-17(fp)
   424e4:	d0a0fdc3 	ldbu	r2,-31753(gp)
   424e8:	e0bffc05 	stb	r2,-16(fp)
   424ec:	d0a0fe03 	ldbu	r2,-31752(gp)
   424f0:	e0bffc45 	stb	r2,-15(fp)
   424f4:	d0a0fe43 	ldbu	r2,-31751(gp)
   424f8:	e0bffc85 	stb	r2,-14(fp)
   424fc:	00004906 	br	42624 <determineMode+0x1a4>
  }

  else {
    // now that we know the mode request is valid, let's determine what it is
    mode.invalid = FALSE;
   42500:	d020fd05 	stb	zero,-31756(gp)

    uint8_t i = 0;
   42504:	e03ffb05 	stb	zero,-20(fp)

    // check for the valid mode request in lookup table
    while (switches_state_request != mode_lookup_table[i][0]) {
   42508:	00000606 	br	42524 <determineMode+0xa4>
      i++;
   4250c:	e0bffb03 	ldbu	r2,-20(fp)
   42510:	10800044 	addi	r2,r2,1
   42514:	e0bffb05 	stb	r2,-20(fp)
      // catch error in case the bounds of the lookup table are exceeded
      if (i == NUM_VALID_MODES) {
   42518:	e0bffb03 	ldbu	r2,-20(fp)
   4251c:	10800218 	cmpnei	r2,r2,8
   42520:	10000b26 	beq	r2,zero,42550 <determineMode+0xd0>
    mode.invalid = FALSE;

    uint8_t i = 0;

    // check for the valid mode request in lookup table
    while (switches_state_request != mode_lookup_table[i][0]) {
   42524:	e0fffb03 	ldbu	r3,-20(fp)
   42528:	00800134 	movhi	r2,4
   4252c:	109fbe84 	addi	r2,r2,32506
   42530:	18c00324 	muli	r3,r3,12
   42534:	10c5883a 	add	r2,r2,r3
   42538:	10c0000b 	ldhu	r3,0(r2)
   4253c:	e0bffd0b 	ldhu	r2,-12(fp)
   42540:	18ffffcc 	andi	r3,r3,65535
   42544:	10bfffcc 	andi	r2,r2,65535
   42548:	18bff01e 	bne	r3,r2,4250c <__alt_data_end+0xfffda50c>
   4254c:	00000106 	br	42554 <determineMode+0xd4>
      i++;
      // catch error in case the bounds of the lookup table are exceeded
      if (i == NUM_VALID_MODES) {
        break;
   42550:	0001883a 	nop
    }

    // once the valid mode request is find, the while loop ends and we have found
    // the correct mode; its location is determined by the index i
    // at this point, we can update the members of the mode struct
    mode.display = mode_lookup_table[i][1];
   42554:	e0fffb03 	ldbu	r3,-20(fp)
   42558:	00800134 	movhi	r2,4
   4255c:	109fbe84 	addi	r2,r2,32506
   42560:	18c00324 	muli	r3,r3,12
   42564:	10c5883a 	add	r2,r2,r3
   42568:	10800084 	addi	r2,r2,2
   4256c:	1080000b 	ldhu	r2,0(r2)
   42570:	d0a0fd45 	stb	r2,-31755(gp)
    mode.config.on = mode_lookup_table[i][2];
   42574:	e0fffb03 	ldbu	r3,-20(fp)
   42578:	00800134 	movhi	r2,4
   4257c:	109fbe84 	addi	r2,r2,32506
   42580:	18c00324 	muli	r3,r3,12
   42584:	10c5883a 	add	r2,r2,r3
   42588:	10800104 	addi	r2,r2,4
   4258c:	1080000b 	ldhu	r2,0(r2)
   42590:	d0a0fdc5 	stb	r2,-31753(gp)
    mode.config.hour = mode_lookup_table[i][3];
   42594:	e0fffb03 	ldbu	r3,-20(fp)
   42598:	00800134 	movhi	r2,4
   4259c:	109fbe84 	addi	r2,r2,32506
   425a0:	18c00324 	muli	r3,r3,12
   425a4:	10c5883a 	add	r2,r2,r3
   425a8:	10800184 	addi	r2,r2,6
   425ac:	1080000b 	ldhu	r2,0(r2)
   425b0:	d0a0fe05 	stb	r2,-31752(gp)
    mode.config.minute = mode_lookup_table[i][4];
   425b4:	e0fffb03 	ldbu	r3,-20(fp)
   425b8:	00800134 	movhi	r2,4
   425bc:	109fbe84 	addi	r2,r2,32506
   425c0:	18c00324 	muli	r3,r3,12
   425c4:	10c5883a 	add	r2,r2,r3
   425c8:	10800204 	addi	r2,r2,8
   425cc:	1080000b 	ldhu	r2,0(r2)
   425d0:	d0a0fe45 	stb	r2,-31751(gp)
    mode.alarm = mode_lookup_table[i][5];
   425d4:	e0fffb03 	ldbu	r3,-20(fp)
   425d8:	00800134 	movhi	r2,4
   425dc:	109fbe84 	addi	r2,r2,32506
   425e0:	18c00324 	muli	r3,r3,12
   425e4:	10c5883a 	add	r2,r2,r3
   425e8:	10800284 	addi	r2,r2,10
   425ec:	1080000b 	ldhu	r2,0(r2)
   425f0:	d0a0fd85 	stb	r2,-31754(gp)

    return mode;
   425f4:	d0a0fd03 	ldbu	r2,-31756(gp)
   425f8:	e0bffb45 	stb	r2,-19(fp)
   425fc:	d0a0fd43 	ldbu	r2,-31755(gp)
   42600:	e0bffb85 	stb	r2,-18(fp)
   42604:	d0a0fd83 	ldbu	r2,-31754(gp)
   42608:	e0bffbc5 	stb	r2,-17(fp)
   4260c:	d0a0fdc3 	ldbu	r2,-31753(gp)
   42610:	e0bffc05 	stb	r2,-16(fp)
   42614:	d0a0fe03 	ldbu	r2,-31752(gp)
   42618:	e0bffc45 	stb	r2,-15(fp)
   4261c:	d0a0fe43 	ldbu	r2,-31751(gp)
   42620:	e0bffc85 	stb	r2,-14(fp)
   42624:	0005883a 	mov	r2,zero
   42628:	e0fffb43 	ldbu	r3,-19(fp)
   4262c:	18c03fcc 	andi	r3,r3,255
   42630:	013fc004 	movi	r4,-256
   42634:	1104703a 	and	r2,r2,r4
   42638:	10c4b03a 	or	r2,r2,r3
   4263c:	e0fffb83 	ldbu	r3,-18(fp)
   42640:	18c03fcc 	andi	r3,r3,255
   42644:	1808923a 	slli	r4,r3,8
   42648:	00fffff4 	movhi	r3,65535
   4264c:	18c03fc4 	addi	r3,r3,255
   42650:	10c4703a 	and	r2,r2,r3
   42654:	1104b03a 	or	r2,r2,r4
   42658:	e0fffbc3 	ldbu	r3,-17(fp)
   4265c:	18c03fcc 	andi	r3,r3,255
   42660:	1808943a 	slli	r4,r3,16
   42664:	00ffc074 	movhi	r3,65281
   42668:	18ffffc4 	addi	r3,r3,-1
   4266c:	10c4703a 	and	r2,r2,r3
   42670:	1104b03a 	or	r2,r2,r4
   42674:	e0fffc03 	ldbu	r3,-16(fp)
   42678:	1808963a 	slli	r4,r3,24
   4267c:	00c04034 	movhi	r3,256
   42680:	18ffffc4 	addi	r3,r3,-1
   42684:	10c4703a 	and	r2,r2,r3
   42688:	1104b03a 	or	r2,r2,r4
   4268c:	0009883a 	mov	r4,zero
   42690:	e0fffc43 	ldbu	r3,-15(fp)
   42694:	18c03fcc 	andi	r3,r3,255
   42698:	017fc004 	movi	r5,-256
   4269c:	2148703a 	and	r4,r4,r5
   426a0:	20c6b03a 	or	r3,r4,r3
   426a4:	1809883a 	mov	r4,r3
   426a8:	e0fffc83 	ldbu	r3,-14(fp)
   426ac:	18c03fcc 	andi	r3,r3,255
   426b0:	180a923a 	slli	r5,r3,8
   426b4:	00fffff4 	movhi	r3,65535
   426b8:	18c03fc4 	addi	r3,r3,255
   426bc:	20c6703a 	and	r3,r4,r3
   426c0:	1946b03a 	or	r3,r3,r5
   426c4:	1809883a 	mov	r4,r3
   426c8:	1021883a 	mov	r16,r2
   426cc:	2023883a 	mov	r17,r4
   426d0:	8007883a 	mov	r3,r16
   426d4:	8809883a 	mov	r4,r17
  }

}
   426d8:	1805883a 	mov	r2,r3
   426dc:	2007883a 	mov	r3,r4
   426e0:	e6fffe04 	addi	sp,fp,-8
   426e4:	dfc00317 	ldw	ra,12(sp)
   426e8:	df000217 	ldw	fp,8(sp)
   426ec:	dc400117 	ldw	r17,4(sp)
   426f0:	dc000017 	ldw	r16,0(sp)
   426f4:	dec00404 	addi	sp,sp,16
   426f8:	f800283a 	ret

000426fc <checkInvalidMode>:

uint8_t checkInvalidMode(uint16_t switches_state_request) {
   426fc:	defffc04 	addi	sp,sp,-16
   42700:	dfc00315 	stw	ra,12(sp)
   42704:	df000215 	stw	fp,8(sp)
   42708:	df000204 	addi	fp,sp,8
   4270c:	2005883a 	mov	r2,r4
   42710:	e0bfff0d 	sth	r2,-4(fp)
  // check if an unused switch was turned on
  uint8_t i = 0;
   42714:	e03ffe05 	stb	zero,-8(fp)

  do {
    // if the entire array of unused_switches was searched but an
    // unused switch was not activated, then exit while loop
    if (i == NUM_UNUSED_SWITCHES) {
   42718:	e0bffe03 	ldbu	r2,-8(fp)
   4271c:	108000d8 	cmpnei	r2,r2,3
   42720:	10000e26 	beq	r2,zero,4275c <checkInvalidMode+0x60>
      break;
    }
    // if an unused switch was activated, exit function and indicate that
    // an invalid mode was selected
    else if (switches_state_request == unused_switches[i]) {
   42724:	e0bffe03 	ldbu	r2,-8(fp)
   42728:	1087883a 	add	r3,r2,r2
   4272c:	d0a00404 	addi	r2,gp,-32752
   42730:	1885883a 	add	r2,r3,r2
   42734:	1080000b 	ldhu	r2,0(r2)
   42738:	10ffffcc 	andi	r3,r2,65535
   4273c:	e0bfff0b 	ldhu	r2,-4(fp)
   42740:	1880021e 	bne	r3,r2,4274c <checkInvalidMode+0x50>
      return INVALID;
   42744:	00800044 	movi	r2,1
   42748:	00000e06 	br	42784 <checkInvalidMode+0x88>
    }

    // increment index of unused_switches array
    i++;
   4274c:	e0bffe03 	ldbu	r2,-8(fp)
   42750:	10800044 	addi	r2,r2,1
   42754:	e0bffe05 	stb	r2,-8(fp)

  } while(1);
   42758:	003fef06 	br	42718 <__alt_data_end+0xfffda718>

  do {
    // if the entire array of unused_switches was searched but an
    // unused switch was not activated, then exit while loop
    if (i == NUM_UNUSED_SWITCHES) {
      break;
   4275c:	0001883a 	nop

  } while(1);

  // now that we know an unused switch is not activated, we need to verify that 
  // the used switches are in a valid configuration
  if ( isPowerOfTwoOrZero(switches_state_request) == TRUE ) {
   42760:	e0bfff0b 	ldhu	r2,-4(fp)
   42764:	1009883a 	mov	r4,r2
   42768:	00427980 	call	42798 <isPowerOfTwoOrZero>
   4276c:	10803fcc 	andi	r2,r2,255
   42770:	10800058 	cmpnei	r2,r2,1
   42774:	1000021e 	bne	r2,zero,42780 <checkInvalidMode+0x84>
    return VALID;
   42778:	0005883a 	mov	r2,zero
   4277c:	00000106 	br	42784 <checkInvalidMode+0x88>
  }

  else {
    return INVALID;
   42780:	00800044 	movi	r2,1
  }
}
   42784:	e037883a 	mov	sp,fp
   42788:	dfc00117 	ldw	ra,4(sp)
   4278c:	df000017 	ldw	fp,0(sp)
   42790:	dec00204 	addi	sp,sp,8
   42794:	f800283a 	ret

00042798 <isPowerOfTwoOrZero>:
6 & 5  != 0 -> invalid!
7 & 6  != 0 -> invalid!
---------------------------------------------
*/ 

uint8_t isPowerOfTwoOrZero(uint16_t value) {
   42798:	defffe04 	addi	sp,sp,-8
   4279c:	df000115 	stw	fp,4(sp)
   427a0:	df000104 	addi	fp,sp,4
   427a4:	2005883a 	mov	r2,r4
   427a8:	e0bfff0d 	sth	r2,-4(fp)
  if ((value & (value-1)) == 0) {
   427ac:	e0ffff0b 	ldhu	r3,-4(fp)
   427b0:	e0bfff0b 	ldhu	r2,-4(fp)
   427b4:	10bfffc4 	addi	r2,r2,-1
   427b8:	1884703a 	and	r2,r3,r2
   427bc:	1000021e 	bne	r2,zero,427c8 <isPowerOfTwoOrZero+0x30>
    return TRUE;
   427c0:	00800044 	movi	r2,1
   427c4:	00000106 	br	427cc <isPowerOfTwoOrZero+0x34>
  }
  else {
    return FALSE;
   427c8:	0005883a 	mov	r2,zero
  }
   427cc:	e037883a 	mov	sp,fp
   427d0:	df000017 	ldw	fp,0(sp)
   427d4:	dec00104 	addi	sp,sp,4
   427d8:	f800283a 	ret

000427dc <resetClockTime>:


/* ------------------------ CLOCK functions ---------------------- */

// initialize clock time to default time (see display.h)
void resetClockTime(void) {
   427dc:	deffff04 	addi	sp,sp,-4
   427e0:	df000015 	stw	fp,0(sp)
   427e4:	d839883a 	mov	fp,sp
  clock.hour = reset_clock_value[0];
   427e8:	008002c4 	movi	r2,11
   427ec:	d0a0ff45 	stb	r2,-31747(gp)
  clock.minute = reset_clock_value[1];
   427f0:	00800ec4 	movi	r2,59
   427f4:	d0a0ff85 	stb	r2,-31746(gp)
  clock.second = reset_clock_value[2];
   427f8:	0005883a 	mov	r2,zero
   427fc:	d0a0ffc5 	stb	r2,-31745(gp)
}
   42800:	0001883a 	nop
   42804:	e037883a 	mov	sp,fp
   42808:	df000017 	ldw	fp,0(sp)
   4280c:	dec00104 	addi	sp,sp,4
   42810:	f800283a 	ret

00042814 <getClockTime>:

struct time getClockTime(void) {
   42814:	defffe04 	addi	sp,sp,-8
   42818:	df000115 	stw	fp,4(sp)
   4281c:	df000104 	addi	fp,sp,4
  return clock;
   42820:	d0a0ff43 	ldbu	r2,-31747(gp)
   42824:	e0bfff05 	stb	r2,-4(fp)
   42828:	d0a0ff83 	ldbu	r2,-31746(gp)
   4282c:	e0bfff45 	stb	r2,-3(fp)
   42830:	d0a0ffc3 	ldbu	r2,-31745(gp)
   42834:	e0bfff85 	stb	r2,-2(fp)
   42838:	0005883a 	mov	r2,zero
   4283c:	e0ffff03 	ldbu	r3,-4(fp)
   42840:	18c03fcc 	andi	r3,r3,255
   42844:	013fc004 	movi	r4,-256
   42848:	1104703a 	and	r2,r2,r4
   4284c:	10c4b03a 	or	r2,r2,r3
   42850:	e0ffff43 	ldbu	r3,-3(fp)
   42854:	18c03fcc 	andi	r3,r3,255
   42858:	1808923a 	slli	r4,r3,8
   4285c:	00fffff4 	movhi	r3,65535
   42860:	18c03fc4 	addi	r3,r3,255
   42864:	10c4703a 	and	r2,r2,r3
   42868:	1104b03a 	or	r2,r2,r4
   4286c:	e0ffff83 	ldbu	r3,-2(fp)
   42870:	18c03fcc 	andi	r3,r3,255
   42874:	1808943a 	slli	r4,r3,16
   42878:	00ffc074 	movhi	r3,65281
   4287c:	18ffffc4 	addi	r3,r3,-1
   42880:	10c4703a 	and	r2,r2,r3
   42884:	1104b03a 	or	r2,r2,r4
}
   42888:	e037883a 	mov	sp,fp
   4288c:	df000017 	ldw	fp,0(sp)
   42890:	dec00104 	addi	sp,sp,4
   42894:	f800283a 	ret

00042898 <upClockSecond>:

/*--------- up operations -------*/

// SECONDS
struct time upClockSecond(uint8_t carry_setting) {
   42898:	defffc04 	addi	sp,sp,-16
   4289c:	dfc00315 	stw	ra,12(sp)
   428a0:	df000215 	stw	fp,8(sp)
   428a4:	df000204 	addi	fp,sp,8
   428a8:	2005883a 	mov	r2,r4
   428ac:	e0bfff05 	stb	r2,-4(fp)
  if (clock.second == (ONE_MINUTE-1)) {
   428b0:	d0a0ffc3 	ldbu	r2,-31745(gp)
   428b4:	10803fcc 	andi	r2,r2,255
   428b8:	10800ed8 	cmpnei	r2,r2,59
   428bc:	1000071e 	bne	r2,zero,428dc <upClockSecond+0x44>
    clock.second = 0;
   428c0:	d020ffc5 	stb	zero,-31745(gp)
    
    if (carry_setting == CARRY_ON) {
   428c4:	e0bfff03 	ldbu	r2,-4(fp)
   428c8:	10800058 	cmpnei	r2,r2,1
   428cc:	1000061e 	bne	r2,zero,428e8 <upClockSecond+0x50>
      upClockMinute(CARRY_ON);
   428d0:	01000044 	movi	r4,1
   428d4:	00429640 	call	42964 <upClockMinute>
   428d8:	00000306 	br	428e8 <upClockSecond+0x50>
    }
  }
  else {
    clock.second++;
   428dc:	d0a0ffc3 	ldbu	r2,-31745(gp)
   428e0:	10800044 	addi	r2,r2,1
   428e4:	d0a0ffc5 	stb	r2,-31745(gp)
  }
  return clock;
   428e8:	d0a0ff43 	ldbu	r2,-31747(gp)
   428ec:	e0bffe05 	stb	r2,-8(fp)
   428f0:	d0a0ff83 	ldbu	r2,-31746(gp)
   428f4:	e0bffe45 	stb	r2,-7(fp)
   428f8:	d0a0ffc3 	ldbu	r2,-31745(gp)
   428fc:	e0bffe85 	stb	r2,-6(fp)
   42900:	0005883a 	mov	r2,zero
   42904:	e0fffe03 	ldbu	r3,-8(fp)
   42908:	18c03fcc 	andi	r3,r3,255
   4290c:	013fc004 	movi	r4,-256
   42910:	1104703a 	and	r2,r2,r4
   42914:	10c4b03a 	or	r2,r2,r3
   42918:	e0fffe43 	ldbu	r3,-7(fp)
   4291c:	18c03fcc 	andi	r3,r3,255
   42920:	1808923a 	slli	r4,r3,8
   42924:	00fffff4 	movhi	r3,65535
   42928:	18c03fc4 	addi	r3,r3,255
   4292c:	10c4703a 	and	r2,r2,r3
   42930:	1104b03a 	or	r2,r2,r4
   42934:	e0fffe83 	ldbu	r3,-6(fp)
   42938:	18c03fcc 	andi	r3,r3,255
   4293c:	1808943a 	slli	r4,r3,16
   42940:	00ffc074 	movhi	r3,65281
   42944:	18ffffc4 	addi	r3,r3,-1
   42948:	10c4703a 	and	r2,r2,r3
   4294c:	1104b03a 	or	r2,r2,r4
}
   42950:	e037883a 	mov	sp,fp
   42954:	dfc00117 	ldw	ra,4(sp)
   42958:	df000017 	ldw	fp,0(sp)
   4295c:	dec00204 	addi	sp,sp,8
   42960:	f800283a 	ret

00042964 <upClockMinute>:

// MINUTES
struct time upClockMinute(uint8_t carry_setting) {
   42964:	defffc04 	addi	sp,sp,-16
   42968:	dfc00315 	stw	ra,12(sp)
   4296c:	df000215 	stw	fp,8(sp)
   42970:	df000204 	addi	fp,sp,8
   42974:	2005883a 	mov	r2,r4
   42978:	e0bfff05 	stb	r2,-4(fp)
  if (clock.minute == (ONE_HOUR-1)) {
   4297c:	d0a0ff83 	ldbu	r2,-31746(gp)
   42980:	10803fcc 	andi	r2,r2,255
   42984:	10800ed8 	cmpnei	r2,r2,59
   42988:	1000061e 	bne	r2,zero,429a4 <upClockMinute+0x40>
    clock.minute = 0;
   4298c:	d020ff85 	stb	zero,-31746(gp)
    
    if (carry_setting == CARRY_ON) {
   42990:	e0bfff03 	ldbu	r2,-4(fp)
   42994:	10800058 	cmpnei	r2,r2,1
   42998:	1000051e 	bne	r2,zero,429b0 <upClockMinute+0x4c>
      upClockHour();
   4299c:	0042a2c0 	call	42a2c <upClockHour>
   429a0:	00000306 	br	429b0 <upClockMinute+0x4c>
    }
  }
  else {
    clock.minute++;
   429a4:	d0a0ff83 	ldbu	r2,-31746(gp)
   429a8:	10800044 	addi	r2,r2,1
   429ac:	d0a0ff85 	stb	r2,-31746(gp)
  }
  return clock;
   429b0:	d0a0ff43 	ldbu	r2,-31747(gp)
   429b4:	e0bffe05 	stb	r2,-8(fp)
   429b8:	d0a0ff83 	ldbu	r2,-31746(gp)
   429bc:	e0bffe45 	stb	r2,-7(fp)
   429c0:	d0a0ffc3 	ldbu	r2,-31745(gp)
   429c4:	e0bffe85 	stb	r2,-6(fp)
   429c8:	0005883a 	mov	r2,zero
   429cc:	e0fffe03 	ldbu	r3,-8(fp)
   429d0:	18c03fcc 	andi	r3,r3,255
   429d4:	013fc004 	movi	r4,-256
   429d8:	1104703a 	and	r2,r2,r4
   429dc:	10c4b03a 	or	r2,r2,r3
   429e0:	e0fffe43 	ldbu	r3,-7(fp)
   429e4:	18c03fcc 	andi	r3,r3,255
   429e8:	1808923a 	slli	r4,r3,8
   429ec:	00fffff4 	movhi	r3,65535
   429f0:	18c03fc4 	addi	r3,r3,255
   429f4:	10c4703a 	and	r2,r2,r3
   429f8:	1104b03a 	or	r2,r2,r4
   429fc:	e0fffe83 	ldbu	r3,-6(fp)
   42a00:	18c03fcc 	andi	r3,r3,255
   42a04:	1808943a 	slli	r4,r3,16
   42a08:	00ffc074 	movhi	r3,65281
   42a0c:	18ffffc4 	addi	r3,r3,-1
   42a10:	10c4703a 	and	r2,r2,r3
   42a14:	1104b03a 	or	r2,r2,r4
}
   42a18:	e037883a 	mov	sp,fp
   42a1c:	dfc00117 	ldw	ra,4(sp)
   42a20:	df000017 	ldw	fp,0(sp)
   42a24:	dec00204 	addi	sp,sp,8
   42a28:	f800283a 	ret

00042a2c <upClockHour>:

// HOURS
struct time upClockHour(void) {
   42a2c:	defffe04 	addi	sp,sp,-8
   42a30:	df000115 	stw	fp,4(sp)
   42a34:	df000104 	addi	fp,sp,4
  if (clock.hour == (time_format-1)) {
   42a38:	d0a0ff43 	ldbu	r2,-31747(gp)
   42a3c:	10c03fcc 	andi	r3,r2,255
   42a40:	d0a00643 	ldbu	r2,-32743(gp)
   42a44:	10803fcc 	andi	r2,r2,255
   42a48:	10bfffc4 	addi	r2,r2,-1
   42a4c:	1880021e 	bne	r3,r2,42a58 <upClockHour+0x2c>
    clock.hour = 0;
   42a50:	d020ff45 	stb	zero,-31747(gp)
   42a54:	00000306 	br	42a64 <upClockHour+0x38>
  }
  else {
    clock.hour++;
   42a58:	d0a0ff43 	ldbu	r2,-31747(gp)
   42a5c:	10800044 	addi	r2,r2,1
   42a60:	d0a0ff45 	stb	r2,-31747(gp)
  }
  return clock;
   42a64:	d0a0ff43 	ldbu	r2,-31747(gp)
   42a68:	e0bfff05 	stb	r2,-4(fp)
   42a6c:	d0a0ff83 	ldbu	r2,-31746(gp)
   42a70:	e0bfff45 	stb	r2,-3(fp)
   42a74:	d0a0ffc3 	ldbu	r2,-31745(gp)
   42a78:	e0bfff85 	stb	r2,-2(fp)
   42a7c:	0005883a 	mov	r2,zero
   42a80:	e0ffff03 	ldbu	r3,-4(fp)
   42a84:	18c03fcc 	andi	r3,r3,255
   42a88:	013fc004 	movi	r4,-256
   42a8c:	1104703a 	and	r2,r2,r4
   42a90:	10c4b03a 	or	r2,r2,r3
   42a94:	e0ffff43 	ldbu	r3,-3(fp)
   42a98:	18c03fcc 	andi	r3,r3,255
   42a9c:	1808923a 	slli	r4,r3,8
   42aa0:	00fffff4 	movhi	r3,65535
   42aa4:	18c03fc4 	addi	r3,r3,255
   42aa8:	10c4703a 	and	r2,r2,r3
   42aac:	1104b03a 	or	r2,r2,r4
   42ab0:	e0ffff83 	ldbu	r3,-2(fp)
   42ab4:	18c03fcc 	andi	r3,r3,255
   42ab8:	1808943a 	slli	r4,r3,16
   42abc:	00ffc074 	movhi	r3,65281
   42ac0:	18ffffc4 	addi	r3,r3,-1
   42ac4:	10c4703a 	and	r2,r2,r3
   42ac8:	1104b03a 	or	r2,r2,r4
}
   42acc:	e037883a 	mov	sp,fp
   42ad0:	df000017 	ldw	fp,0(sp)
   42ad4:	dec00104 	addi	sp,sp,4
   42ad8:	f800283a 	ret

00042adc <downClockSecond>:

/*--------- down operations -------*/

// SECONDS
struct time downClockSecond(uint8_t carry_setting) {
   42adc:	defffc04 	addi	sp,sp,-16
   42ae0:	dfc00315 	stw	ra,12(sp)
   42ae4:	df000215 	stw	fp,8(sp)
   42ae8:	df000204 	addi	fp,sp,8
   42aec:	2005883a 	mov	r2,r4
   42af0:	e0bfff05 	stb	r2,-4(fp)
  if (clock.second == 0) {
   42af4:	d0a0ffc3 	ldbu	r2,-31745(gp)
   42af8:	10803fcc 	andi	r2,r2,255
   42afc:	1000081e 	bne	r2,zero,42b20 <downClockSecond+0x44>
    clock.second = (ONE_MINUTE-1);
   42b00:	00800ec4 	movi	r2,59
   42b04:	d0a0ffc5 	stb	r2,-31745(gp)
    
    if (carry_setting == CARRY_ON) {
   42b08:	e0bfff03 	ldbu	r2,-4(fp)
   42b0c:	10800058 	cmpnei	r2,r2,1
   42b10:	1000061e 	bne	r2,zero,42b2c <downClockSecond+0x50>
      downClockMinute(CARRY_ON);
   42b14:	01000044 	movi	r4,1
   42b18:	0042ba80 	call	42ba8 <downClockMinute>
   42b1c:	00000306 	br	42b2c <downClockSecond+0x50>
    }
  }
  else {
    clock.second--;
   42b20:	d0a0ffc3 	ldbu	r2,-31745(gp)
   42b24:	10bfffc4 	addi	r2,r2,-1
   42b28:	d0a0ffc5 	stb	r2,-31745(gp)
  }
  return clock;
   42b2c:	d0a0ff43 	ldbu	r2,-31747(gp)
   42b30:	e0bffe05 	stb	r2,-8(fp)
   42b34:	d0a0ff83 	ldbu	r2,-31746(gp)
   42b38:	e0bffe45 	stb	r2,-7(fp)
   42b3c:	d0a0ffc3 	ldbu	r2,-31745(gp)
   42b40:	e0bffe85 	stb	r2,-6(fp)
   42b44:	0005883a 	mov	r2,zero
   42b48:	e0fffe03 	ldbu	r3,-8(fp)
   42b4c:	18c03fcc 	andi	r3,r3,255
   42b50:	013fc004 	movi	r4,-256
   42b54:	1104703a 	and	r2,r2,r4
   42b58:	10c4b03a 	or	r2,r2,r3
   42b5c:	e0fffe43 	ldbu	r3,-7(fp)
   42b60:	18c03fcc 	andi	r3,r3,255
   42b64:	1808923a 	slli	r4,r3,8
   42b68:	00fffff4 	movhi	r3,65535
   42b6c:	18c03fc4 	addi	r3,r3,255
   42b70:	10c4703a 	and	r2,r2,r3
   42b74:	1104b03a 	or	r2,r2,r4
   42b78:	e0fffe83 	ldbu	r3,-6(fp)
   42b7c:	18c03fcc 	andi	r3,r3,255
   42b80:	1808943a 	slli	r4,r3,16
   42b84:	00ffc074 	movhi	r3,65281
   42b88:	18ffffc4 	addi	r3,r3,-1
   42b8c:	10c4703a 	and	r2,r2,r3
   42b90:	1104b03a 	or	r2,r2,r4
}
   42b94:	e037883a 	mov	sp,fp
   42b98:	dfc00117 	ldw	ra,4(sp)
   42b9c:	df000017 	ldw	fp,0(sp)
   42ba0:	dec00204 	addi	sp,sp,8
   42ba4:	f800283a 	ret

00042ba8 <downClockMinute>:

// MINUTES
struct time downClockMinute(uint8_t carry_setting) {
   42ba8:	defffc04 	addi	sp,sp,-16
   42bac:	dfc00315 	stw	ra,12(sp)
   42bb0:	df000215 	stw	fp,8(sp)
   42bb4:	df000204 	addi	fp,sp,8
   42bb8:	2005883a 	mov	r2,r4
   42bbc:	e0bfff05 	stb	r2,-4(fp)
  if (clock.minute == 0) {
   42bc0:	d0a0ff83 	ldbu	r2,-31746(gp)
   42bc4:	10803fcc 	andi	r2,r2,255
   42bc8:	1000071e 	bne	r2,zero,42be8 <downClockMinute+0x40>
    clock.minute = (ONE_HOUR-1);
   42bcc:	00800ec4 	movi	r2,59
   42bd0:	d0a0ff85 	stb	r2,-31746(gp)
    
    if (carry_setting == CARRY_ON) {
   42bd4:	e0bfff03 	ldbu	r2,-4(fp)
   42bd8:	10800058 	cmpnei	r2,r2,1
   42bdc:	1000051e 	bne	r2,zero,42bf4 <downClockMinute+0x4c>
      downClockHour();
   42be0:	0042c700 	call	42c70 <downClockHour>
   42be4:	00000306 	br	42bf4 <downClockMinute+0x4c>
    }
  }
  else {
    clock.minute--;
   42be8:	d0a0ff83 	ldbu	r2,-31746(gp)
   42bec:	10bfffc4 	addi	r2,r2,-1
   42bf0:	d0a0ff85 	stb	r2,-31746(gp)
  }
  return clock;
   42bf4:	d0a0ff43 	ldbu	r2,-31747(gp)
   42bf8:	e0bffe05 	stb	r2,-8(fp)
   42bfc:	d0a0ff83 	ldbu	r2,-31746(gp)
   42c00:	e0bffe45 	stb	r2,-7(fp)
   42c04:	d0a0ffc3 	ldbu	r2,-31745(gp)
   42c08:	e0bffe85 	stb	r2,-6(fp)
   42c0c:	0005883a 	mov	r2,zero
   42c10:	e0fffe03 	ldbu	r3,-8(fp)
   42c14:	18c03fcc 	andi	r3,r3,255
   42c18:	013fc004 	movi	r4,-256
   42c1c:	1104703a 	and	r2,r2,r4
   42c20:	10c4b03a 	or	r2,r2,r3
   42c24:	e0fffe43 	ldbu	r3,-7(fp)
   42c28:	18c03fcc 	andi	r3,r3,255
   42c2c:	1808923a 	slli	r4,r3,8
   42c30:	00fffff4 	movhi	r3,65535
   42c34:	18c03fc4 	addi	r3,r3,255
   42c38:	10c4703a 	and	r2,r2,r3
   42c3c:	1104b03a 	or	r2,r2,r4
   42c40:	e0fffe83 	ldbu	r3,-6(fp)
   42c44:	18c03fcc 	andi	r3,r3,255
   42c48:	1808943a 	slli	r4,r3,16
   42c4c:	00ffc074 	movhi	r3,65281
   42c50:	18ffffc4 	addi	r3,r3,-1
   42c54:	10c4703a 	and	r2,r2,r3
   42c58:	1104b03a 	or	r2,r2,r4
}
   42c5c:	e037883a 	mov	sp,fp
   42c60:	dfc00117 	ldw	ra,4(sp)
   42c64:	df000017 	ldw	fp,0(sp)
   42c68:	dec00204 	addi	sp,sp,8
   42c6c:	f800283a 	ret

00042c70 <downClockHour>:

// HOURS
struct time downClockHour(void) {
   42c70:	defffe04 	addi	sp,sp,-8
   42c74:	df000115 	stw	fp,4(sp)
   42c78:	df000104 	addi	fp,sp,4
  if (clock.hour == 0) {
   42c7c:	d0a0ff43 	ldbu	r2,-31747(gp)
   42c80:	10803fcc 	andi	r2,r2,255
   42c84:	1000041e 	bne	r2,zero,42c98 <downClockHour+0x28>
    clock.hour = (time_format-1);
   42c88:	d0a00643 	ldbu	r2,-32743(gp)
   42c8c:	10bfffc4 	addi	r2,r2,-1
   42c90:	d0a0ff45 	stb	r2,-31747(gp)
   42c94:	00000306 	br	42ca4 <downClockHour+0x34>
  }
  else {
    clock.hour--;
   42c98:	d0a0ff43 	ldbu	r2,-31747(gp)
   42c9c:	10bfffc4 	addi	r2,r2,-1
   42ca0:	d0a0ff45 	stb	r2,-31747(gp)
  }
  return clock;
   42ca4:	d0a0ff43 	ldbu	r2,-31747(gp)
   42ca8:	e0bfff05 	stb	r2,-4(fp)
   42cac:	d0a0ff83 	ldbu	r2,-31746(gp)
   42cb0:	e0bfff45 	stb	r2,-3(fp)
   42cb4:	d0a0ffc3 	ldbu	r2,-31745(gp)
   42cb8:	e0bfff85 	stb	r2,-2(fp)
   42cbc:	0005883a 	mov	r2,zero
   42cc0:	e0ffff03 	ldbu	r3,-4(fp)
   42cc4:	18c03fcc 	andi	r3,r3,255
   42cc8:	013fc004 	movi	r4,-256
   42ccc:	1104703a 	and	r2,r2,r4
   42cd0:	10c4b03a 	or	r2,r2,r3
   42cd4:	e0ffff43 	ldbu	r3,-3(fp)
   42cd8:	18c03fcc 	andi	r3,r3,255
   42cdc:	1808923a 	slli	r4,r3,8
   42ce0:	00fffff4 	movhi	r3,65535
   42ce4:	18c03fc4 	addi	r3,r3,255
   42ce8:	10c4703a 	and	r2,r2,r3
   42cec:	1104b03a 	or	r2,r2,r4
   42cf0:	e0ffff83 	ldbu	r3,-2(fp)
   42cf4:	18c03fcc 	andi	r3,r3,255
   42cf8:	1808943a 	slli	r4,r3,16
   42cfc:	00ffc074 	movhi	r3,65281
   42d00:	18ffffc4 	addi	r3,r3,-1
   42d04:	10c4703a 	and	r2,r2,r3
   42d08:	1104b03a 	or	r2,r2,r4
}
   42d0c:	e037883a 	mov	sp,fp
   42d10:	df000017 	ldw	fp,0(sp)
   42d14:	dec00104 	addi	sp,sp,4
   42d18:	f800283a 	ret

00042d1c <resetAlarmTime>:


/* ------------------------ ALARM functions ---------------------- */

// initialize alarm time to 00:00 (seconds are turned off)
void resetAlarmTime(void) {
   42d1c:	deffff04 	addi	sp,sp,-4
   42d20:	df000015 	stw	fp,0(sp)
   42d24:	d839883a 	mov	fp,sp
  // necessary to cast to a time struct, otherwise the 
  // value assignment won't work
  alarm =  (struct time){0};
   42d28:	d020fe85 	stb	zero,-31750(gp)
   42d2c:	d020fec5 	stb	zero,-31749(gp)
   42d30:	d020ff05 	stb	zero,-31748(gp)

  // we explicitly request that the seconds are not displayed
  alarm.second = DONT_DISPLAY;
   42d34:	00801904 	movi	r2,100
   42d38:	d0a0ff05 	stb	r2,-31748(gp)
}
   42d3c:	0001883a 	nop
   42d40:	e037883a 	mov	sp,fp
   42d44:	df000017 	ldw	fp,0(sp)
   42d48:	dec00104 	addi	sp,sp,4
   42d4c:	f800283a 	ret

00042d50 <getAlarmTime>:

struct time getAlarmTime(void) {
   42d50:	defffe04 	addi	sp,sp,-8
   42d54:	df000115 	stw	fp,4(sp)
   42d58:	df000104 	addi	fp,sp,4
  return alarm;
   42d5c:	d0a0fe83 	ldbu	r2,-31750(gp)
   42d60:	e0bfff05 	stb	r2,-4(fp)
   42d64:	d0a0fec3 	ldbu	r2,-31749(gp)
   42d68:	e0bfff45 	stb	r2,-3(fp)
   42d6c:	d0a0ff03 	ldbu	r2,-31748(gp)
   42d70:	e0bfff85 	stb	r2,-2(fp)
   42d74:	0005883a 	mov	r2,zero
   42d78:	e0ffff03 	ldbu	r3,-4(fp)
   42d7c:	18c03fcc 	andi	r3,r3,255
   42d80:	013fc004 	movi	r4,-256
   42d84:	1104703a 	and	r2,r2,r4
   42d88:	10c4b03a 	or	r2,r2,r3
   42d8c:	e0ffff43 	ldbu	r3,-3(fp)
   42d90:	18c03fcc 	andi	r3,r3,255
   42d94:	1808923a 	slli	r4,r3,8
   42d98:	00fffff4 	movhi	r3,65535
   42d9c:	18c03fc4 	addi	r3,r3,255
   42da0:	10c4703a 	and	r2,r2,r3
   42da4:	1104b03a 	or	r2,r2,r4
   42da8:	e0ffff83 	ldbu	r3,-2(fp)
   42dac:	18c03fcc 	andi	r3,r3,255
   42db0:	1808943a 	slli	r4,r3,16
   42db4:	00ffc074 	movhi	r3,65281
   42db8:	18ffffc4 	addi	r3,r3,-1
   42dbc:	10c4703a 	and	r2,r2,r3
   42dc0:	1104b03a 	or	r2,r2,r4
}
   42dc4:	e037883a 	mov	sp,fp
   42dc8:	df000017 	ldw	fp,0(sp)
   42dcc:	dec00104 	addi	sp,sp,4
   42dd0:	f800283a 	ret

00042dd4 <upAlarmMinute>:

/*--------- up operations -------*/

// MINUTES
struct time upAlarmMinute(void) {
   42dd4:	defffe04 	addi	sp,sp,-8
   42dd8:	df000115 	stw	fp,4(sp)
   42ddc:	df000104 	addi	fp,sp,4
  if (alarm.minute == (ONE_HOUR-1)) {
   42de0:	d0a0fec3 	ldbu	r2,-31749(gp)
   42de4:	10803fcc 	andi	r2,r2,255
   42de8:	10800ed8 	cmpnei	r2,r2,59
   42dec:	1000021e 	bne	r2,zero,42df8 <upAlarmMinute+0x24>
    alarm.minute = 0;
   42df0:	d020fec5 	stb	zero,-31749(gp)
   42df4:	00000306 	br	42e04 <upAlarmMinute+0x30>
  }
  else {
    alarm.minute++;
   42df8:	d0a0fec3 	ldbu	r2,-31749(gp)
   42dfc:	10800044 	addi	r2,r2,1
   42e00:	d0a0fec5 	stb	r2,-31749(gp)
  }
  return alarm;
   42e04:	d0a0fe83 	ldbu	r2,-31750(gp)
   42e08:	e0bfff05 	stb	r2,-4(fp)
   42e0c:	d0a0fec3 	ldbu	r2,-31749(gp)
   42e10:	e0bfff45 	stb	r2,-3(fp)
   42e14:	d0a0ff03 	ldbu	r2,-31748(gp)
   42e18:	e0bfff85 	stb	r2,-2(fp)
   42e1c:	0005883a 	mov	r2,zero
   42e20:	e0ffff03 	ldbu	r3,-4(fp)
   42e24:	18c03fcc 	andi	r3,r3,255
   42e28:	013fc004 	movi	r4,-256
   42e2c:	1104703a 	and	r2,r2,r4
   42e30:	10c4b03a 	or	r2,r2,r3
   42e34:	e0ffff43 	ldbu	r3,-3(fp)
   42e38:	18c03fcc 	andi	r3,r3,255
   42e3c:	1808923a 	slli	r4,r3,8
   42e40:	00fffff4 	movhi	r3,65535
   42e44:	18c03fc4 	addi	r3,r3,255
   42e48:	10c4703a 	and	r2,r2,r3
   42e4c:	1104b03a 	or	r2,r2,r4
   42e50:	e0ffff83 	ldbu	r3,-2(fp)
   42e54:	18c03fcc 	andi	r3,r3,255
   42e58:	1808943a 	slli	r4,r3,16
   42e5c:	00ffc074 	movhi	r3,65281
   42e60:	18ffffc4 	addi	r3,r3,-1
   42e64:	10c4703a 	and	r2,r2,r3
   42e68:	1104b03a 	or	r2,r2,r4
}
   42e6c:	e037883a 	mov	sp,fp
   42e70:	df000017 	ldw	fp,0(sp)
   42e74:	dec00104 	addi	sp,sp,4
   42e78:	f800283a 	ret

00042e7c <upAlarmHour>:

// HOURS
struct time upAlarmHour(void) {
   42e7c:	defffe04 	addi	sp,sp,-8
   42e80:	df000115 	stw	fp,4(sp)
   42e84:	df000104 	addi	fp,sp,4
  if (alarm.hour == (time_format-1)) {
   42e88:	d0a0fe83 	ldbu	r2,-31750(gp)
   42e8c:	10c03fcc 	andi	r3,r2,255
   42e90:	d0a00643 	ldbu	r2,-32743(gp)
   42e94:	10803fcc 	andi	r2,r2,255
   42e98:	10bfffc4 	addi	r2,r2,-1
   42e9c:	1880021e 	bne	r3,r2,42ea8 <upAlarmHour+0x2c>
    alarm.hour = 0;
   42ea0:	d020fe85 	stb	zero,-31750(gp)
   42ea4:	00000306 	br	42eb4 <upAlarmHour+0x38>
  }
  else {
    alarm.hour++;
   42ea8:	d0a0fe83 	ldbu	r2,-31750(gp)
   42eac:	10800044 	addi	r2,r2,1
   42eb0:	d0a0fe85 	stb	r2,-31750(gp)
  }
  return alarm;
   42eb4:	d0a0fe83 	ldbu	r2,-31750(gp)
   42eb8:	e0bfff05 	stb	r2,-4(fp)
   42ebc:	d0a0fec3 	ldbu	r2,-31749(gp)
   42ec0:	e0bfff45 	stb	r2,-3(fp)
   42ec4:	d0a0ff03 	ldbu	r2,-31748(gp)
   42ec8:	e0bfff85 	stb	r2,-2(fp)
   42ecc:	0005883a 	mov	r2,zero
   42ed0:	e0ffff03 	ldbu	r3,-4(fp)
   42ed4:	18c03fcc 	andi	r3,r3,255
   42ed8:	013fc004 	movi	r4,-256
   42edc:	1104703a 	and	r2,r2,r4
   42ee0:	10c4b03a 	or	r2,r2,r3
   42ee4:	e0ffff43 	ldbu	r3,-3(fp)
   42ee8:	18c03fcc 	andi	r3,r3,255
   42eec:	1808923a 	slli	r4,r3,8
   42ef0:	00fffff4 	movhi	r3,65535
   42ef4:	18c03fc4 	addi	r3,r3,255
   42ef8:	10c4703a 	and	r2,r2,r3
   42efc:	1104b03a 	or	r2,r2,r4
   42f00:	e0ffff83 	ldbu	r3,-2(fp)
   42f04:	18c03fcc 	andi	r3,r3,255
   42f08:	1808943a 	slli	r4,r3,16
   42f0c:	00ffc074 	movhi	r3,65281
   42f10:	18ffffc4 	addi	r3,r3,-1
   42f14:	10c4703a 	and	r2,r2,r3
   42f18:	1104b03a 	or	r2,r2,r4
}
   42f1c:	e037883a 	mov	sp,fp
   42f20:	df000017 	ldw	fp,0(sp)
   42f24:	dec00104 	addi	sp,sp,4
   42f28:	f800283a 	ret

00042f2c <downAlarmMinute>:

/*--------- down operations -------*/

// MINUTES
struct time downAlarmMinute(void) {
   42f2c:	defffe04 	addi	sp,sp,-8
   42f30:	df000115 	stw	fp,4(sp)
   42f34:	df000104 	addi	fp,sp,4
  if (alarm.minute == 0) {
   42f38:	d0a0fec3 	ldbu	r2,-31749(gp)
   42f3c:	10803fcc 	andi	r2,r2,255
   42f40:	1000031e 	bne	r2,zero,42f50 <downAlarmMinute+0x24>
    alarm.minute = (ONE_HOUR-1);
   42f44:	00800ec4 	movi	r2,59
   42f48:	d0a0fec5 	stb	r2,-31749(gp)
   42f4c:	00000306 	br	42f5c <downAlarmMinute+0x30>
  }
  else {
    alarm.minute--;
   42f50:	d0a0fec3 	ldbu	r2,-31749(gp)
   42f54:	10bfffc4 	addi	r2,r2,-1
   42f58:	d0a0fec5 	stb	r2,-31749(gp)
  }
  return alarm;
   42f5c:	d0a0fe83 	ldbu	r2,-31750(gp)
   42f60:	e0bfff05 	stb	r2,-4(fp)
   42f64:	d0a0fec3 	ldbu	r2,-31749(gp)
   42f68:	e0bfff45 	stb	r2,-3(fp)
   42f6c:	d0a0ff03 	ldbu	r2,-31748(gp)
   42f70:	e0bfff85 	stb	r2,-2(fp)
   42f74:	0005883a 	mov	r2,zero
   42f78:	e0ffff03 	ldbu	r3,-4(fp)
   42f7c:	18c03fcc 	andi	r3,r3,255
   42f80:	013fc004 	movi	r4,-256
   42f84:	1104703a 	and	r2,r2,r4
   42f88:	10c4b03a 	or	r2,r2,r3
   42f8c:	e0ffff43 	ldbu	r3,-3(fp)
   42f90:	18c03fcc 	andi	r3,r3,255
   42f94:	1808923a 	slli	r4,r3,8
   42f98:	00fffff4 	movhi	r3,65535
   42f9c:	18c03fc4 	addi	r3,r3,255
   42fa0:	10c4703a 	and	r2,r2,r3
   42fa4:	1104b03a 	or	r2,r2,r4
   42fa8:	e0ffff83 	ldbu	r3,-2(fp)
   42fac:	18c03fcc 	andi	r3,r3,255
   42fb0:	1808943a 	slli	r4,r3,16
   42fb4:	00ffc074 	movhi	r3,65281
   42fb8:	18ffffc4 	addi	r3,r3,-1
   42fbc:	10c4703a 	and	r2,r2,r3
   42fc0:	1104b03a 	or	r2,r2,r4
}
   42fc4:	e037883a 	mov	sp,fp
   42fc8:	df000017 	ldw	fp,0(sp)
   42fcc:	dec00104 	addi	sp,sp,4
   42fd0:	f800283a 	ret

00042fd4 <downAlarmHour>:

// HOURS
struct time downAlarmHour(void) {
   42fd4:	defffe04 	addi	sp,sp,-8
   42fd8:	df000115 	stw	fp,4(sp)
   42fdc:	df000104 	addi	fp,sp,4
  if (alarm.hour == 0) {
   42fe0:	d0a0fe83 	ldbu	r2,-31750(gp)
   42fe4:	10803fcc 	andi	r2,r2,255
   42fe8:	1000041e 	bne	r2,zero,42ffc <downAlarmHour+0x28>
    alarm.hour = (time_format-1);
   42fec:	d0a00643 	ldbu	r2,-32743(gp)
   42ff0:	10bfffc4 	addi	r2,r2,-1
   42ff4:	d0a0fe85 	stb	r2,-31750(gp)
   42ff8:	00000306 	br	43008 <downAlarmHour+0x34>
  }
  else {
    alarm.hour--;
   42ffc:	d0a0fe83 	ldbu	r2,-31750(gp)
   43000:	10bfffc4 	addi	r2,r2,-1
   43004:	d0a0fe85 	stb	r2,-31750(gp)
  }
  return alarm;
   43008:	d0a0fe83 	ldbu	r2,-31750(gp)
   4300c:	e0bfff05 	stb	r2,-4(fp)
   43010:	d0a0fec3 	ldbu	r2,-31749(gp)
   43014:	e0bfff45 	stb	r2,-3(fp)
   43018:	d0a0ff03 	ldbu	r2,-31748(gp)
   4301c:	e0bfff85 	stb	r2,-2(fp)
   43020:	0005883a 	mov	r2,zero
   43024:	e0ffff03 	ldbu	r3,-4(fp)
   43028:	18c03fcc 	andi	r3,r3,255
   4302c:	013fc004 	movi	r4,-256
   43030:	1104703a 	and	r2,r2,r4
   43034:	10c4b03a 	or	r2,r2,r3
   43038:	e0ffff43 	ldbu	r3,-3(fp)
   4303c:	18c03fcc 	andi	r3,r3,255
   43040:	1808923a 	slli	r4,r3,8
   43044:	00fffff4 	movhi	r3,65535
   43048:	18c03fc4 	addi	r3,r3,255
   4304c:	10c4703a 	and	r2,r2,r3
   43050:	1104b03a 	or	r2,r2,r4
   43054:	e0ffff83 	ldbu	r3,-2(fp)
   43058:	18c03fcc 	andi	r3,r3,255
   4305c:	1808943a 	slli	r4,r3,16
   43060:	00ffc074 	movhi	r3,65281
   43064:	18ffffc4 	addi	r3,r3,-1
   43068:	10c4703a 	and	r2,r2,r3
   4306c:	1104b03a 	or	r2,r2,r4
}
   43070:	e037883a 	mov	sp,fp
   43074:	df000017 	ldw	fp,0(sp)
   43078:	dec00104 	addi	sp,sp,4
   4307c:	f800283a 	ret

00043080 <__fixunsdfsi>:
   43080:	defffd04 	addi	sp,sp,-12
   43084:	000d883a 	mov	r6,zero
   43088:	01d07834 	movhi	r7,16864
   4308c:	dc400115 	stw	r17,4(sp)
   43090:	dc000015 	stw	r16,0(sp)
   43094:	dfc00215 	stw	ra,8(sp)
   43098:	2023883a 	mov	r17,r4
   4309c:	2821883a 	mov	r16,r5
   430a0:	00432a80 	call	432a8 <__gedf2>
   430a4:	1000080e 	bge	r2,zero,430c8 <__fixunsdfsi+0x48>
   430a8:	8809883a 	mov	r4,r17
   430ac:	800b883a 	mov	r5,r16
   430b0:	00443980 	call	44398 <__fixdfsi>
   430b4:	dfc00217 	ldw	ra,8(sp)
   430b8:	dc400117 	ldw	r17,4(sp)
   430bc:	dc000017 	ldw	r16,0(sp)
   430c0:	dec00304 	addi	sp,sp,12
   430c4:	f800283a 	ret
   430c8:	000d883a 	mov	r6,zero
   430cc:	01d07834 	movhi	r7,16864
   430d0:	8809883a 	mov	r4,r17
   430d4:	800b883a 	mov	r5,r16
   430d8:	0043a9c0 	call	43a9c <__subdf3>
   430dc:	180b883a 	mov	r5,r3
   430e0:	1009883a 	mov	r4,r2
   430e4:	00443980 	call	44398 <__fixdfsi>
   430e8:	00e00034 	movhi	r3,32768
   430ec:	10c5883a 	add	r2,r2,r3
   430f0:	003ff006 	br	430b4 <__alt_data_end+0xfffdb0b4>

000430f4 <__divsi3>:
   430f4:	20001b16 	blt	r4,zero,43164 <__divsi3+0x70>
   430f8:	000f883a 	mov	r7,zero
   430fc:	28001616 	blt	r5,zero,43158 <__divsi3+0x64>
   43100:	200d883a 	mov	r6,r4
   43104:	29001a2e 	bgeu	r5,r4,43170 <__divsi3+0x7c>
   43108:	00800804 	movi	r2,32
   4310c:	00c00044 	movi	r3,1
   43110:	00000106 	br	43118 <__divsi3+0x24>
   43114:	10000d26 	beq	r2,zero,4314c <__divsi3+0x58>
   43118:	294b883a 	add	r5,r5,r5
   4311c:	10bfffc4 	addi	r2,r2,-1
   43120:	18c7883a 	add	r3,r3,r3
   43124:	293ffb36 	bltu	r5,r4,43114 <__alt_data_end+0xfffdb114>
   43128:	0005883a 	mov	r2,zero
   4312c:	18000726 	beq	r3,zero,4314c <__divsi3+0x58>
   43130:	0005883a 	mov	r2,zero
   43134:	31400236 	bltu	r6,r5,43140 <__divsi3+0x4c>
   43138:	314dc83a 	sub	r6,r6,r5
   4313c:	10c4b03a 	or	r2,r2,r3
   43140:	1806d07a 	srli	r3,r3,1
   43144:	280ad07a 	srli	r5,r5,1
   43148:	183ffa1e 	bne	r3,zero,43134 <__alt_data_end+0xfffdb134>
   4314c:	38000126 	beq	r7,zero,43154 <__divsi3+0x60>
   43150:	0085c83a 	sub	r2,zero,r2
   43154:	f800283a 	ret
   43158:	014bc83a 	sub	r5,zero,r5
   4315c:	39c0005c 	xori	r7,r7,1
   43160:	003fe706 	br	43100 <__alt_data_end+0xfffdb100>
   43164:	0109c83a 	sub	r4,zero,r4
   43168:	01c00044 	movi	r7,1
   4316c:	003fe306 	br	430fc <__alt_data_end+0xfffdb0fc>
   43170:	00c00044 	movi	r3,1
   43174:	003fee06 	br	43130 <__alt_data_end+0xfffdb130>

00043178 <__modsi3>:
   43178:	20001716 	blt	r4,zero,431d8 <__modsi3+0x60>
   4317c:	000f883a 	mov	r7,zero
   43180:	2005883a 	mov	r2,r4
   43184:	28001216 	blt	r5,zero,431d0 <__modsi3+0x58>
   43188:	2900162e 	bgeu	r5,r4,431e4 <__modsi3+0x6c>
   4318c:	01800804 	movi	r6,32
   43190:	00c00044 	movi	r3,1
   43194:	00000106 	br	4319c <__modsi3+0x24>
   43198:	30000a26 	beq	r6,zero,431c4 <__modsi3+0x4c>
   4319c:	294b883a 	add	r5,r5,r5
   431a0:	31bfffc4 	addi	r6,r6,-1
   431a4:	18c7883a 	add	r3,r3,r3
   431a8:	293ffb36 	bltu	r5,r4,43198 <__alt_data_end+0xfffdb198>
   431ac:	18000526 	beq	r3,zero,431c4 <__modsi3+0x4c>
   431b0:	1806d07a 	srli	r3,r3,1
   431b4:	11400136 	bltu	r2,r5,431bc <__modsi3+0x44>
   431b8:	1145c83a 	sub	r2,r2,r5
   431bc:	280ad07a 	srli	r5,r5,1
   431c0:	183ffb1e 	bne	r3,zero,431b0 <__alt_data_end+0xfffdb1b0>
   431c4:	38000126 	beq	r7,zero,431cc <__modsi3+0x54>
   431c8:	0085c83a 	sub	r2,zero,r2
   431cc:	f800283a 	ret
   431d0:	014bc83a 	sub	r5,zero,r5
   431d4:	003fec06 	br	43188 <__alt_data_end+0xfffdb188>
   431d8:	0109c83a 	sub	r4,zero,r4
   431dc:	01c00044 	movi	r7,1
   431e0:	003fe706 	br	43180 <__alt_data_end+0xfffdb180>
   431e4:	00c00044 	movi	r3,1
   431e8:	003ff106 	br	431b0 <__alt_data_end+0xfffdb1b0>

000431ec <__udivsi3>:
   431ec:	200d883a 	mov	r6,r4
   431f0:	2900152e 	bgeu	r5,r4,43248 <__udivsi3+0x5c>
   431f4:	28001416 	blt	r5,zero,43248 <__udivsi3+0x5c>
   431f8:	00800804 	movi	r2,32
   431fc:	00c00044 	movi	r3,1
   43200:	00000206 	br	4320c <__udivsi3+0x20>
   43204:	10000e26 	beq	r2,zero,43240 <__udivsi3+0x54>
   43208:	28000516 	blt	r5,zero,43220 <__udivsi3+0x34>
   4320c:	294b883a 	add	r5,r5,r5
   43210:	10bfffc4 	addi	r2,r2,-1
   43214:	18c7883a 	add	r3,r3,r3
   43218:	293ffa36 	bltu	r5,r4,43204 <__alt_data_end+0xfffdb204>
   4321c:	18000826 	beq	r3,zero,43240 <__udivsi3+0x54>
   43220:	0005883a 	mov	r2,zero
   43224:	31400236 	bltu	r6,r5,43230 <__udivsi3+0x44>
   43228:	314dc83a 	sub	r6,r6,r5
   4322c:	10c4b03a 	or	r2,r2,r3
   43230:	1806d07a 	srli	r3,r3,1
   43234:	280ad07a 	srli	r5,r5,1
   43238:	183ffa1e 	bne	r3,zero,43224 <__alt_data_end+0xfffdb224>
   4323c:	f800283a 	ret
   43240:	0005883a 	mov	r2,zero
   43244:	f800283a 	ret
   43248:	00c00044 	movi	r3,1
   4324c:	003ff406 	br	43220 <__alt_data_end+0xfffdb220>

00043250 <__umodsi3>:
   43250:	2005883a 	mov	r2,r4
   43254:	2900122e 	bgeu	r5,r4,432a0 <__umodsi3+0x50>
   43258:	28001116 	blt	r5,zero,432a0 <__umodsi3+0x50>
   4325c:	01800804 	movi	r6,32
   43260:	00c00044 	movi	r3,1
   43264:	00000206 	br	43270 <__umodsi3+0x20>
   43268:	30000c26 	beq	r6,zero,4329c <__umodsi3+0x4c>
   4326c:	28000516 	blt	r5,zero,43284 <__umodsi3+0x34>
   43270:	294b883a 	add	r5,r5,r5
   43274:	31bfffc4 	addi	r6,r6,-1
   43278:	18c7883a 	add	r3,r3,r3
   4327c:	293ffa36 	bltu	r5,r4,43268 <__alt_data_end+0xfffdb268>
   43280:	18000626 	beq	r3,zero,4329c <__umodsi3+0x4c>
   43284:	1806d07a 	srli	r3,r3,1
   43288:	11400136 	bltu	r2,r5,43290 <__umodsi3+0x40>
   4328c:	1145c83a 	sub	r2,r2,r5
   43290:	280ad07a 	srli	r5,r5,1
   43294:	183ffb1e 	bne	r3,zero,43284 <__alt_data_end+0xfffdb284>
   43298:	f800283a 	ret
   4329c:	f800283a 	ret
   432a0:	00c00044 	movi	r3,1
   432a4:	003ff706 	br	43284 <__alt_data_end+0xfffdb284>

000432a8 <__gedf2>:
   432a8:	2804d53a 	srli	r2,r5,20
   432ac:	3806d53a 	srli	r3,r7,20
   432b0:	02000434 	movhi	r8,16
   432b4:	423fffc4 	addi	r8,r8,-1
   432b8:	1081ffcc 	andi	r2,r2,2047
   432bc:	0241ffc4 	movi	r9,2047
   432c0:	2a14703a 	and	r10,r5,r8
   432c4:	18c1ffcc 	andi	r3,r3,2047
   432c8:	3a10703a 	and	r8,r7,r8
   432cc:	280ad7fa 	srli	r5,r5,31
   432d0:	380ed7fa 	srli	r7,r7,31
   432d4:	12401d26 	beq	r2,r9,4334c <__gedf2+0xa4>
   432d8:	0241ffc4 	movi	r9,2047
   432dc:	1a401226 	beq	r3,r9,43328 <__gedf2+0x80>
   432e0:	1000081e 	bne	r2,zero,43304 <__gedf2+0x5c>
   432e4:	2296b03a 	or	r11,r4,r10
   432e8:	5813003a 	cmpeq	r9,r11,zero
   432ec:	1800091e 	bne	r3,zero,43314 <__gedf2+0x6c>
   432f0:	3218b03a 	or	r12,r6,r8
   432f4:	6000071e 	bne	r12,zero,43314 <__gedf2+0x6c>
   432f8:	0005883a 	mov	r2,zero
   432fc:	5800101e 	bne	r11,zero,43340 <__gedf2+0x98>
   43300:	f800283a 	ret
   43304:	18000c1e 	bne	r3,zero,43338 <__gedf2+0x90>
   43308:	3212b03a 	or	r9,r6,r8
   4330c:	48000c26 	beq	r9,zero,43340 <__gedf2+0x98>
   43310:	0013883a 	mov	r9,zero
   43314:	39c03fcc 	andi	r7,r7,255
   43318:	48000826 	beq	r9,zero,4333c <__gedf2+0x94>
   4331c:	38000926 	beq	r7,zero,43344 <__gedf2+0x9c>
   43320:	00800044 	movi	r2,1
   43324:	f800283a 	ret
   43328:	3212b03a 	or	r9,r6,r8
   4332c:	483fec26 	beq	r9,zero,432e0 <__alt_data_end+0xfffdb2e0>
   43330:	00bfff84 	movi	r2,-2
   43334:	f800283a 	ret
   43338:	39c03fcc 	andi	r7,r7,255
   4333c:	29c00626 	beq	r5,r7,43358 <__gedf2+0xb0>
   43340:	283ff726 	beq	r5,zero,43320 <__alt_data_end+0xfffdb320>
   43344:	00bfffc4 	movi	r2,-1
   43348:	f800283a 	ret
   4334c:	2292b03a 	or	r9,r4,r10
   43350:	483fe126 	beq	r9,zero,432d8 <__alt_data_end+0xfffdb2d8>
   43354:	003ff606 	br	43330 <__alt_data_end+0xfffdb330>
   43358:	18bff916 	blt	r3,r2,43340 <__alt_data_end+0xfffdb340>
   4335c:	10c00316 	blt	r2,r3,4336c <__gedf2+0xc4>
   43360:	42bff736 	bltu	r8,r10,43340 <__alt_data_end+0xfffdb340>
   43364:	52000326 	beq	r10,r8,43374 <__gedf2+0xcc>
   43368:	5200042e 	bgeu	r10,r8,4337c <__gedf2+0xd4>
   4336c:	283fec1e 	bne	r5,zero,43320 <__alt_data_end+0xfffdb320>
   43370:	003ff406 	br	43344 <__alt_data_end+0xfffdb344>
   43374:	313ff236 	bltu	r6,r4,43340 <__alt_data_end+0xfffdb340>
   43378:	21bffc36 	bltu	r4,r6,4336c <__alt_data_end+0xfffdb36c>
   4337c:	0005883a 	mov	r2,zero
   43380:	f800283a 	ret

00043384 <__muldf3>:
   43384:	defff304 	addi	sp,sp,-52
   43388:	2804d53a 	srli	r2,r5,20
   4338c:	dd800915 	stw	r22,36(sp)
   43390:	282cd7fa 	srli	r22,r5,31
   43394:	dc000315 	stw	r16,12(sp)
   43398:	04000434 	movhi	r16,16
   4339c:	dd400815 	stw	r21,32(sp)
   433a0:	dc800515 	stw	r18,20(sp)
   433a4:	843fffc4 	addi	r16,r16,-1
   433a8:	dfc00c15 	stw	ra,48(sp)
   433ac:	df000b15 	stw	fp,44(sp)
   433b0:	ddc00a15 	stw	r23,40(sp)
   433b4:	dd000715 	stw	r20,28(sp)
   433b8:	dcc00615 	stw	r19,24(sp)
   433bc:	dc400415 	stw	r17,16(sp)
   433c0:	1481ffcc 	andi	r18,r2,2047
   433c4:	2c20703a 	and	r16,r5,r16
   433c8:	b02b883a 	mov	r21,r22
   433cc:	b2403fcc 	andi	r9,r22,255
   433d0:	90006026 	beq	r18,zero,43554 <__muldf3+0x1d0>
   433d4:	0081ffc4 	movi	r2,2047
   433d8:	2029883a 	mov	r20,r4
   433dc:	90803626 	beq	r18,r2,434b8 <__muldf3+0x134>
   433e0:	80800434 	orhi	r2,r16,16
   433e4:	100490fa 	slli	r2,r2,3
   433e8:	2020d77a 	srli	r16,r4,29
   433ec:	202890fa 	slli	r20,r4,3
   433f0:	94bf0044 	addi	r18,r18,-1023
   433f4:	80a0b03a 	or	r16,r16,r2
   433f8:	0027883a 	mov	r19,zero
   433fc:	0039883a 	mov	fp,zero
   43400:	3804d53a 	srli	r2,r7,20
   43404:	382ed7fa 	srli	r23,r7,31
   43408:	04400434 	movhi	r17,16
   4340c:	8c7fffc4 	addi	r17,r17,-1
   43410:	1081ffcc 	andi	r2,r2,2047
   43414:	3011883a 	mov	r8,r6
   43418:	3c62703a 	and	r17,r7,r17
   4341c:	ba803fcc 	andi	r10,r23,255
   43420:	10006d26 	beq	r2,zero,435d8 <__muldf3+0x254>
   43424:	00c1ffc4 	movi	r3,2047
   43428:	10c06526 	beq	r2,r3,435c0 <__muldf3+0x23c>
   4342c:	88c00434 	orhi	r3,r17,16
   43430:	180690fa 	slli	r3,r3,3
   43434:	3022d77a 	srli	r17,r6,29
   43438:	301090fa 	slli	r8,r6,3
   4343c:	10bf0044 	addi	r2,r2,-1023
   43440:	88e2b03a 	or	r17,r17,r3
   43444:	000b883a 	mov	r5,zero
   43448:	9085883a 	add	r2,r18,r2
   4344c:	2cc8b03a 	or	r4,r5,r19
   43450:	00c003c4 	movi	r3,15
   43454:	bdacf03a 	xor	r22,r23,r22
   43458:	12c00044 	addi	r11,r2,1
   4345c:	19009936 	bltu	r3,r4,436c4 <__muldf3+0x340>
   43460:	200890ba 	slli	r4,r4,2
   43464:	00c00134 	movhi	r3,4
   43468:	18cd1e04 	addi	r3,r3,13432
   4346c:	20c9883a 	add	r4,r4,r3
   43470:	20c00017 	ldw	r3,0(r4)
   43474:	1800683a 	jmp	r3
   43478:	000436c4 	movi	zero,4315
   4347c:	000434d8 	cmpnei	zero,zero,4307
   43480:	000434d8 	cmpnei	zero,zero,4307
   43484:	000434d4 	movui	zero,4307
   43488:	000436a0 	cmpeqi	zero,zero,4314
   4348c:	000436a0 	cmpeqi	zero,zero,4314
   43490:	00043688 	cmpgei	zero,zero,4314
   43494:	000434d4 	movui	zero,4307
   43498:	000436a0 	cmpeqi	zero,zero,4314
   4349c:	00043688 	cmpgei	zero,zero,4314
   434a0:	000436a0 	cmpeqi	zero,zero,4314
   434a4:	000434d4 	movui	zero,4307
   434a8:	000436b0 	cmpltui	zero,zero,4314
   434ac:	000436b0 	cmpltui	zero,zero,4314
   434b0:	000436b0 	cmpltui	zero,zero,4314
   434b4:	000438cc 	andi	zero,zero,4323
   434b8:	2404b03a 	or	r2,r4,r16
   434bc:	10006f1e 	bne	r2,zero,4367c <__muldf3+0x2f8>
   434c0:	04c00204 	movi	r19,8
   434c4:	0021883a 	mov	r16,zero
   434c8:	0029883a 	mov	r20,zero
   434cc:	07000084 	movi	fp,2
   434d0:	003fcb06 	br	43400 <__alt_data_end+0xfffdb400>
   434d4:	502d883a 	mov	r22,r10
   434d8:	00800084 	movi	r2,2
   434dc:	28805726 	beq	r5,r2,4363c <__muldf3+0x2b8>
   434e0:	008000c4 	movi	r2,3
   434e4:	28816626 	beq	r5,r2,43a80 <__muldf3+0x6fc>
   434e8:	00800044 	movi	r2,1
   434ec:	2881411e 	bne	r5,r2,439f4 <__muldf3+0x670>
   434f0:	b02b883a 	mov	r21,r22
   434f4:	0005883a 	mov	r2,zero
   434f8:	000b883a 	mov	r5,zero
   434fc:	0029883a 	mov	r20,zero
   43500:	1004953a 	slli	r2,r2,20
   43504:	a8c03fcc 	andi	r3,r21,255
   43508:	04400434 	movhi	r17,16
   4350c:	8c7fffc4 	addi	r17,r17,-1
   43510:	180697fa 	slli	r3,r3,31
   43514:	2c4a703a 	and	r5,r5,r17
   43518:	288ab03a 	or	r5,r5,r2
   4351c:	28c6b03a 	or	r3,r5,r3
   43520:	a005883a 	mov	r2,r20
   43524:	dfc00c17 	ldw	ra,48(sp)
   43528:	df000b17 	ldw	fp,44(sp)
   4352c:	ddc00a17 	ldw	r23,40(sp)
   43530:	dd800917 	ldw	r22,36(sp)
   43534:	dd400817 	ldw	r21,32(sp)
   43538:	dd000717 	ldw	r20,28(sp)
   4353c:	dcc00617 	ldw	r19,24(sp)
   43540:	dc800517 	ldw	r18,20(sp)
   43544:	dc400417 	ldw	r17,16(sp)
   43548:	dc000317 	ldw	r16,12(sp)
   4354c:	dec00d04 	addi	sp,sp,52
   43550:	f800283a 	ret
   43554:	2404b03a 	or	r2,r4,r16
   43558:	2027883a 	mov	r19,r4
   4355c:	10004226 	beq	r2,zero,43668 <__muldf3+0x2e4>
   43560:	8000fc26 	beq	r16,zero,43954 <__muldf3+0x5d0>
   43564:	8009883a 	mov	r4,r16
   43568:	d9800215 	stw	r6,8(sp)
   4356c:	d9c00015 	stw	r7,0(sp)
   43570:	da400115 	stw	r9,4(sp)
   43574:	00444c00 	call	444c0 <__clzsi2>
   43578:	d9800217 	ldw	r6,8(sp)
   4357c:	d9c00017 	ldw	r7,0(sp)
   43580:	da400117 	ldw	r9,4(sp)
   43584:	113ffd44 	addi	r4,r2,-11
   43588:	00c00704 	movi	r3,28
   4358c:	1900ed16 	blt	r3,r4,43944 <__muldf3+0x5c0>
   43590:	00c00744 	movi	r3,29
   43594:	147ffe04 	addi	r17,r2,-8
   43598:	1907c83a 	sub	r3,r3,r4
   4359c:	8460983a 	sll	r16,r16,r17
   435a0:	98c6d83a 	srl	r3,r19,r3
   435a4:	9c68983a 	sll	r20,r19,r17
   435a8:	1c20b03a 	or	r16,r3,r16
   435ac:	1080fcc4 	addi	r2,r2,1011
   435b0:	00a5c83a 	sub	r18,zero,r2
   435b4:	0027883a 	mov	r19,zero
   435b8:	0039883a 	mov	fp,zero
   435bc:	003f9006 	br	43400 <__alt_data_end+0xfffdb400>
   435c0:	3446b03a 	or	r3,r6,r17
   435c4:	1800261e 	bne	r3,zero,43660 <__muldf3+0x2dc>
   435c8:	0023883a 	mov	r17,zero
   435cc:	0011883a 	mov	r8,zero
   435d0:	01400084 	movi	r5,2
   435d4:	003f9c06 	br	43448 <__alt_data_end+0xfffdb448>
   435d8:	3446b03a 	or	r3,r6,r17
   435dc:	18001c26 	beq	r3,zero,43650 <__muldf3+0x2cc>
   435e0:	8800ce26 	beq	r17,zero,4391c <__muldf3+0x598>
   435e4:	8809883a 	mov	r4,r17
   435e8:	d9800215 	stw	r6,8(sp)
   435ec:	da400115 	stw	r9,4(sp)
   435f0:	da800015 	stw	r10,0(sp)
   435f4:	00444c00 	call	444c0 <__clzsi2>
   435f8:	d9800217 	ldw	r6,8(sp)
   435fc:	da400117 	ldw	r9,4(sp)
   43600:	da800017 	ldw	r10,0(sp)
   43604:	113ffd44 	addi	r4,r2,-11
   43608:	00c00704 	movi	r3,28
   4360c:	1900bf16 	blt	r3,r4,4390c <__muldf3+0x588>
   43610:	00c00744 	movi	r3,29
   43614:	123ffe04 	addi	r8,r2,-8
   43618:	1907c83a 	sub	r3,r3,r4
   4361c:	8a22983a 	sll	r17,r17,r8
   43620:	30c6d83a 	srl	r3,r6,r3
   43624:	3210983a 	sll	r8,r6,r8
   43628:	1c62b03a 	or	r17,r3,r17
   4362c:	1080fcc4 	addi	r2,r2,1011
   43630:	0085c83a 	sub	r2,zero,r2
   43634:	000b883a 	mov	r5,zero
   43638:	003f8306 	br	43448 <__alt_data_end+0xfffdb448>
   4363c:	b02b883a 	mov	r21,r22
   43640:	0081ffc4 	movi	r2,2047
   43644:	000b883a 	mov	r5,zero
   43648:	0029883a 	mov	r20,zero
   4364c:	003fac06 	br	43500 <__alt_data_end+0xfffdb500>
   43650:	0023883a 	mov	r17,zero
   43654:	0011883a 	mov	r8,zero
   43658:	01400044 	movi	r5,1
   4365c:	003f7a06 	br	43448 <__alt_data_end+0xfffdb448>
   43660:	014000c4 	movi	r5,3
   43664:	003f7806 	br	43448 <__alt_data_end+0xfffdb448>
   43668:	04c00104 	movi	r19,4
   4366c:	0021883a 	mov	r16,zero
   43670:	0029883a 	mov	r20,zero
   43674:	07000044 	movi	fp,1
   43678:	003f6106 	br	43400 <__alt_data_end+0xfffdb400>
   4367c:	04c00304 	movi	r19,12
   43680:	070000c4 	movi	fp,3
   43684:	003f5e06 	br	43400 <__alt_data_end+0xfffdb400>
   43688:	01400434 	movhi	r5,16
   4368c:	002b883a 	mov	r21,zero
   43690:	297fffc4 	addi	r5,r5,-1
   43694:	053fffc4 	movi	r20,-1
   43698:	0081ffc4 	movi	r2,2047
   4369c:	003f9806 	br	43500 <__alt_data_end+0xfffdb500>
   436a0:	8023883a 	mov	r17,r16
   436a4:	a011883a 	mov	r8,r20
   436a8:	e00b883a 	mov	r5,fp
   436ac:	003f8a06 	br	434d8 <__alt_data_end+0xfffdb4d8>
   436b0:	8023883a 	mov	r17,r16
   436b4:	a011883a 	mov	r8,r20
   436b8:	482d883a 	mov	r22,r9
   436bc:	e00b883a 	mov	r5,fp
   436c0:	003f8506 	br	434d8 <__alt_data_end+0xfffdb4d8>
   436c4:	a00ad43a 	srli	r5,r20,16
   436c8:	401ad43a 	srli	r13,r8,16
   436cc:	a53fffcc 	andi	r20,r20,65535
   436d0:	423fffcc 	andi	r8,r8,65535
   436d4:	4519383a 	mul	r12,r8,r20
   436d8:	4147383a 	mul	r3,r8,r5
   436dc:	6d09383a 	mul	r4,r13,r20
   436e0:	600cd43a 	srli	r6,r12,16
   436e4:	2b5d383a 	mul	r14,r5,r13
   436e8:	20c9883a 	add	r4,r4,r3
   436ec:	310d883a 	add	r6,r6,r4
   436f0:	30c0022e 	bgeu	r6,r3,436fc <__muldf3+0x378>
   436f4:	00c00074 	movhi	r3,1
   436f8:	70dd883a 	add	r14,r14,r3
   436fc:	8826d43a 	srli	r19,r17,16
   43700:	8bffffcc 	andi	r15,r17,65535
   43704:	7d23383a 	mul	r17,r15,r20
   43708:	7949383a 	mul	r4,r15,r5
   4370c:	9d29383a 	mul	r20,r19,r20
   43710:	8814d43a 	srli	r10,r17,16
   43714:	3012943a 	slli	r9,r6,16
   43718:	a129883a 	add	r20,r20,r4
   4371c:	633fffcc 	andi	r12,r12,65535
   43720:	5515883a 	add	r10,r10,r20
   43724:	3006d43a 	srli	r3,r6,16
   43728:	4b13883a 	add	r9,r9,r12
   4372c:	2ccb383a 	mul	r5,r5,r19
   43730:	5100022e 	bgeu	r10,r4,4373c <__muldf3+0x3b8>
   43734:	01000074 	movhi	r4,1
   43738:	290b883a 	add	r5,r5,r4
   4373c:	802ad43a 	srli	r21,r16,16
   43740:	843fffcc 	andi	r16,r16,65535
   43744:	440d383a 	mul	r6,r8,r16
   43748:	4565383a 	mul	r18,r8,r21
   4374c:	8349383a 	mul	r4,r16,r13
   43750:	500e943a 	slli	r7,r10,16
   43754:	3010d43a 	srli	r8,r6,16
   43758:	5028d43a 	srli	r20,r10,16
   4375c:	2489883a 	add	r4,r4,r18
   43760:	8abfffcc 	andi	r10,r17,65535
   43764:	3a95883a 	add	r10,r7,r10
   43768:	4119883a 	add	r12,r8,r4
   4376c:	a169883a 	add	r20,r20,r5
   43770:	1a87883a 	add	r3,r3,r10
   43774:	6d5b383a 	mul	r13,r13,r21
   43778:	6480022e 	bgeu	r12,r18,43784 <__muldf3+0x400>
   4377c:	01000074 	movhi	r4,1
   43780:	691b883a 	add	r13,r13,r4
   43784:	7c25383a 	mul	r18,r15,r16
   43788:	7d4b383a 	mul	r5,r15,r21
   4378c:	84cf383a 	mul	r7,r16,r19
   43790:	901ed43a 	srli	r15,r18,16
   43794:	6008d43a 	srli	r4,r12,16
   43798:	6010943a 	slli	r8,r12,16
   4379c:	394f883a 	add	r7,r7,r5
   437a0:	333fffcc 	andi	r12,r6,65535
   437a4:	79df883a 	add	r15,r15,r7
   437a8:	235b883a 	add	r13,r4,r13
   437ac:	9d63383a 	mul	r17,r19,r21
   437b0:	4309883a 	add	r4,r8,r12
   437b4:	7940022e 	bgeu	r15,r5,437c0 <__muldf3+0x43c>
   437b8:	01400074 	movhi	r5,1
   437bc:	8963883a 	add	r17,r17,r5
   437c0:	780a943a 	slli	r5,r15,16
   437c4:	91bfffcc 	andi	r6,r18,65535
   437c8:	70c7883a 	add	r3,r14,r3
   437cc:	298d883a 	add	r6,r5,r6
   437d0:	1a8f803a 	cmpltu	r7,r3,r10
   437d4:	350b883a 	add	r5,r6,r20
   437d8:	20c7883a 	add	r3,r4,r3
   437dc:	3955883a 	add	r10,r7,r5
   437e0:	1909803a 	cmpltu	r4,r3,r4
   437e4:	6a91883a 	add	r8,r13,r10
   437e8:	780cd43a 	srli	r6,r15,16
   437ec:	2219883a 	add	r12,r4,r8
   437f0:	2d0b803a 	cmpltu	r5,r5,r20
   437f4:	51cf803a 	cmpltu	r7,r10,r7
   437f8:	29ceb03a 	or	r7,r5,r7
   437fc:	4351803a 	cmpltu	r8,r8,r13
   43800:	610b803a 	cmpltu	r5,r12,r4
   43804:	4148b03a 	or	r4,r8,r5
   43808:	398f883a 	add	r7,r7,r6
   4380c:	3909883a 	add	r4,r7,r4
   43810:	1810927a 	slli	r8,r3,9
   43814:	2449883a 	add	r4,r4,r17
   43818:	2008927a 	slli	r4,r4,9
   4381c:	6022d5fa 	srli	r17,r12,23
   43820:	1806d5fa 	srli	r3,r3,23
   43824:	4252b03a 	or	r9,r8,r9
   43828:	600a927a 	slli	r5,r12,9
   4382c:	4810c03a 	cmpne	r8,r9,zero
   43830:	2462b03a 	or	r17,r4,r17
   43834:	40c6b03a 	or	r3,r8,r3
   43838:	8900402c 	andhi	r4,r17,256
   4383c:	1950b03a 	or	r8,r3,r5
   43840:	20000726 	beq	r4,zero,43860 <__muldf3+0x4dc>
   43844:	4006d07a 	srli	r3,r8,1
   43848:	880497fa 	slli	r2,r17,31
   4384c:	4200004c 	andi	r8,r8,1
   43850:	8822d07a 	srli	r17,r17,1
   43854:	1a10b03a 	or	r8,r3,r8
   43858:	1210b03a 	or	r8,r2,r8
   4385c:	5805883a 	mov	r2,r11
   43860:	1140ffc4 	addi	r5,r2,1023
   43864:	0140440e 	bge	zero,r5,43978 <__muldf3+0x5f4>
   43868:	40c001cc 	andi	r3,r8,7
   4386c:	18000726 	beq	r3,zero,4388c <__muldf3+0x508>
   43870:	40c003cc 	andi	r3,r8,15
   43874:	01000104 	movi	r4,4
   43878:	19000426 	beq	r3,r4,4388c <__muldf3+0x508>
   4387c:	4107883a 	add	r3,r8,r4
   43880:	1a11803a 	cmpltu	r8,r3,r8
   43884:	8a23883a 	add	r17,r17,r8
   43888:	1811883a 	mov	r8,r3
   4388c:	88c0402c 	andhi	r3,r17,256
   43890:	18000426 	beq	r3,zero,438a4 <__muldf3+0x520>
   43894:	11410004 	addi	r5,r2,1024
   43898:	00bfc034 	movhi	r2,65280
   4389c:	10bfffc4 	addi	r2,r2,-1
   438a0:	88a2703a 	and	r17,r17,r2
   438a4:	0081ff84 	movi	r2,2046
   438a8:	117f6416 	blt	r2,r5,4363c <__alt_data_end+0xfffdb63c>
   438ac:	8828977a 	slli	r20,r17,29
   438b0:	4010d0fa 	srli	r8,r8,3
   438b4:	8822927a 	slli	r17,r17,9
   438b8:	2881ffcc 	andi	r2,r5,2047
   438bc:	a228b03a 	or	r20,r20,r8
   438c0:	880ad33a 	srli	r5,r17,12
   438c4:	b02b883a 	mov	r21,r22
   438c8:	003f0d06 	br	43500 <__alt_data_end+0xfffdb500>
   438cc:	8080022c 	andhi	r2,r16,8
   438d0:	10000926 	beq	r2,zero,438f8 <__muldf3+0x574>
   438d4:	8880022c 	andhi	r2,r17,8
   438d8:	1000071e 	bne	r2,zero,438f8 <__muldf3+0x574>
   438dc:	00800434 	movhi	r2,16
   438e0:	89400234 	orhi	r5,r17,8
   438e4:	10bfffc4 	addi	r2,r2,-1
   438e8:	b82b883a 	mov	r21,r23
   438ec:	288a703a 	and	r5,r5,r2
   438f0:	4029883a 	mov	r20,r8
   438f4:	003f6806 	br	43698 <__alt_data_end+0xfffdb698>
   438f8:	00800434 	movhi	r2,16
   438fc:	81400234 	orhi	r5,r16,8
   43900:	10bfffc4 	addi	r2,r2,-1
   43904:	288a703a 	and	r5,r5,r2
   43908:	003f6306 	br	43698 <__alt_data_end+0xfffdb698>
   4390c:	147ff604 	addi	r17,r2,-40
   43910:	3462983a 	sll	r17,r6,r17
   43914:	0011883a 	mov	r8,zero
   43918:	003f4406 	br	4362c <__alt_data_end+0xfffdb62c>
   4391c:	3009883a 	mov	r4,r6
   43920:	d9800215 	stw	r6,8(sp)
   43924:	da400115 	stw	r9,4(sp)
   43928:	da800015 	stw	r10,0(sp)
   4392c:	00444c00 	call	444c0 <__clzsi2>
   43930:	10800804 	addi	r2,r2,32
   43934:	da800017 	ldw	r10,0(sp)
   43938:	da400117 	ldw	r9,4(sp)
   4393c:	d9800217 	ldw	r6,8(sp)
   43940:	003f3006 	br	43604 <__alt_data_end+0xfffdb604>
   43944:	143ff604 	addi	r16,r2,-40
   43948:	9c20983a 	sll	r16,r19,r16
   4394c:	0029883a 	mov	r20,zero
   43950:	003f1606 	br	435ac <__alt_data_end+0xfffdb5ac>
   43954:	d9800215 	stw	r6,8(sp)
   43958:	d9c00015 	stw	r7,0(sp)
   4395c:	da400115 	stw	r9,4(sp)
   43960:	00444c00 	call	444c0 <__clzsi2>
   43964:	10800804 	addi	r2,r2,32
   43968:	da400117 	ldw	r9,4(sp)
   4396c:	d9c00017 	ldw	r7,0(sp)
   43970:	d9800217 	ldw	r6,8(sp)
   43974:	003f0306 	br	43584 <__alt_data_end+0xfffdb584>
   43978:	00c00044 	movi	r3,1
   4397c:	1947c83a 	sub	r3,r3,r5
   43980:	00800e04 	movi	r2,56
   43984:	10feda16 	blt	r2,r3,434f0 <__alt_data_end+0xfffdb4f0>
   43988:	008007c4 	movi	r2,31
   4398c:	10c01b16 	blt	r2,r3,439fc <__muldf3+0x678>
   43990:	00800804 	movi	r2,32
   43994:	10c5c83a 	sub	r2,r2,r3
   43998:	888a983a 	sll	r5,r17,r2
   4399c:	40c8d83a 	srl	r4,r8,r3
   439a0:	4084983a 	sll	r2,r8,r2
   439a4:	88e2d83a 	srl	r17,r17,r3
   439a8:	2906b03a 	or	r3,r5,r4
   439ac:	1004c03a 	cmpne	r2,r2,zero
   439b0:	1886b03a 	or	r3,r3,r2
   439b4:	188001cc 	andi	r2,r3,7
   439b8:	10000726 	beq	r2,zero,439d8 <__muldf3+0x654>
   439bc:	188003cc 	andi	r2,r3,15
   439c0:	01000104 	movi	r4,4
   439c4:	11000426 	beq	r2,r4,439d8 <__muldf3+0x654>
   439c8:	1805883a 	mov	r2,r3
   439cc:	10c00104 	addi	r3,r2,4
   439d0:	1885803a 	cmpltu	r2,r3,r2
   439d4:	88a3883a 	add	r17,r17,r2
   439d8:	8880202c 	andhi	r2,r17,128
   439dc:	10001c26 	beq	r2,zero,43a50 <__muldf3+0x6cc>
   439e0:	b02b883a 	mov	r21,r22
   439e4:	00800044 	movi	r2,1
   439e8:	000b883a 	mov	r5,zero
   439ec:	0029883a 	mov	r20,zero
   439f0:	003ec306 	br	43500 <__alt_data_end+0xfffdb500>
   439f4:	5805883a 	mov	r2,r11
   439f8:	003f9906 	br	43860 <__alt_data_end+0xfffdb860>
   439fc:	00bff844 	movi	r2,-31
   43a00:	1145c83a 	sub	r2,r2,r5
   43a04:	8888d83a 	srl	r4,r17,r2
   43a08:	00800804 	movi	r2,32
   43a0c:	18801a26 	beq	r3,r2,43a78 <__muldf3+0x6f4>
   43a10:	00801004 	movi	r2,64
   43a14:	10c5c83a 	sub	r2,r2,r3
   43a18:	8884983a 	sll	r2,r17,r2
   43a1c:	1204b03a 	or	r2,r2,r8
   43a20:	1004c03a 	cmpne	r2,r2,zero
   43a24:	2084b03a 	or	r2,r4,r2
   43a28:	144001cc 	andi	r17,r2,7
   43a2c:	88000d1e 	bne	r17,zero,43a64 <__muldf3+0x6e0>
   43a30:	000b883a 	mov	r5,zero
   43a34:	1028d0fa 	srli	r20,r2,3
   43a38:	b02b883a 	mov	r21,r22
   43a3c:	0005883a 	mov	r2,zero
   43a40:	a468b03a 	or	r20,r20,r17
   43a44:	003eae06 	br	43500 <__alt_data_end+0xfffdb500>
   43a48:	1007883a 	mov	r3,r2
   43a4c:	0023883a 	mov	r17,zero
   43a50:	880a927a 	slli	r5,r17,9
   43a54:	1805883a 	mov	r2,r3
   43a58:	8822977a 	slli	r17,r17,29
   43a5c:	280ad33a 	srli	r5,r5,12
   43a60:	003ff406 	br	43a34 <__alt_data_end+0xfffdba34>
   43a64:	10c003cc 	andi	r3,r2,15
   43a68:	01000104 	movi	r4,4
   43a6c:	193ff626 	beq	r3,r4,43a48 <__alt_data_end+0xfffdba48>
   43a70:	0023883a 	mov	r17,zero
   43a74:	003fd506 	br	439cc <__alt_data_end+0xfffdb9cc>
   43a78:	0005883a 	mov	r2,zero
   43a7c:	003fe706 	br	43a1c <__alt_data_end+0xfffdba1c>
   43a80:	00800434 	movhi	r2,16
   43a84:	89400234 	orhi	r5,r17,8
   43a88:	10bfffc4 	addi	r2,r2,-1
   43a8c:	b02b883a 	mov	r21,r22
   43a90:	288a703a 	and	r5,r5,r2
   43a94:	4029883a 	mov	r20,r8
   43a98:	003eff06 	br	43698 <__alt_data_end+0xfffdb698>

00043a9c <__subdf3>:
   43a9c:	02000434 	movhi	r8,16
   43aa0:	423fffc4 	addi	r8,r8,-1
   43aa4:	defffb04 	addi	sp,sp,-20
   43aa8:	2a14703a 	and	r10,r5,r8
   43aac:	3812d53a 	srli	r9,r7,20
   43ab0:	3a10703a 	and	r8,r7,r8
   43ab4:	2006d77a 	srli	r3,r4,29
   43ab8:	3004d77a 	srli	r2,r6,29
   43abc:	dc000015 	stw	r16,0(sp)
   43ac0:	501490fa 	slli	r10,r10,3
   43ac4:	2820d53a 	srli	r16,r5,20
   43ac8:	401090fa 	slli	r8,r8,3
   43acc:	dc800215 	stw	r18,8(sp)
   43ad0:	dc400115 	stw	r17,4(sp)
   43ad4:	dfc00415 	stw	ra,16(sp)
   43ad8:	202290fa 	slli	r17,r4,3
   43adc:	dcc00315 	stw	r19,12(sp)
   43ae0:	4a41ffcc 	andi	r9,r9,2047
   43ae4:	0101ffc4 	movi	r4,2047
   43ae8:	2824d7fa 	srli	r18,r5,31
   43aec:	8401ffcc 	andi	r16,r16,2047
   43af0:	50c6b03a 	or	r3,r10,r3
   43af4:	380ed7fa 	srli	r7,r7,31
   43af8:	408ab03a 	or	r5,r8,r2
   43afc:	300c90fa 	slli	r6,r6,3
   43b00:	49009626 	beq	r9,r4,43d5c <__subdf3+0x2c0>
   43b04:	39c0005c 	xori	r7,r7,1
   43b08:	8245c83a 	sub	r2,r16,r9
   43b0c:	3c807426 	beq	r7,r18,43ce0 <__subdf3+0x244>
   43b10:	0080af0e 	bge	zero,r2,43dd0 <__subdf3+0x334>
   43b14:	48002a1e 	bne	r9,zero,43bc0 <__subdf3+0x124>
   43b18:	2988b03a 	or	r4,r5,r6
   43b1c:	20009a1e 	bne	r4,zero,43d88 <__subdf3+0x2ec>
   43b20:	888001cc 	andi	r2,r17,7
   43b24:	10000726 	beq	r2,zero,43b44 <__subdf3+0xa8>
   43b28:	888003cc 	andi	r2,r17,15
   43b2c:	01000104 	movi	r4,4
   43b30:	11000426 	beq	r2,r4,43b44 <__subdf3+0xa8>
   43b34:	890b883a 	add	r5,r17,r4
   43b38:	2c63803a 	cmpltu	r17,r5,r17
   43b3c:	1c47883a 	add	r3,r3,r17
   43b40:	2823883a 	mov	r17,r5
   43b44:	1880202c 	andhi	r2,r3,128
   43b48:	10005926 	beq	r2,zero,43cb0 <__subdf3+0x214>
   43b4c:	84000044 	addi	r16,r16,1
   43b50:	0081ffc4 	movi	r2,2047
   43b54:	8080be26 	beq	r16,r2,43e50 <__subdf3+0x3b4>
   43b58:	017fe034 	movhi	r5,65408
   43b5c:	297fffc4 	addi	r5,r5,-1
   43b60:	1946703a 	and	r3,r3,r5
   43b64:	1804977a 	slli	r2,r3,29
   43b68:	1806927a 	slli	r3,r3,9
   43b6c:	8822d0fa 	srli	r17,r17,3
   43b70:	8401ffcc 	andi	r16,r16,2047
   43b74:	180ad33a 	srli	r5,r3,12
   43b78:	9100004c 	andi	r4,r18,1
   43b7c:	1444b03a 	or	r2,r2,r17
   43b80:	80c1ffcc 	andi	r3,r16,2047
   43b84:	1820953a 	slli	r16,r3,20
   43b88:	20c03fcc 	andi	r3,r4,255
   43b8c:	180897fa 	slli	r4,r3,31
   43b90:	00c00434 	movhi	r3,16
   43b94:	18ffffc4 	addi	r3,r3,-1
   43b98:	28c6703a 	and	r3,r5,r3
   43b9c:	1c06b03a 	or	r3,r3,r16
   43ba0:	1906b03a 	or	r3,r3,r4
   43ba4:	dfc00417 	ldw	ra,16(sp)
   43ba8:	dcc00317 	ldw	r19,12(sp)
   43bac:	dc800217 	ldw	r18,8(sp)
   43bb0:	dc400117 	ldw	r17,4(sp)
   43bb4:	dc000017 	ldw	r16,0(sp)
   43bb8:	dec00504 	addi	sp,sp,20
   43bbc:	f800283a 	ret
   43bc0:	0101ffc4 	movi	r4,2047
   43bc4:	813fd626 	beq	r16,r4,43b20 <__alt_data_end+0xfffdbb20>
   43bc8:	29402034 	orhi	r5,r5,128
   43bcc:	01000e04 	movi	r4,56
   43bd0:	2080a316 	blt	r4,r2,43e60 <__subdf3+0x3c4>
   43bd4:	010007c4 	movi	r4,31
   43bd8:	2080c616 	blt	r4,r2,43ef4 <__subdf3+0x458>
   43bdc:	01000804 	movi	r4,32
   43be0:	2089c83a 	sub	r4,r4,r2
   43be4:	2910983a 	sll	r8,r5,r4
   43be8:	308ed83a 	srl	r7,r6,r2
   43bec:	3108983a 	sll	r4,r6,r4
   43bf0:	2884d83a 	srl	r2,r5,r2
   43bf4:	41ccb03a 	or	r6,r8,r7
   43bf8:	2008c03a 	cmpne	r4,r4,zero
   43bfc:	310cb03a 	or	r6,r6,r4
   43c00:	898dc83a 	sub	r6,r17,r6
   43c04:	89a3803a 	cmpltu	r17,r17,r6
   43c08:	1887c83a 	sub	r3,r3,r2
   43c0c:	1c47c83a 	sub	r3,r3,r17
   43c10:	3023883a 	mov	r17,r6
   43c14:	1880202c 	andhi	r2,r3,128
   43c18:	10002326 	beq	r2,zero,43ca8 <__subdf3+0x20c>
   43c1c:	04c02034 	movhi	r19,128
   43c20:	9cffffc4 	addi	r19,r19,-1
   43c24:	1ce6703a 	and	r19,r3,r19
   43c28:	98007a26 	beq	r19,zero,43e14 <__subdf3+0x378>
   43c2c:	9809883a 	mov	r4,r19
   43c30:	00444c00 	call	444c0 <__clzsi2>
   43c34:	113ffe04 	addi	r4,r2,-8
   43c38:	00c007c4 	movi	r3,31
   43c3c:	19007b16 	blt	r3,r4,43e2c <__subdf3+0x390>
   43c40:	00800804 	movi	r2,32
   43c44:	1105c83a 	sub	r2,r2,r4
   43c48:	8884d83a 	srl	r2,r17,r2
   43c4c:	9906983a 	sll	r3,r19,r4
   43c50:	8922983a 	sll	r17,r17,r4
   43c54:	10c4b03a 	or	r2,r2,r3
   43c58:	24007816 	blt	r4,r16,43e3c <__subdf3+0x3a0>
   43c5c:	2421c83a 	sub	r16,r4,r16
   43c60:	80c00044 	addi	r3,r16,1
   43c64:	010007c4 	movi	r4,31
   43c68:	20c09516 	blt	r4,r3,43ec0 <__subdf3+0x424>
   43c6c:	01400804 	movi	r5,32
   43c70:	28cbc83a 	sub	r5,r5,r3
   43c74:	88c8d83a 	srl	r4,r17,r3
   43c78:	8962983a 	sll	r17,r17,r5
   43c7c:	114a983a 	sll	r5,r2,r5
   43c80:	10c6d83a 	srl	r3,r2,r3
   43c84:	8804c03a 	cmpne	r2,r17,zero
   43c88:	290ab03a 	or	r5,r5,r4
   43c8c:	28a2b03a 	or	r17,r5,r2
   43c90:	0021883a 	mov	r16,zero
   43c94:	003fa206 	br	43b20 <__alt_data_end+0xfffdbb20>
   43c98:	2090b03a 	or	r8,r4,r2
   43c9c:	40018e26 	beq	r8,zero,442d8 <__subdf3+0x83c>
   43ca0:	1007883a 	mov	r3,r2
   43ca4:	2023883a 	mov	r17,r4
   43ca8:	888001cc 	andi	r2,r17,7
   43cac:	103f9e1e 	bne	r2,zero,43b28 <__alt_data_end+0xfffdbb28>
   43cb0:	1804977a 	slli	r2,r3,29
   43cb4:	8822d0fa 	srli	r17,r17,3
   43cb8:	1810d0fa 	srli	r8,r3,3
   43cbc:	9100004c 	andi	r4,r18,1
   43cc0:	1444b03a 	or	r2,r2,r17
   43cc4:	00c1ffc4 	movi	r3,2047
   43cc8:	80c02826 	beq	r16,r3,43d6c <__subdf3+0x2d0>
   43ccc:	01400434 	movhi	r5,16
   43cd0:	297fffc4 	addi	r5,r5,-1
   43cd4:	80e0703a 	and	r16,r16,r3
   43cd8:	414a703a 	and	r5,r8,r5
   43cdc:	003fa806 	br	43b80 <__alt_data_end+0xfffdbb80>
   43ce0:	0080630e 	bge	zero,r2,43e70 <__subdf3+0x3d4>
   43ce4:	48003026 	beq	r9,zero,43da8 <__subdf3+0x30c>
   43ce8:	0101ffc4 	movi	r4,2047
   43cec:	813f8c26 	beq	r16,r4,43b20 <__alt_data_end+0xfffdbb20>
   43cf0:	29402034 	orhi	r5,r5,128
   43cf4:	01000e04 	movi	r4,56
   43cf8:	2080a90e 	bge	r4,r2,43fa0 <__subdf3+0x504>
   43cfc:	298cb03a 	or	r6,r5,r6
   43d00:	3012c03a 	cmpne	r9,r6,zero
   43d04:	0005883a 	mov	r2,zero
   43d08:	4c53883a 	add	r9,r9,r17
   43d0c:	4c63803a 	cmpltu	r17,r9,r17
   43d10:	10c7883a 	add	r3,r2,r3
   43d14:	88c7883a 	add	r3,r17,r3
   43d18:	4823883a 	mov	r17,r9
   43d1c:	1880202c 	andhi	r2,r3,128
   43d20:	1000d026 	beq	r2,zero,44064 <__subdf3+0x5c8>
   43d24:	84000044 	addi	r16,r16,1
   43d28:	0081ffc4 	movi	r2,2047
   43d2c:	8080fe26 	beq	r16,r2,44128 <__subdf3+0x68c>
   43d30:	00bfe034 	movhi	r2,65408
   43d34:	10bfffc4 	addi	r2,r2,-1
   43d38:	1886703a 	and	r3,r3,r2
   43d3c:	880ad07a 	srli	r5,r17,1
   43d40:	180497fa 	slli	r2,r3,31
   43d44:	8900004c 	andi	r4,r17,1
   43d48:	2922b03a 	or	r17,r5,r4
   43d4c:	1806d07a 	srli	r3,r3,1
   43d50:	1462b03a 	or	r17,r2,r17
   43d54:	3825883a 	mov	r18,r7
   43d58:	003f7106 	br	43b20 <__alt_data_end+0xfffdbb20>
   43d5c:	2984b03a 	or	r2,r5,r6
   43d60:	103f6826 	beq	r2,zero,43b04 <__alt_data_end+0xfffdbb04>
   43d64:	39c03fcc 	andi	r7,r7,255
   43d68:	003f6706 	br	43b08 <__alt_data_end+0xfffdbb08>
   43d6c:	4086b03a 	or	r3,r8,r2
   43d70:	18015226 	beq	r3,zero,442bc <__subdf3+0x820>
   43d74:	00c00434 	movhi	r3,16
   43d78:	41400234 	orhi	r5,r8,8
   43d7c:	18ffffc4 	addi	r3,r3,-1
   43d80:	28ca703a 	and	r5,r5,r3
   43d84:	003f7e06 	br	43b80 <__alt_data_end+0xfffdbb80>
   43d88:	10bfffc4 	addi	r2,r2,-1
   43d8c:	1000491e 	bne	r2,zero,43eb4 <__subdf3+0x418>
   43d90:	898fc83a 	sub	r7,r17,r6
   43d94:	89e3803a 	cmpltu	r17,r17,r7
   43d98:	1947c83a 	sub	r3,r3,r5
   43d9c:	1c47c83a 	sub	r3,r3,r17
   43da0:	3823883a 	mov	r17,r7
   43da4:	003f9b06 	br	43c14 <__alt_data_end+0xfffdbc14>
   43da8:	2988b03a 	or	r4,r5,r6
   43dac:	203f5c26 	beq	r4,zero,43b20 <__alt_data_end+0xfffdbb20>
   43db0:	10bfffc4 	addi	r2,r2,-1
   43db4:	1000931e 	bne	r2,zero,44004 <__subdf3+0x568>
   43db8:	898d883a 	add	r6,r17,r6
   43dbc:	3463803a 	cmpltu	r17,r6,r17
   43dc0:	1947883a 	add	r3,r3,r5
   43dc4:	88c7883a 	add	r3,r17,r3
   43dc8:	3023883a 	mov	r17,r6
   43dcc:	003fd306 	br	43d1c <__alt_data_end+0xfffdbd1c>
   43dd0:	1000541e 	bne	r2,zero,43f24 <__subdf3+0x488>
   43dd4:	80800044 	addi	r2,r16,1
   43dd8:	1081ffcc 	andi	r2,r2,2047
   43ddc:	01000044 	movi	r4,1
   43de0:	2080a20e 	bge	r4,r2,4406c <__subdf3+0x5d0>
   43de4:	8989c83a 	sub	r4,r17,r6
   43de8:	8905803a 	cmpltu	r2,r17,r4
   43dec:	1967c83a 	sub	r19,r3,r5
   43df0:	98a7c83a 	sub	r19,r19,r2
   43df4:	9880202c 	andhi	r2,r19,128
   43df8:	10006326 	beq	r2,zero,43f88 <__subdf3+0x4ec>
   43dfc:	3463c83a 	sub	r17,r6,r17
   43e00:	28c7c83a 	sub	r3,r5,r3
   43e04:	344d803a 	cmpltu	r6,r6,r17
   43e08:	19a7c83a 	sub	r19,r3,r6
   43e0c:	3825883a 	mov	r18,r7
   43e10:	983f861e 	bne	r19,zero,43c2c <__alt_data_end+0xfffdbc2c>
   43e14:	8809883a 	mov	r4,r17
   43e18:	00444c00 	call	444c0 <__clzsi2>
   43e1c:	10800804 	addi	r2,r2,32
   43e20:	113ffe04 	addi	r4,r2,-8
   43e24:	00c007c4 	movi	r3,31
   43e28:	193f850e 	bge	r3,r4,43c40 <__alt_data_end+0xfffdbc40>
   43e2c:	10bff604 	addi	r2,r2,-40
   43e30:	8884983a 	sll	r2,r17,r2
   43e34:	0023883a 	mov	r17,zero
   43e38:	243f880e 	bge	r4,r16,43c5c <__alt_data_end+0xfffdbc5c>
   43e3c:	00ffe034 	movhi	r3,65408
   43e40:	18ffffc4 	addi	r3,r3,-1
   43e44:	8121c83a 	sub	r16,r16,r4
   43e48:	10c6703a 	and	r3,r2,r3
   43e4c:	003f3406 	br	43b20 <__alt_data_end+0xfffdbb20>
   43e50:	9100004c 	andi	r4,r18,1
   43e54:	000b883a 	mov	r5,zero
   43e58:	0005883a 	mov	r2,zero
   43e5c:	003f4806 	br	43b80 <__alt_data_end+0xfffdbb80>
   43e60:	298cb03a 	or	r6,r5,r6
   43e64:	300cc03a 	cmpne	r6,r6,zero
   43e68:	0005883a 	mov	r2,zero
   43e6c:	003f6406 	br	43c00 <__alt_data_end+0xfffdbc00>
   43e70:	10009a1e 	bne	r2,zero,440dc <__subdf3+0x640>
   43e74:	82400044 	addi	r9,r16,1
   43e78:	4881ffcc 	andi	r2,r9,2047
   43e7c:	02800044 	movi	r10,1
   43e80:	5080670e 	bge	r10,r2,44020 <__subdf3+0x584>
   43e84:	0081ffc4 	movi	r2,2047
   43e88:	4880af26 	beq	r9,r2,44148 <__subdf3+0x6ac>
   43e8c:	898d883a 	add	r6,r17,r6
   43e90:	1945883a 	add	r2,r3,r5
   43e94:	3447803a 	cmpltu	r3,r6,r17
   43e98:	1887883a 	add	r3,r3,r2
   43e9c:	182297fa 	slli	r17,r3,31
   43ea0:	300cd07a 	srli	r6,r6,1
   43ea4:	1806d07a 	srli	r3,r3,1
   43ea8:	4821883a 	mov	r16,r9
   43eac:	89a2b03a 	or	r17,r17,r6
   43eb0:	003f1b06 	br	43b20 <__alt_data_end+0xfffdbb20>
   43eb4:	0101ffc4 	movi	r4,2047
   43eb8:	813f441e 	bne	r16,r4,43bcc <__alt_data_end+0xfffdbbcc>
   43ebc:	003f1806 	br	43b20 <__alt_data_end+0xfffdbb20>
   43ec0:	843ff844 	addi	r16,r16,-31
   43ec4:	01400804 	movi	r5,32
   43ec8:	1408d83a 	srl	r4,r2,r16
   43ecc:	19405026 	beq	r3,r5,44010 <__subdf3+0x574>
   43ed0:	01401004 	movi	r5,64
   43ed4:	28c7c83a 	sub	r3,r5,r3
   43ed8:	10c4983a 	sll	r2,r2,r3
   43edc:	88a2b03a 	or	r17,r17,r2
   43ee0:	8822c03a 	cmpne	r17,r17,zero
   43ee4:	2462b03a 	or	r17,r4,r17
   43ee8:	0007883a 	mov	r3,zero
   43eec:	0021883a 	mov	r16,zero
   43ef0:	003f6d06 	br	43ca8 <__alt_data_end+0xfffdbca8>
   43ef4:	11fff804 	addi	r7,r2,-32
   43ef8:	01000804 	movi	r4,32
   43efc:	29ced83a 	srl	r7,r5,r7
   43f00:	11004526 	beq	r2,r4,44018 <__subdf3+0x57c>
   43f04:	01001004 	movi	r4,64
   43f08:	2089c83a 	sub	r4,r4,r2
   43f0c:	2904983a 	sll	r2,r5,r4
   43f10:	118cb03a 	or	r6,r2,r6
   43f14:	300cc03a 	cmpne	r6,r6,zero
   43f18:	398cb03a 	or	r6,r7,r6
   43f1c:	0005883a 	mov	r2,zero
   43f20:	003f3706 	br	43c00 <__alt_data_end+0xfffdbc00>
   43f24:	80002a26 	beq	r16,zero,43fd0 <__subdf3+0x534>
   43f28:	0101ffc4 	movi	r4,2047
   43f2c:	49006626 	beq	r9,r4,440c8 <__subdf3+0x62c>
   43f30:	0085c83a 	sub	r2,zero,r2
   43f34:	18c02034 	orhi	r3,r3,128
   43f38:	01000e04 	movi	r4,56
   43f3c:	20807e16 	blt	r4,r2,44138 <__subdf3+0x69c>
   43f40:	010007c4 	movi	r4,31
   43f44:	2080e716 	blt	r4,r2,442e4 <__subdf3+0x848>
   43f48:	01000804 	movi	r4,32
   43f4c:	2089c83a 	sub	r4,r4,r2
   43f50:	1914983a 	sll	r10,r3,r4
   43f54:	8890d83a 	srl	r8,r17,r2
   43f58:	8908983a 	sll	r4,r17,r4
   43f5c:	1884d83a 	srl	r2,r3,r2
   43f60:	5222b03a 	or	r17,r10,r8
   43f64:	2006c03a 	cmpne	r3,r4,zero
   43f68:	88e2b03a 	or	r17,r17,r3
   43f6c:	3463c83a 	sub	r17,r6,r17
   43f70:	2885c83a 	sub	r2,r5,r2
   43f74:	344d803a 	cmpltu	r6,r6,r17
   43f78:	1187c83a 	sub	r3,r2,r6
   43f7c:	4821883a 	mov	r16,r9
   43f80:	3825883a 	mov	r18,r7
   43f84:	003f2306 	br	43c14 <__alt_data_end+0xfffdbc14>
   43f88:	24d0b03a 	or	r8,r4,r19
   43f8c:	40001b1e 	bne	r8,zero,43ffc <__subdf3+0x560>
   43f90:	0005883a 	mov	r2,zero
   43f94:	0009883a 	mov	r4,zero
   43f98:	0021883a 	mov	r16,zero
   43f9c:	003f4906 	br	43cc4 <__alt_data_end+0xfffdbcc4>
   43fa0:	010007c4 	movi	r4,31
   43fa4:	20803a16 	blt	r4,r2,44090 <__subdf3+0x5f4>
   43fa8:	01000804 	movi	r4,32
   43fac:	2089c83a 	sub	r4,r4,r2
   43fb0:	2912983a 	sll	r9,r5,r4
   43fb4:	3090d83a 	srl	r8,r6,r2
   43fb8:	3108983a 	sll	r4,r6,r4
   43fbc:	2884d83a 	srl	r2,r5,r2
   43fc0:	4a12b03a 	or	r9,r9,r8
   43fc4:	2008c03a 	cmpne	r4,r4,zero
   43fc8:	4912b03a 	or	r9,r9,r4
   43fcc:	003f4e06 	br	43d08 <__alt_data_end+0xfffdbd08>
   43fd0:	1c48b03a 	or	r4,r3,r17
   43fd4:	20003c26 	beq	r4,zero,440c8 <__subdf3+0x62c>
   43fd8:	0084303a 	nor	r2,zero,r2
   43fdc:	1000381e 	bne	r2,zero,440c0 <__subdf3+0x624>
   43fe0:	3463c83a 	sub	r17,r6,r17
   43fe4:	28c5c83a 	sub	r2,r5,r3
   43fe8:	344d803a 	cmpltu	r6,r6,r17
   43fec:	1187c83a 	sub	r3,r2,r6
   43ff0:	4821883a 	mov	r16,r9
   43ff4:	3825883a 	mov	r18,r7
   43ff8:	003f0606 	br	43c14 <__alt_data_end+0xfffdbc14>
   43ffc:	2023883a 	mov	r17,r4
   44000:	003f0906 	br	43c28 <__alt_data_end+0xfffdbc28>
   44004:	0101ffc4 	movi	r4,2047
   44008:	813f3a1e 	bne	r16,r4,43cf4 <__alt_data_end+0xfffdbcf4>
   4400c:	003ec406 	br	43b20 <__alt_data_end+0xfffdbb20>
   44010:	0005883a 	mov	r2,zero
   44014:	003fb106 	br	43edc <__alt_data_end+0xfffdbedc>
   44018:	0005883a 	mov	r2,zero
   4401c:	003fbc06 	br	43f10 <__alt_data_end+0xfffdbf10>
   44020:	1c44b03a 	or	r2,r3,r17
   44024:	80008e1e 	bne	r16,zero,44260 <__subdf3+0x7c4>
   44028:	1000c826 	beq	r2,zero,4434c <__subdf3+0x8b0>
   4402c:	2984b03a 	or	r2,r5,r6
   44030:	103ebb26 	beq	r2,zero,43b20 <__alt_data_end+0xfffdbb20>
   44034:	8989883a 	add	r4,r17,r6
   44038:	1945883a 	add	r2,r3,r5
   4403c:	2447803a 	cmpltu	r3,r4,r17
   44040:	1887883a 	add	r3,r3,r2
   44044:	1880202c 	andhi	r2,r3,128
   44048:	2023883a 	mov	r17,r4
   4404c:	103f1626 	beq	r2,zero,43ca8 <__alt_data_end+0xfffdbca8>
   44050:	00bfe034 	movhi	r2,65408
   44054:	10bfffc4 	addi	r2,r2,-1
   44058:	5021883a 	mov	r16,r10
   4405c:	1886703a 	and	r3,r3,r2
   44060:	003eaf06 	br	43b20 <__alt_data_end+0xfffdbb20>
   44064:	3825883a 	mov	r18,r7
   44068:	003f0f06 	br	43ca8 <__alt_data_end+0xfffdbca8>
   4406c:	1c44b03a 	or	r2,r3,r17
   44070:	8000251e 	bne	r16,zero,44108 <__subdf3+0x66c>
   44074:	1000661e 	bne	r2,zero,44210 <__subdf3+0x774>
   44078:	2990b03a 	or	r8,r5,r6
   4407c:	40009626 	beq	r8,zero,442d8 <__subdf3+0x83c>
   44080:	2807883a 	mov	r3,r5
   44084:	3023883a 	mov	r17,r6
   44088:	3825883a 	mov	r18,r7
   4408c:	003ea406 	br	43b20 <__alt_data_end+0xfffdbb20>
   44090:	127ff804 	addi	r9,r2,-32
   44094:	01000804 	movi	r4,32
   44098:	2a52d83a 	srl	r9,r5,r9
   4409c:	11008c26 	beq	r2,r4,442d0 <__subdf3+0x834>
   440a0:	01001004 	movi	r4,64
   440a4:	2085c83a 	sub	r2,r4,r2
   440a8:	2884983a 	sll	r2,r5,r2
   440ac:	118cb03a 	or	r6,r2,r6
   440b0:	300cc03a 	cmpne	r6,r6,zero
   440b4:	4992b03a 	or	r9,r9,r6
   440b8:	0005883a 	mov	r2,zero
   440bc:	003f1206 	br	43d08 <__alt_data_end+0xfffdbd08>
   440c0:	0101ffc4 	movi	r4,2047
   440c4:	493f9c1e 	bne	r9,r4,43f38 <__alt_data_end+0xfffdbf38>
   440c8:	2807883a 	mov	r3,r5
   440cc:	3023883a 	mov	r17,r6
   440d0:	4821883a 	mov	r16,r9
   440d4:	3825883a 	mov	r18,r7
   440d8:	003e9106 	br	43b20 <__alt_data_end+0xfffdbb20>
   440dc:	80001f1e 	bne	r16,zero,4415c <__subdf3+0x6c0>
   440e0:	1c48b03a 	or	r4,r3,r17
   440e4:	20005a26 	beq	r4,zero,44250 <__subdf3+0x7b4>
   440e8:	0084303a 	nor	r2,zero,r2
   440ec:	1000561e 	bne	r2,zero,44248 <__subdf3+0x7ac>
   440f0:	89a3883a 	add	r17,r17,r6
   440f4:	1945883a 	add	r2,r3,r5
   440f8:	898d803a 	cmpltu	r6,r17,r6
   440fc:	3087883a 	add	r3,r6,r2
   44100:	4821883a 	mov	r16,r9
   44104:	003f0506 	br	43d1c <__alt_data_end+0xfffdbd1c>
   44108:	10002b1e 	bne	r2,zero,441b8 <__subdf3+0x71c>
   4410c:	2984b03a 	or	r2,r5,r6
   44110:	10008026 	beq	r2,zero,44314 <__subdf3+0x878>
   44114:	2807883a 	mov	r3,r5
   44118:	3023883a 	mov	r17,r6
   4411c:	3825883a 	mov	r18,r7
   44120:	0401ffc4 	movi	r16,2047
   44124:	003e7e06 	br	43b20 <__alt_data_end+0xfffdbb20>
   44128:	3809883a 	mov	r4,r7
   4412c:	0011883a 	mov	r8,zero
   44130:	0005883a 	mov	r2,zero
   44134:	003ee306 	br	43cc4 <__alt_data_end+0xfffdbcc4>
   44138:	1c62b03a 	or	r17,r3,r17
   4413c:	8822c03a 	cmpne	r17,r17,zero
   44140:	0005883a 	mov	r2,zero
   44144:	003f8906 	br	43f6c <__alt_data_end+0xfffdbf6c>
   44148:	3809883a 	mov	r4,r7
   4414c:	4821883a 	mov	r16,r9
   44150:	0011883a 	mov	r8,zero
   44154:	0005883a 	mov	r2,zero
   44158:	003eda06 	br	43cc4 <__alt_data_end+0xfffdbcc4>
   4415c:	0101ffc4 	movi	r4,2047
   44160:	49003b26 	beq	r9,r4,44250 <__subdf3+0x7b4>
   44164:	0085c83a 	sub	r2,zero,r2
   44168:	18c02034 	orhi	r3,r3,128
   4416c:	01000e04 	movi	r4,56
   44170:	20806e16 	blt	r4,r2,4432c <__subdf3+0x890>
   44174:	010007c4 	movi	r4,31
   44178:	20807716 	blt	r4,r2,44358 <__subdf3+0x8bc>
   4417c:	01000804 	movi	r4,32
   44180:	2089c83a 	sub	r4,r4,r2
   44184:	1914983a 	sll	r10,r3,r4
   44188:	8890d83a 	srl	r8,r17,r2
   4418c:	8908983a 	sll	r4,r17,r4
   44190:	1884d83a 	srl	r2,r3,r2
   44194:	5222b03a 	or	r17,r10,r8
   44198:	2006c03a 	cmpne	r3,r4,zero
   4419c:	88e2b03a 	or	r17,r17,r3
   441a0:	89a3883a 	add	r17,r17,r6
   441a4:	1145883a 	add	r2,r2,r5
   441a8:	898d803a 	cmpltu	r6,r17,r6
   441ac:	3087883a 	add	r3,r6,r2
   441b0:	4821883a 	mov	r16,r9
   441b4:	003ed906 	br	43d1c <__alt_data_end+0xfffdbd1c>
   441b8:	2984b03a 	or	r2,r5,r6
   441bc:	10004226 	beq	r2,zero,442c8 <__subdf3+0x82c>
   441c0:	1808d0fa 	srli	r4,r3,3
   441c4:	8822d0fa 	srli	r17,r17,3
   441c8:	1806977a 	slli	r3,r3,29
   441cc:	2080022c 	andhi	r2,r4,8
   441d0:	1c62b03a 	or	r17,r3,r17
   441d4:	10000826 	beq	r2,zero,441f8 <__subdf3+0x75c>
   441d8:	2812d0fa 	srli	r9,r5,3
   441dc:	4880022c 	andhi	r2,r9,8
   441e0:	1000051e 	bne	r2,zero,441f8 <__subdf3+0x75c>
   441e4:	300cd0fa 	srli	r6,r6,3
   441e8:	2804977a 	slli	r2,r5,29
   441ec:	4809883a 	mov	r4,r9
   441f0:	3825883a 	mov	r18,r7
   441f4:	11a2b03a 	or	r17,r2,r6
   441f8:	8806d77a 	srli	r3,r17,29
   441fc:	200890fa 	slli	r4,r4,3
   44200:	882290fa 	slli	r17,r17,3
   44204:	0401ffc4 	movi	r16,2047
   44208:	1906b03a 	or	r3,r3,r4
   4420c:	003e4406 	br	43b20 <__alt_data_end+0xfffdbb20>
   44210:	2984b03a 	or	r2,r5,r6
   44214:	103e4226 	beq	r2,zero,43b20 <__alt_data_end+0xfffdbb20>
   44218:	8989c83a 	sub	r4,r17,r6
   4421c:	8911803a 	cmpltu	r8,r17,r4
   44220:	1945c83a 	sub	r2,r3,r5
   44224:	1205c83a 	sub	r2,r2,r8
   44228:	1200202c 	andhi	r8,r2,128
   4422c:	403e9a26 	beq	r8,zero,43c98 <__alt_data_end+0xfffdbc98>
   44230:	3463c83a 	sub	r17,r6,r17
   44234:	28c5c83a 	sub	r2,r5,r3
   44238:	344d803a 	cmpltu	r6,r6,r17
   4423c:	1187c83a 	sub	r3,r2,r6
   44240:	3825883a 	mov	r18,r7
   44244:	003e3606 	br	43b20 <__alt_data_end+0xfffdbb20>
   44248:	0101ffc4 	movi	r4,2047
   4424c:	493fc71e 	bne	r9,r4,4416c <__alt_data_end+0xfffdc16c>
   44250:	2807883a 	mov	r3,r5
   44254:	3023883a 	mov	r17,r6
   44258:	4821883a 	mov	r16,r9
   4425c:	003e3006 	br	43b20 <__alt_data_end+0xfffdbb20>
   44260:	10003626 	beq	r2,zero,4433c <__subdf3+0x8a0>
   44264:	2984b03a 	or	r2,r5,r6
   44268:	10001726 	beq	r2,zero,442c8 <__subdf3+0x82c>
   4426c:	1808d0fa 	srli	r4,r3,3
   44270:	8822d0fa 	srli	r17,r17,3
   44274:	1806977a 	slli	r3,r3,29
   44278:	2080022c 	andhi	r2,r4,8
   4427c:	1c62b03a 	or	r17,r3,r17
   44280:	10000726 	beq	r2,zero,442a0 <__subdf3+0x804>
   44284:	2812d0fa 	srli	r9,r5,3
   44288:	4880022c 	andhi	r2,r9,8
   4428c:	1000041e 	bne	r2,zero,442a0 <__subdf3+0x804>
   44290:	300cd0fa 	srli	r6,r6,3
   44294:	2804977a 	slli	r2,r5,29
   44298:	4809883a 	mov	r4,r9
   4429c:	11a2b03a 	or	r17,r2,r6
   442a0:	8806d77a 	srli	r3,r17,29
   442a4:	200890fa 	slli	r4,r4,3
   442a8:	882290fa 	slli	r17,r17,3
   442ac:	3825883a 	mov	r18,r7
   442b0:	1906b03a 	or	r3,r3,r4
   442b4:	0401ffc4 	movi	r16,2047
   442b8:	003e1906 	br	43b20 <__alt_data_end+0xfffdbb20>
   442bc:	000b883a 	mov	r5,zero
   442c0:	0005883a 	mov	r2,zero
   442c4:	003e2e06 	br	43b80 <__alt_data_end+0xfffdbb80>
   442c8:	0401ffc4 	movi	r16,2047
   442cc:	003e1406 	br	43b20 <__alt_data_end+0xfffdbb20>
   442d0:	0005883a 	mov	r2,zero
   442d4:	003f7506 	br	440ac <__alt_data_end+0xfffdc0ac>
   442d8:	0005883a 	mov	r2,zero
   442dc:	0009883a 	mov	r4,zero
   442e0:	003e7806 	br	43cc4 <__alt_data_end+0xfffdbcc4>
   442e4:	123ff804 	addi	r8,r2,-32
   442e8:	01000804 	movi	r4,32
   442ec:	1a10d83a 	srl	r8,r3,r8
   442f0:	11002526 	beq	r2,r4,44388 <__subdf3+0x8ec>
   442f4:	01001004 	movi	r4,64
   442f8:	2085c83a 	sub	r2,r4,r2
   442fc:	1884983a 	sll	r2,r3,r2
   44300:	1444b03a 	or	r2,r2,r17
   44304:	1004c03a 	cmpne	r2,r2,zero
   44308:	40a2b03a 	or	r17,r8,r2
   4430c:	0005883a 	mov	r2,zero
   44310:	003f1606 	br	43f6c <__alt_data_end+0xfffdbf6c>
   44314:	02000434 	movhi	r8,16
   44318:	0009883a 	mov	r4,zero
   4431c:	423fffc4 	addi	r8,r8,-1
   44320:	00bfffc4 	movi	r2,-1
   44324:	0401ffc4 	movi	r16,2047
   44328:	003e6606 	br	43cc4 <__alt_data_end+0xfffdbcc4>
   4432c:	1c62b03a 	or	r17,r3,r17
   44330:	8822c03a 	cmpne	r17,r17,zero
   44334:	0005883a 	mov	r2,zero
   44338:	003f9906 	br	441a0 <__alt_data_end+0xfffdc1a0>
   4433c:	2807883a 	mov	r3,r5
   44340:	3023883a 	mov	r17,r6
   44344:	0401ffc4 	movi	r16,2047
   44348:	003df506 	br	43b20 <__alt_data_end+0xfffdbb20>
   4434c:	2807883a 	mov	r3,r5
   44350:	3023883a 	mov	r17,r6
   44354:	003df206 	br	43b20 <__alt_data_end+0xfffdbb20>
   44358:	123ff804 	addi	r8,r2,-32
   4435c:	01000804 	movi	r4,32
   44360:	1a10d83a 	srl	r8,r3,r8
   44364:	11000a26 	beq	r2,r4,44390 <__subdf3+0x8f4>
   44368:	01001004 	movi	r4,64
   4436c:	2085c83a 	sub	r2,r4,r2
   44370:	1884983a 	sll	r2,r3,r2
   44374:	1444b03a 	or	r2,r2,r17
   44378:	1004c03a 	cmpne	r2,r2,zero
   4437c:	40a2b03a 	or	r17,r8,r2
   44380:	0005883a 	mov	r2,zero
   44384:	003f8606 	br	441a0 <__alt_data_end+0xfffdc1a0>
   44388:	0005883a 	mov	r2,zero
   4438c:	003fdc06 	br	44300 <__alt_data_end+0xfffdc300>
   44390:	0005883a 	mov	r2,zero
   44394:	003ff706 	br	44374 <__alt_data_end+0xfffdc374>

00044398 <__fixdfsi>:
   44398:	280cd53a 	srli	r6,r5,20
   4439c:	00c00434 	movhi	r3,16
   443a0:	18ffffc4 	addi	r3,r3,-1
   443a4:	3181ffcc 	andi	r6,r6,2047
   443a8:	01c0ff84 	movi	r7,1022
   443ac:	28c6703a 	and	r3,r5,r3
   443b0:	280ad7fa 	srli	r5,r5,31
   443b4:	3980120e 	bge	r7,r6,44400 <__fixdfsi+0x68>
   443b8:	00810744 	movi	r2,1053
   443bc:	11800c16 	blt	r2,r6,443f0 <__fixdfsi+0x58>
   443c0:	00810cc4 	movi	r2,1075
   443c4:	1185c83a 	sub	r2,r2,r6
   443c8:	01c007c4 	movi	r7,31
   443cc:	18c00434 	orhi	r3,r3,16
   443d0:	38800d16 	blt	r7,r2,44408 <__fixdfsi+0x70>
   443d4:	31befb44 	addi	r6,r6,-1043
   443d8:	2084d83a 	srl	r2,r4,r2
   443dc:	1986983a 	sll	r3,r3,r6
   443e0:	1884b03a 	or	r2,r3,r2
   443e4:	28000726 	beq	r5,zero,44404 <__fixdfsi+0x6c>
   443e8:	0085c83a 	sub	r2,zero,r2
   443ec:	f800283a 	ret
   443f0:	00a00034 	movhi	r2,32768
   443f4:	10bfffc4 	addi	r2,r2,-1
   443f8:	2885883a 	add	r2,r5,r2
   443fc:	f800283a 	ret
   44400:	0005883a 	mov	r2,zero
   44404:	f800283a 	ret
   44408:	008104c4 	movi	r2,1043
   4440c:	1185c83a 	sub	r2,r2,r6
   44410:	1884d83a 	srl	r2,r3,r2
   44414:	003ff306 	br	443e4 <__alt_data_end+0xfffdc3e4>

00044418 <__floatunsidf>:
   44418:	defffe04 	addi	sp,sp,-8
   4441c:	dc000015 	stw	r16,0(sp)
   44420:	dfc00115 	stw	ra,4(sp)
   44424:	2021883a 	mov	r16,r4
   44428:	20002226 	beq	r4,zero,444b4 <__floatunsidf+0x9c>
   4442c:	00444c00 	call	444c0 <__clzsi2>
   44430:	01010784 	movi	r4,1054
   44434:	2089c83a 	sub	r4,r4,r2
   44438:	01810cc4 	movi	r6,1075
   4443c:	310dc83a 	sub	r6,r6,r4
   44440:	00c007c4 	movi	r3,31
   44444:	1980120e 	bge	r3,r6,44490 <__floatunsidf+0x78>
   44448:	00c104c4 	movi	r3,1043
   4444c:	1907c83a 	sub	r3,r3,r4
   44450:	80ca983a 	sll	r5,r16,r3
   44454:	00800434 	movhi	r2,16
   44458:	10bfffc4 	addi	r2,r2,-1
   4445c:	2101ffcc 	andi	r4,r4,2047
   44460:	0021883a 	mov	r16,zero
   44464:	288a703a 	and	r5,r5,r2
   44468:	2008953a 	slli	r4,r4,20
   4446c:	00c00434 	movhi	r3,16
   44470:	18ffffc4 	addi	r3,r3,-1
   44474:	28c6703a 	and	r3,r5,r3
   44478:	8005883a 	mov	r2,r16
   4447c:	1906b03a 	or	r3,r3,r4
   44480:	dfc00117 	ldw	ra,4(sp)
   44484:	dc000017 	ldw	r16,0(sp)
   44488:	dec00204 	addi	sp,sp,8
   4448c:	f800283a 	ret
   44490:	00c002c4 	movi	r3,11
   44494:	188bc83a 	sub	r5,r3,r2
   44498:	814ad83a 	srl	r5,r16,r5
   4449c:	00c00434 	movhi	r3,16
   444a0:	18ffffc4 	addi	r3,r3,-1
   444a4:	81a0983a 	sll	r16,r16,r6
   444a8:	2101ffcc 	andi	r4,r4,2047
   444ac:	28ca703a 	and	r5,r5,r3
   444b0:	003fed06 	br	44468 <__alt_data_end+0xfffdc468>
   444b4:	0009883a 	mov	r4,zero
   444b8:	000b883a 	mov	r5,zero
   444bc:	003fea06 	br	44468 <__alt_data_end+0xfffdc468>

000444c0 <__clzsi2>:
   444c0:	00bfffd4 	movui	r2,65535
   444c4:	11000536 	bltu	r2,r4,444dc <__clzsi2+0x1c>
   444c8:	00803fc4 	movi	r2,255
   444cc:	11000f36 	bltu	r2,r4,4450c <__clzsi2+0x4c>
   444d0:	00800804 	movi	r2,32
   444d4:	0007883a 	mov	r3,zero
   444d8:	00000506 	br	444f0 <__clzsi2+0x30>
   444dc:	00804034 	movhi	r2,256
   444e0:	10bfffc4 	addi	r2,r2,-1
   444e4:	11000c2e 	bgeu	r2,r4,44518 <__clzsi2+0x58>
   444e8:	00800204 	movi	r2,8
   444ec:	00c00604 	movi	r3,24
   444f0:	20c8d83a 	srl	r4,r4,r3
   444f4:	00c00134 	movhi	r3,4
   444f8:	18dfd684 	addi	r3,r3,32602
   444fc:	1909883a 	add	r4,r3,r4
   44500:	20c00003 	ldbu	r3,0(r4)
   44504:	10c5c83a 	sub	r2,r2,r3
   44508:	f800283a 	ret
   4450c:	00800604 	movi	r2,24
   44510:	00c00204 	movi	r3,8
   44514:	003ff606 	br	444f0 <__alt_data_end+0xfffdc4f0>
   44518:	00800404 	movi	r2,16
   4451c:	1007883a 	mov	r3,r2
   44520:	003ff306 	br	444f0 <__alt_data_end+0xfffdc4f0>

00044524 <_printf_r>:
   44524:	defffd04 	addi	sp,sp,-12
   44528:	dfc00015 	stw	ra,0(sp)
   4452c:	d9800115 	stw	r6,4(sp)
   44530:	d9c00215 	stw	r7,8(sp)
   44534:	20c00217 	ldw	r3,8(r4)
   44538:	01800134 	movhi	r6,4
   4453c:	31930204 	addi	r6,r6,19464
   44540:	19800115 	stw	r6,4(r3)
   44544:	280d883a 	mov	r6,r5
   44548:	21400217 	ldw	r5,8(r4)
   4454c:	d9c00104 	addi	r7,sp,4
   44550:	00446c80 	call	446c8 <___vfprintf_internal_r>
   44554:	dfc00017 	ldw	ra,0(sp)
   44558:	dec00304 	addi	sp,sp,12
   4455c:	f800283a 	ret

00044560 <printf>:
   44560:	defffc04 	addi	sp,sp,-16
   44564:	dfc00015 	stw	ra,0(sp)
   44568:	d9400115 	stw	r5,4(sp)
   4456c:	d9800215 	stw	r6,8(sp)
   44570:	d9c00315 	stw	r7,12(sp)
   44574:	00800174 	movhi	r2,5
   44578:	10a10504 	addi	r2,r2,-31724
   4457c:	10800017 	ldw	r2,0(r2)
   44580:	01400134 	movhi	r5,4
   44584:	29530204 	addi	r5,r5,19464
   44588:	10c00217 	ldw	r3,8(r2)
   4458c:	d9800104 	addi	r6,sp,4
   44590:	19400115 	stw	r5,4(r3)
   44594:	200b883a 	mov	r5,r4
   44598:	11000217 	ldw	r4,8(r2)
   4459c:	0044bec0 	call	44bec <__vfprintf_internal>
   445a0:	dfc00017 	ldw	ra,0(sp)
   445a4:	dec00404 	addi	sp,sp,16
   445a8:	f800283a 	ret

000445ac <_puts_r>:
   445ac:	defffd04 	addi	sp,sp,-12
   445b0:	dc000015 	stw	r16,0(sp)
   445b4:	2021883a 	mov	r16,r4
   445b8:	2809883a 	mov	r4,r5
   445bc:	dfc00215 	stw	ra,8(sp)
   445c0:	dc400115 	stw	r17,4(sp)
   445c4:	2823883a 	mov	r17,r5
   445c8:	00446400 	call	44640 <strlen>
   445cc:	81400217 	ldw	r5,8(r16)
   445d0:	01000134 	movhi	r4,4
   445d4:	21130204 	addi	r4,r4,19464
   445d8:	29000115 	stw	r4,4(r5)
   445dc:	100f883a 	mov	r7,r2
   445e0:	880d883a 	mov	r6,r17
   445e4:	8009883a 	mov	r4,r16
   445e8:	0044c080 	call	44c08 <__sfvwrite_small_dev>
   445ec:	00ffffc4 	movi	r3,-1
   445f0:	10c00926 	beq	r2,r3,44618 <_puts_r+0x6c>
   445f4:	81400217 	ldw	r5,8(r16)
   445f8:	01800174 	movhi	r6,5
   445fc:	01c00044 	movi	r7,1
   44600:	28800117 	ldw	r2,4(r5)
   44604:	31a01704 	addi	r6,r6,-32676
   44608:	8009883a 	mov	r4,r16
   4460c:	103ee83a 	callr	r2
   44610:	10bfffe0 	cmpeqi	r2,r2,-1
   44614:	0085c83a 	sub	r2,zero,r2
   44618:	dfc00217 	ldw	ra,8(sp)
   4461c:	dc400117 	ldw	r17,4(sp)
   44620:	dc000017 	ldw	r16,0(sp)
   44624:	dec00304 	addi	sp,sp,12
   44628:	f800283a 	ret

0004462c <puts>:
   4462c:	00800174 	movhi	r2,5
   44630:	10a10504 	addi	r2,r2,-31724
   44634:	200b883a 	mov	r5,r4
   44638:	11000017 	ldw	r4,0(r2)
   4463c:	00445ac1 	jmpi	445ac <_puts_r>

00044640 <strlen>:
   44640:	2005883a 	mov	r2,r4
   44644:	10c00007 	ldb	r3,0(r2)
   44648:	18000226 	beq	r3,zero,44654 <strlen+0x14>
   4464c:	10800044 	addi	r2,r2,1
   44650:	003ffc06 	br	44644 <__alt_data_end+0xfffdc644>
   44654:	1105c83a 	sub	r2,r2,r4
   44658:	f800283a 	ret

0004465c <print_repeat>:
   4465c:	defffb04 	addi	sp,sp,-20
   44660:	dc800315 	stw	r18,12(sp)
   44664:	dc400215 	stw	r17,8(sp)
   44668:	dc000115 	stw	r16,4(sp)
   4466c:	dfc00415 	stw	ra,16(sp)
   44670:	2025883a 	mov	r18,r4
   44674:	2823883a 	mov	r17,r5
   44678:	d9800005 	stb	r6,0(sp)
   4467c:	3821883a 	mov	r16,r7
   44680:	04000a0e 	bge	zero,r16,446ac <print_repeat+0x50>
   44684:	88800117 	ldw	r2,4(r17)
   44688:	01c00044 	movi	r7,1
   4468c:	d80d883a 	mov	r6,sp
   44690:	880b883a 	mov	r5,r17
   44694:	9009883a 	mov	r4,r18
   44698:	103ee83a 	callr	r2
   4469c:	843fffc4 	addi	r16,r16,-1
   446a0:	103ff726 	beq	r2,zero,44680 <__alt_data_end+0xfffdc680>
   446a4:	00bfffc4 	movi	r2,-1
   446a8:	00000106 	br	446b0 <print_repeat+0x54>
   446ac:	0005883a 	mov	r2,zero
   446b0:	dfc00417 	ldw	ra,16(sp)
   446b4:	dc800317 	ldw	r18,12(sp)
   446b8:	dc400217 	ldw	r17,8(sp)
   446bc:	dc000117 	ldw	r16,4(sp)
   446c0:	dec00504 	addi	sp,sp,20
   446c4:	f800283a 	ret

000446c8 <___vfprintf_internal_r>:
   446c8:	deffe504 	addi	sp,sp,-108
   446cc:	d8c00804 	addi	r3,sp,32
   446d0:	df001915 	stw	fp,100(sp)
   446d4:	ddc01815 	stw	r23,96(sp)
   446d8:	dd801715 	stw	r22,92(sp)
   446dc:	dd401615 	stw	r21,88(sp)
   446e0:	dd001515 	stw	r20,84(sp)
   446e4:	dcc01415 	stw	r19,80(sp)
   446e8:	dc801315 	stw	r18,76(sp)
   446ec:	dc401215 	stw	r17,72(sp)
   446f0:	dc001115 	stw	r16,68(sp)
   446f4:	dfc01a15 	stw	ra,104(sp)
   446f8:	2027883a 	mov	r19,r4
   446fc:	2839883a 	mov	fp,r5
   44700:	382d883a 	mov	r22,r7
   44704:	d9800f15 	stw	r6,60(sp)
   44708:	0021883a 	mov	r16,zero
   4470c:	d8000e15 	stw	zero,56(sp)
   44710:	002f883a 	mov	r23,zero
   44714:	002b883a 	mov	r21,zero
   44718:	0025883a 	mov	r18,zero
   4471c:	0023883a 	mov	r17,zero
   44720:	d8000c15 	stw	zero,48(sp)
   44724:	d8000b15 	stw	zero,44(sp)
   44728:	0029883a 	mov	r20,zero
   4472c:	d8c00915 	stw	r3,36(sp)
   44730:	d8c00f17 	ldw	r3,60(sp)
   44734:	19000003 	ldbu	r4,0(r3)
   44738:	20803fcc 	andi	r2,r4,255
   4473c:	1080201c 	xori	r2,r2,128
   44740:	10bfe004 	addi	r2,r2,-128
   44744:	10011c26 	beq	r2,zero,44bb8 <___vfprintf_internal_r+0x4f0>
   44748:	00c00044 	movi	r3,1
   4474c:	a0c01426 	beq	r20,r3,447a0 <___vfprintf_internal_r+0xd8>
   44750:	1d000216 	blt	r3,r20,4475c <___vfprintf_internal_r+0x94>
   44754:	a0000626 	beq	r20,zero,44770 <___vfprintf_internal_r+0xa8>
   44758:	00011306 	br	44ba8 <___vfprintf_internal_r+0x4e0>
   4475c:	01400084 	movi	r5,2
   44760:	a1401d26 	beq	r20,r5,447d8 <___vfprintf_internal_r+0x110>
   44764:	014000c4 	movi	r5,3
   44768:	a1402926 	beq	r20,r5,44810 <___vfprintf_internal_r+0x148>
   4476c:	00010e06 	br	44ba8 <___vfprintf_internal_r+0x4e0>
   44770:	01400944 	movi	r5,37
   44774:	1140fb26 	beq	r2,r5,44b64 <___vfprintf_internal_r+0x49c>
   44778:	e0800117 	ldw	r2,4(fp)
   4477c:	d9000005 	stb	r4,0(sp)
   44780:	01c00044 	movi	r7,1
   44784:	d80d883a 	mov	r6,sp
   44788:	e00b883a 	mov	r5,fp
   4478c:	9809883a 	mov	r4,r19
   44790:	103ee83a 	callr	r2
   44794:	1000d61e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   44798:	84000044 	addi	r16,r16,1
   4479c:	00010206 	br	44ba8 <___vfprintf_internal_r+0x4e0>
   447a0:	01400c04 	movi	r5,48
   447a4:	1140f826 	beq	r2,r5,44b88 <___vfprintf_internal_r+0x4c0>
   447a8:	01400944 	movi	r5,37
   447ac:	11400a1e 	bne	r2,r5,447d8 <___vfprintf_internal_r+0x110>
   447b0:	d8800005 	stb	r2,0(sp)
   447b4:	e0800117 	ldw	r2,4(fp)
   447b8:	a00f883a 	mov	r7,r20
   447bc:	d80d883a 	mov	r6,sp
   447c0:	e00b883a 	mov	r5,fp
   447c4:	9809883a 	mov	r4,r19
   447c8:	103ee83a 	callr	r2
   447cc:	1000c81e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   447d0:	84000044 	addi	r16,r16,1
   447d4:	0000f306 	br	44ba4 <___vfprintf_internal_r+0x4dc>
   447d8:	217ff404 	addi	r5,r4,-48
   447dc:	29403fcc 	andi	r5,r5,255
   447e0:	00c00244 	movi	r3,9
   447e4:	19400736 	bltu	r3,r5,44804 <___vfprintf_internal_r+0x13c>
   447e8:	00bfffc4 	movi	r2,-1
   447ec:	88800226 	beq	r17,r2,447f8 <___vfprintf_internal_r+0x130>
   447f0:	8c4002a4 	muli	r17,r17,10
   447f4:	00000106 	br	447fc <___vfprintf_internal_r+0x134>
   447f8:	0023883a 	mov	r17,zero
   447fc:	2c63883a 	add	r17,r5,r17
   44800:	0000e206 	br	44b8c <___vfprintf_internal_r+0x4c4>
   44804:	01400b84 	movi	r5,46
   44808:	1140e426 	beq	r2,r5,44b9c <___vfprintf_internal_r+0x4d4>
   4480c:	05000084 	movi	r20,2
   44810:	213ff404 	addi	r4,r4,-48
   44814:	21003fcc 	andi	r4,r4,255
   44818:	00c00244 	movi	r3,9
   4481c:	19000736 	bltu	r3,r4,4483c <___vfprintf_internal_r+0x174>
   44820:	00bfffc4 	movi	r2,-1
   44824:	90800226 	beq	r18,r2,44830 <___vfprintf_internal_r+0x168>
   44828:	948002a4 	muli	r18,r18,10
   4482c:	00000106 	br	44834 <___vfprintf_internal_r+0x16c>
   44830:	0025883a 	mov	r18,zero
   44834:	24a5883a 	add	r18,r4,r18
   44838:	0000db06 	br	44ba8 <___vfprintf_internal_r+0x4e0>
   4483c:	00c01b04 	movi	r3,108
   44840:	10c0d426 	beq	r2,r3,44b94 <___vfprintf_internal_r+0x4cc>
   44844:	013fffc4 	movi	r4,-1
   44848:	91000226 	beq	r18,r4,44854 <___vfprintf_internal_r+0x18c>
   4484c:	d8000b15 	stw	zero,44(sp)
   44850:	00000106 	br	44858 <___vfprintf_internal_r+0x190>
   44854:	04800044 	movi	r18,1
   44858:	01001a44 	movi	r4,105
   4485c:	11001626 	beq	r2,r4,448b8 <___vfprintf_internal_r+0x1f0>
   44860:	20800916 	blt	r4,r2,44888 <___vfprintf_internal_r+0x1c0>
   44864:	010018c4 	movi	r4,99
   44868:	11008a26 	beq	r2,r4,44a94 <___vfprintf_internal_r+0x3cc>
   4486c:	01001904 	movi	r4,100
   44870:	11001126 	beq	r2,r4,448b8 <___vfprintf_internal_r+0x1f0>
   44874:	01001604 	movi	r4,88
   44878:	1100ca1e 	bne	r2,r4,44ba4 <___vfprintf_internal_r+0x4dc>
   4487c:	00c00044 	movi	r3,1
   44880:	d8c00e15 	stw	r3,56(sp)
   44884:	00001406 	br	448d8 <___vfprintf_internal_r+0x210>
   44888:	01001cc4 	movi	r4,115
   4488c:	11009a26 	beq	r2,r4,44af8 <___vfprintf_internal_r+0x430>
   44890:	20800416 	blt	r4,r2,448a4 <___vfprintf_internal_r+0x1dc>
   44894:	01001bc4 	movi	r4,111
   44898:	1100c21e 	bne	r2,r4,44ba4 <___vfprintf_internal_r+0x4dc>
   4489c:	05400204 	movi	r21,8
   448a0:	00000e06 	br	448dc <___vfprintf_internal_r+0x214>
   448a4:	01001d44 	movi	r4,117
   448a8:	11000c26 	beq	r2,r4,448dc <___vfprintf_internal_r+0x214>
   448ac:	01001e04 	movi	r4,120
   448b0:	11000926 	beq	r2,r4,448d8 <___vfprintf_internal_r+0x210>
   448b4:	0000bb06 	br	44ba4 <___vfprintf_internal_r+0x4dc>
   448b8:	b5000104 	addi	r20,r22,4
   448bc:	b8000726 	beq	r23,zero,448dc <___vfprintf_internal_r+0x214>
   448c0:	dd000d15 	stw	r20,52(sp)
   448c4:	b5800017 	ldw	r22,0(r22)
   448c8:	b000080e 	bge	r22,zero,448ec <___vfprintf_internal_r+0x224>
   448cc:	05adc83a 	sub	r22,zero,r22
   448d0:	02800044 	movi	r10,1
   448d4:	00000606 	br	448f0 <___vfprintf_internal_r+0x228>
   448d8:	05400404 	movi	r21,16
   448dc:	b0c00104 	addi	r3,r22,4
   448e0:	d8c00d15 	stw	r3,52(sp)
   448e4:	b5800017 	ldw	r22,0(r22)
   448e8:	002f883a 	mov	r23,zero
   448ec:	0015883a 	mov	r10,zero
   448f0:	d829883a 	mov	r20,sp
   448f4:	b0001426 	beq	r22,zero,44948 <___vfprintf_internal_r+0x280>
   448f8:	b009883a 	mov	r4,r22
   448fc:	a80b883a 	mov	r5,r21
   44900:	da801015 	stw	r10,64(sp)
   44904:	00431ec0 	call	431ec <__udivsi3>
   44908:	1549383a 	mul	r4,r2,r21
   4490c:	00c00244 	movi	r3,9
   44910:	da801017 	ldw	r10,64(sp)
   44914:	b12dc83a 	sub	r22,r22,r4
   44918:	1d800216 	blt	r3,r22,44924 <___vfprintf_internal_r+0x25c>
   4491c:	b5800c04 	addi	r22,r22,48
   44920:	00000506 	br	44938 <___vfprintf_internal_r+0x270>
   44924:	d8c00e17 	ldw	r3,56(sp)
   44928:	18000226 	beq	r3,zero,44934 <___vfprintf_internal_r+0x26c>
   4492c:	b5800dc4 	addi	r22,r22,55
   44930:	00000106 	br	44938 <___vfprintf_internal_r+0x270>
   44934:	b58015c4 	addi	r22,r22,87
   44938:	a5800005 	stb	r22,0(r20)
   4493c:	a5000044 	addi	r20,r20,1
   44940:	102d883a 	mov	r22,r2
   44944:	003feb06 	br	448f4 <__alt_data_end+0xfffdc8f4>
   44948:	a6c7c83a 	sub	r3,r20,sp
   4494c:	d8c00a15 	stw	r3,40(sp)
   44950:	90c5c83a 	sub	r2,r18,r3
   44954:	00800a0e 	bge	zero,r2,44980 <___vfprintf_internal_r+0x2b8>
   44958:	a085883a 	add	r2,r20,r2
   4495c:	01400c04 	movi	r5,48
   44960:	d8c00917 	ldw	r3,36(sp)
   44964:	a009883a 	mov	r4,r20
   44968:	a0c0032e 	bgeu	r20,r3,44978 <___vfprintf_internal_r+0x2b0>
   4496c:	a5000044 	addi	r20,r20,1
   44970:	21400005 	stb	r5,0(r4)
   44974:	a0bffa1e 	bne	r20,r2,44960 <__alt_data_end+0xfffdc960>
   44978:	a6c7c83a 	sub	r3,r20,sp
   4497c:	d8c00a15 	stw	r3,40(sp)
   44980:	d8c00a17 	ldw	r3,40(sp)
   44984:	50d3883a 	add	r9,r10,r3
   44988:	d8c00b17 	ldw	r3,44(sp)
   4498c:	8a6dc83a 	sub	r22,r17,r9
   44990:	18001726 	beq	r3,zero,449f0 <___vfprintf_internal_r+0x328>
   44994:	50000a26 	beq	r10,zero,449c0 <___vfprintf_internal_r+0x2f8>
   44998:	00800b44 	movi	r2,45
   4499c:	d8800805 	stb	r2,32(sp)
   449a0:	e0800117 	ldw	r2,4(fp)
   449a4:	01c00044 	movi	r7,1
   449a8:	d9800804 	addi	r6,sp,32
   449ac:	e00b883a 	mov	r5,fp
   449b0:	9809883a 	mov	r4,r19
   449b4:	103ee83a 	callr	r2
   449b8:	10004d1e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   449bc:	84000044 	addi	r16,r16,1
   449c0:	0580070e 	bge	zero,r22,449e0 <___vfprintf_internal_r+0x318>
   449c4:	b00f883a 	mov	r7,r22
   449c8:	01800c04 	movi	r6,48
   449cc:	e00b883a 	mov	r5,fp
   449d0:	9809883a 	mov	r4,r19
   449d4:	004465c0 	call	4465c <print_repeat>
   449d8:	1000451e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   449dc:	85a1883a 	add	r16,r16,r22
   449e0:	d8c00a17 	ldw	r3,40(sp)
   449e4:	a013883a 	mov	r9,r20
   449e8:	1d2dc83a 	sub	r22,r3,r20
   449ec:	00002206 	br	44a78 <___vfprintf_internal_r+0x3b0>
   449f0:	0580090e 	bge	zero,r22,44a18 <___vfprintf_internal_r+0x350>
   449f4:	b00f883a 	mov	r7,r22
   449f8:	01800804 	movi	r6,32
   449fc:	e00b883a 	mov	r5,fp
   44a00:	9809883a 	mov	r4,r19
   44a04:	da801015 	stw	r10,64(sp)
   44a08:	004465c0 	call	4465c <print_repeat>
   44a0c:	da801017 	ldw	r10,64(sp)
   44a10:	1000371e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   44a14:	85a1883a 	add	r16,r16,r22
   44a18:	503ff126 	beq	r10,zero,449e0 <__alt_data_end+0xfffdc9e0>
   44a1c:	00800b44 	movi	r2,45
   44a20:	d8800805 	stb	r2,32(sp)
   44a24:	e0800117 	ldw	r2,4(fp)
   44a28:	01c00044 	movi	r7,1
   44a2c:	d9800804 	addi	r6,sp,32
   44a30:	e00b883a 	mov	r5,fp
   44a34:	9809883a 	mov	r4,r19
   44a38:	103ee83a 	callr	r2
   44a3c:	10002c1e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   44a40:	84000044 	addi	r16,r16,1
   44a44:	003fe606 	br	449e0 <__alt_data_end+0xfffdc9e0>
   44a48:	4a7fffc4 	addi	r9,r9,-1
   44a4c:	48800003 	ldbu	r2,0(r9)
   44a50:	01c00044 	movi	r7,1
   44a54:	d9800804 	addi	r6,sp,32
   44a58:	d8800805 	stb	r2,32(sp)
   44a5c:	e0800117 	ldw	r2,4(fp)
   44a60:	e00b883a 	mov	r5,fp
   44a64:	da401015 	stw	r9,64(sp)
   44a68:	9809883a 	mov	r4,r19
   44a6c:	103ee83a 	callr	r2
   44a70:	da401017 	ldw	r9,64(sp)
   44a74:	10001e1e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   44a78:	8245c83a 	sub	r2,r16,r9
   44a7c:	4d89883a 	add	r4,r9,r22
   44a80:	a085883a 	add	r2,r20,r2
   44a84:	013ff016 	blt	zero,r4,44a48 <__alt_data_end+0xfffdca48>
   44a88:	1021883a 	mov	r16,r2
   44a8c:	dd800d17 	ldw	r22,52(sp)
   44a90:	00004406 	br	44ba4 <___vfprintf_internal_r+0x4dc>
   44a94:	00800044 	movi	r2,1
   44a98:	1440080e 	bge	r2,r17,44abc <___vfprintf_internal_r+0x3f4>
   44a9c:	8d3fffc4 	addi	r20,r17,-1
   44aa0:	a00f883a 	mov	r7,r20
   44aa4:	01800804 	movi	r6,32
   44aa8:	e00b883a 	mov	r5,fp
   44aac:	9809883a 	mov	r4,r19
   44ab0:	004465c0 	call	4465c <print_repeat>
   44ab4:	10000e1e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   44ab8:	8521883a 	add	r16,r16,r20
   44abc:	b0800017 	ldw	r2,0(r22)
   44ac0:	01c00044 	movi	r7,1
   44ac4:	d80d883a 	mov	r6,sp
   44ac8:	d8800005 	stb	r2,0(sp)
   44acc:	e0800117 	ldw	r2,4(fp)
   44ad0:	e00b883a 	mov	r5,fp
   44ad4:	9809883a 	mov	r4,r19
   44ad8:	b5000104 	addi	r20,r22,4
   44adc:	103ee83a 	callr	r2
   44ae0:	1000031e 	bne	r2,zero,44af0 <___vfprintf_internal_r+0x428>
   44ae4:	84000044 	addi	r16,r16,1
   44ae8:	a02d883a 	mov	r22,r20
   44aec:	00002d06 	br	44ba4 <___vfprintf_internal_r+0x4dc>
   44af0:	00bfffc4 	movi	r2,-1
   44af4:	00003106 	br	44bbc <___vfprintf_internal_r+0x4f4>
   44af8:	b5000017 	ldw	r20,0(r22)
   44afc:	b0c00104 	addi	r3,r22,4
   44b00:	d8c00a15 	stw	r3,40(sp)
   44b04:	a009883a 	mov	r4,r20
   44b08:	00446400 	call	44640 <strlen>
   44b0c:	8893c83a 	sub	r9,r17,r2
   44b10:	102d883a 	mov	r22,r2
   44b14:	0240090e 	bge	zero,r9,44b3c <___vfprintf_internal_r+0x474>
   44b18:	480f883a 	mov	r7,r9
   44b1c:	01800804 	movi	r6,32
   44b20:	e00b883a 	mov	r5,fp
   44b24:	9809883a 	mov	r4,r19
   44b28:	da401015 	stw	r9,64(sp)
   44b2c:	004465c0 	call	4465c <print_repeat>
   44b30:	da401017 	ldw	r9,64(sp)
   44b34:	103fee1e 	bne	r2,zero,44af0 <__alt_data_end+0xfffdcaf0>
   44b38:	8261883a 	add	r16,r16,r9
   44b3c:	e0800117 	ldw	r2,4(fp)
   44b40:	b00f883a 	mov	r7,r22
   44b44:	a00d883a 	mov	r6,r20
   44b48:	e00b883a 	mov	r5,fp
   44b4c:	9809883a 	mov	r4,r19
   44b50:	103ee83a 	callr	r2
   44b54:	103fe61e 	bne	r2,zero,44af0 <__alt_data_end+0xfffdcaf0>
   44b58:	85a1883a 	add	r16,r16,r22
   44b5c:	dd800a17 	ldw	r22,40(sp)
   44b60:	00001006 	br	44ba4 <___vfprintf_internal_r+0x4dc>
   44b64:	05c00044 	movi	r23,1
   44b68:	04bfffc4 	movi	r18,-1
   44b6c:	d8000e15 	stw	zero,56(sp)
   44b70:	05400284 	movi	r21,10
   44b74:	9023883a 	mov	r17,r18
   44b78:	d8000c15 	stw	zero,48(sp)
   44b7c:	d8000b15 	stw	zero,44(sp)
   44b80:	b829883a 	mov	r20,r23
   44b84:	00000806 	br	44ba8 <___vfprintf_internal_r+0x4e0>
   44b88:	dd000b15 	stw	r20,44(sp)
   44b8c:	05000084 	movi	r20,2
   44b90:	00000506 	br	44ba8 <___vfprintf_internal_r+0x4e0>
   44b94:	00c00044 	movi	r3,1
   44b98:	d8c00c15 	stw	r3,48(sp)
   44b9c:	050000c4 	movi	r20,3
   44ba0:	00000106 	br	44ba8 <___vfprintf_internal_r+0x4e0>
   44ba4:	0029883a 	mov	r20,zero
   44ba8:	d8c00f17 	ldw	r3,60(sp)
   44bac:	18c00044 	addi	r3,r3,1
   44bb0:	d8c00f15 	stw	r3,60(sp)
   44bb4:	003ede06 	br	44730 <__alt_data_end+0xfffdc730>
   44bb8:	8005883a 	mov	r2,r16
   44bbc:	dfc01a17 	ldw	ra,104(sp)
   44bc0:	df001917 	ldw	fp,100(sp)
   44bc4:	ddc01817 	ldw	r23,96(sp)
   44bc8:	dd801717 	ldw	r22,92(sp)
   44bcc:	dd401617 	ldw	r21,88(sp)
   44bd0:	dd001517 	ldw	r20,84(sp)
   44bd4:	dcc01417 	ldw	r19,80(sp)
   44bd8:	dc801317 	ldw	r18,76(sp)
   44bdc:	dc401217 	ldw	r17,72(sp)
   44be0:	dc001117 	ldw	r16,68(sp)
   44be4:	dec01b04 	addi	sp,sp,108
   44be8:	f800283a 	ret

00044bec <__vfprintf_internal>:
   44bec:	00800174 	movhi	r2,5
   44bf0:	10a10504 	addi	r2,r2,-31724
   44bf4:	300f883a 	mov	r7,r6
   44bf8:	280d883a 	mov	r6,r5
   44bfc:	200b883a 	mov	r5,r4
   44c00:	11000017 	ldw	r4,0(r2)
   44c04:	00446c81 	jmpi	446c8 <___vfprintf_internal_r>

00044c08 <__sfvwrite_small_dev>:
   44c08:	2880000b 	ldhu	r2,0(r5)
   44c0c:	1080020c 	andi	r2,r2,8
   44c10:	10002126 	beq	r2,zero,44c98 <__sfvwrite_small_dev+0x90>
   44c14:	2880008f 	ldh	r2,2(r5)
   44c18:	defffa04 	addi	sp,sp,-24
   44c1c:	dc000015 	stw	r16,0(sp)
   44c20:	dfc00515 	stw	ra,20(sp)
   44c24:	dd000415 	stw	r20,16(sp)
   44c28:	dcc00315 	stw	r19,12(sp)
   44c2c:	dc800215 	stw	r18,8(sp)
   44c30:	dc400115 	stw	r17,4(sp)
   44c34:	2821883a 	mov	r16,r5
   44c38:	10001216 	blt	r2,zero,44c84 <__sfvwrite_small_dev+0x7c>
   44c3c:	2027883a 	mov	r19,r4
   44c40:	3025883a 	mov	r18,r6
   44c44:	3823883a 	mov	r17,r7
   44c48:	05010004 	movi	r20,1024
   44c4c:	04400b0e 	bge	zero,r17,44c7c <__sfvwrite_small_dev+0x74>
   44c50:	880f883a 	mov	r7,r17
   44c54:	a440010e 	bge	r20,r17,44c5c <__sfvwrite_small_dev+0x54>
   44c58:	01c10004 	movi	r7,1024
   44c5c:	8140008f 	ldh	r5,2(r16)
   44c60:	900d883a 	mov	r6,r18
   44c64:	9809883a 	mov	r4,r19
   44c68:	0044cc00 	call	44cc0 <_write_r>
   44c6c:	0080050e 	bge	zero,r2,44c84 <__sfvwrite_small_dev+0x7c>
   44c70:	88a3c83a 	sub	r17,r17,r2
   44c74:	90a5883a 	add	r18,r18,r2
   44c78:	003ff406 	br	44c4c <__alt_data_end+0xfffdcc4c>
   44c7c:	0005883a 	mov	r2,zero
   44c80:	00000706 	br	44ca0 <__sfvwrite_small_dev+0x98>
   44c84:	8080000b 	ldhu	r2,0(r16)
   44c88:	10801014 	ori	r2,r2,64
   44c8c:	8080000d 	sth	r2,0(r16)
   44c90:	00bfffc4 	movi	r2,-1
   44c94:	00000206 	br	44ca0 <__sfvwrite_small_dev+0x98>
   44c98:	00bfffc4 	movi	r2,-1
   44c9c:	f800283a 	ret
   44ca0:	dfc00517 	ldw	ra,20(sp)
   44ca4:	dd000417 	ldw	r20,16(sp)
   44ca8:	dcc00317 	ldw	r19,12(sp)
   44cac:	dc800217 	ldw	r18,8(sp)
   44cb0:	dc400117 	ldw	r17,4(sp)
   44cb4:	dc000017 	ldw	r16,0(sp)
   44cb8:	dec00604 	addi	sp,sp,24
   44cbc:	f800283a 	ret

00044cc0 <_write_r>:
   44cc0:	defffd04 	addi	sp,sp,-12
   44cc4:	dc000015 	stw	r16,0(sp)
   44cc8:	04000174 	movhi	r16,5
   44ccc:	dc400115 	stw	r17,4(sp)
   44cd0:	8421fd04 	addi	r16,r16,-30732
   44cd4:	2023883a 	mov	r17,r4
   44cd8:	2809883a 	mov	r4,r5
   44cdc:	300b883a 	mov	r5,r6
   44ce0:	380d883a 	mov	r6,r7
   44ce4:	dfc00215 	stw	ra,8(sp)
   44ce8:	80000015 	stw	zero,0(r16)
   44cec:	004514c0 	call	4514c <write>
   44cf0:	00ffffc4 	movi	r3,-1
   44cf4:	10c0031e 	bne	r2,r3,44d04 <_write_r+0x44>
   44cf8:	80c00017 	ldw	r3,0(r16)
   44cfc:	18000126 	beq	r3,zero,44d04 <_write_r+0x44>
   44d00:	88c00015 	stw	r3,0(r17)
   44d04:	dfc00217 	ldw	ra,8(sp)
   44d08:	dc400117 	ldw	r17,4(sp)
   44d0c:	dc000017 	ldw	r16,0(sp)
   44d10:	dec00304 	addi	sp,sp,12
   44d14:	f800283a 	ret

00044d18 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   44d18:	defff904 	addi	sp,sp,-28
   44d1c:	dfc00615 	stw	ra,24(sp)
   44d20:	df000515 	stw	fp,20(sp)
   44d24:	df000504 	addi	fp,sp,20
   44d28:	e13ffc15 	stw	r4,-16(fp)
   44d2c:	e17ffd15 	stw	r5,-12(fp)
   44d30:	e1bffe15 	stw	r6,-8(fp)
   44d34:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   44d38:	e0800217 	ldw	r2,8(fp)
   44d3c:	d8800015 	stw	r2,0(sp)
   44d40:	e1ffff17 	ldw	r7,-4(fp)
   44d44:	e1bffe17 	ldw	r6,-8(fp)
   44d48:	e17ffd17 	ldw	r5,-12(fp)
   44d4c:	e13ffc17 	ldw	r4,-16(fp)
   44d50:	0044ec80 	call	44ec8 <alt_iic_isr_register>
}  
   44d54:	e037883a 	mov	sp,fp
   44d58:	dfc00117 	ldw	ra,4(sp)
   44d5c:	df000017 	ldw	fp,0(sp)
   44d60:	dec00204 	addi	sp,sp,8
   44d64:	f800283a 	ret

00044d68 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
   44d68:	defff904 	addi	sp,sp,-28
   44d6c:	df000615 	stw	fp,24(sp)
   44d70:	df000604 	addi	fp,sp,24
   44d74:	e13ffe15 	stw	r4,-8(fp)
   44d78:	e17fff15 	stw	r5,-4(fp)
   44d7c:	e0bfff17 	ldw	r2,-4(fp)
   44d80:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   44d84:	0005303a 	rdctl	r2,status
   44d88:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   44d8c:	e0fffb17 	ldw	r3,-20(fp)
   44d90:	00bfff84 	movi	r2,-2
   44d94:	1884703a 	and	r2,r3,r2
   44d98:	1001703a 	wrctl	status,r2
  
  return context;
   44d9c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   44da0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
   44da4:	00c00044 	movi	r3,1
   44da8:	e0bffa17 	ldw	r2,-24(fp)
   44dac:	1884983a 	sll	r2,r3,r2
   44db0:	1007883a 	mov	r3,r2
   44db4:	d0a10117 	ldw	r2,-31740(gp)
   44db8:	1884b03a 	or	r2,r3,r2
   44dbc:	d0a10115 	stw	r2,-31740(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   44dc0:	d0a10117 	ldw	r2,-31740(gp)
   44dc4:	100170fa 	wrctl	ienable,r2
   44dc8:	e0bffc17 	ldw	r2,-16(fp)
   44dcc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   44dd0:	e0bffd17 	ldw	r2,-12(fp)
   44dd4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   44dd8:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
   44ddc:	0001883a 	nop
}
   44de0:	e037883a 	mov	sp,fp
   44de4:	df000017 	ldw	fp,0(sp)
   44de8:	dec00104 	addi	sp,sp,4
   44dec:	f800283a 	ret

00044df0 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
   44df0:	defff904 	addi	sp,sp,-28
   44df4:	df000615 	stw	fp,24(sp)
   44df8:	df000604 	addi	fp,sp,24
   44dfc:	e13ffe15 	stw	r4,-8(fp)
   44e00:	e17fff15 	stw	r5,-4(fp)
   44e04:	e0bfff17 	ldw	r2,-4(fp)
   44e08:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   44e0c:	0005303a 	rdctl	r2,status
   44e10:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   44e14:	e0fffb17 	ldw	r3,-20(fp)
   44e18:	00bfff84 	movi	r2,-2
   44e1c:	1884703a 	and	r2,r3,r2
   44e20:	1001703a 	wrctl	status,r2
  
  return context;
   44e24:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   44e28:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
   44e2c:	00c00044 	movi	r3,1
   44e30:	e0bffa17 	ldw	r2,-24(fp)
   44e34:	1884983a 	sll	r2,r3,r2
   44e38:	0084303a 	nor	r2,zero,r2
   44e3c:	1007883a 	mov	r3,r2
   44e40:	d0a10117 	ldw	r2,-31740(gp)
   44e44:	1884703a 	and	r2,r3,r2
   44e48:	d0a10115 	stw	r2,-31740(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   44e4c:	d0a10117 	ldw	r2,-31740(gp)
   44e50:	100170fa 	wrctl	ienable,r2
   44e54:	e0bffc17 	ldw	r2,-16(fp)
   44e58:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   44e5c:	e0bffd17 	ldw	r2,-12(fp)
   44e60:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   44e64:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
   44e68:	0001883a 	nop
}
   44e6c:	e037883a 	mov	sp,fp
   44e70:	df000017 	ldw	fp,0(sp)
   44e74:	dec00104 	addi	sp,sp,4
   44e78:	f800283a 	ret

00044e7c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
   44e7c:	defffc04 	addi	sp,sp,-16
   44e80:	df000315 	stw	fp,12(sp)
   44e84:	df000304 	addi	fp,sp,12
   44e88:	e13ffe15 	stw	r4,-8(fp)
   44e8c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   44e90:	000530fa 	rdctl	r2,ienable
   44e94:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
   44e98:	00c00044 	movi	r3,1
   44e9c:	e0bfff17 	ldw	r2,-4(fp)
   44ea0:	1884983a 	sll	r2,r3,r2
   44ea4:	1007883a 	mov	r3,r2
   44ea8:	e0bffd17 	ldw	r2,-12(fp)
   44eac:	1884703a 	and	r2,r3,r2
   44eb0:	1004c03a 	cmpne	r2,r2,zero
   44eb4:	10803fcc 	andi	r2,r2,255
}
   44eb8:	e037883a 	mov	sp,fp
   44ebc:	df000017 	ldw	fp,0(sp)
   44ec0:	dec00104 	addi	sp,sp,4
   44ec4:	f800283a 	ret

00044ec8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   44ec8:	defff504 	addi	sp,sp,-44
   44ecc:	dfc00a15 	stw	ra,40(sp)
   44ed0:	df000915 	stw	fp,36(sp)
   44ed4:	df000904 	addi	fp,sp,36
   44ed8:	e13ffc15 	stw	r4,-16(fp)
   44edc:	e17ffd15 	stw	r5,-12(fp)
   44ee0:	e1bffe15 	stw	r6,-8(fp)
   44ee4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
   44ee8:	00bffa84 	movi	r2,-22
   44eec:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
   44ef0:	e0bffd17 	ldw	r2,-12(fp)
   44ef4:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   44ef8:	e0bff817 	ldw	r2,-32(fp)
   44efc:	10800808 	cmpgei	r2,r2,32
   44f00:	1000271e 	bne	r2,zero,44fa0 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   44f04:	0005303a 	rdctl	r2,status
   44f08:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   44f0c:	e0fffb17 	ldw	r3,-20(fp)
   44f10:	00bfff84 	movi	r2,-2
   44f14:	1884703a 	and	r2,r3,r2
   44f18:	1001703a 	wrctl	status,r2
  
  return context;
   44f1c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
   44f20:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
   44f24:	00800174 	movhi	r2,5
   44f28:	10a20304 	addi	r2,r2,-30708
   44f2c:	e0fff817 	ldw	r3,-32(fp)
   44f30:	180690fa 	slli	r3,r3,3
   44f34:	10c5883a 	add	r2,r2,r3
   44f38:	e0fffe17 	ldw	r3,-8(fp)
   44f3c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
   44f40:	00800174 	movhi	r2,5
   44f44:	10a20304 	addi	r2,r2,-30708
   44f48:	e0fff817 	ldw	r3,-32(fp)
   44f4c:	180690fa 	slli	r3,r3,3
   44f50:	10c5883a 	add	r2,r2,r3
   44f54:	10800104 	addi	r2,r2,4
   44f58:	e0ffff17 	ldw	r3,-4(fp)
   44f5c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   44f60:	e0bffe17 	ldw	r2,-8(fp)
   44f64:	10000526 	beq	r2,zero,44f7c <alt_iic_isr_register+0xb4>
   44f68:	e0bff817 	ldw	r2,-32(fp)
   44f6c:	100b883a 	mov	r5,r2
   44f70:	e13ffc17 	ldw	r4,-16(fp)
   44f74:	0044d680 	call	44d68 <alt_ic_irq_enable>
   44f78:	00000406 	br	44f8c <alt_iic_isr_register+0xc4>
   44f7c:	e0bff817 	ldw	r2,-32(fp)
   44f80:	100b883a 	mov	r5,r2
   44f84:	e13ffc17 	ldw	r4,-16(fp)
   44f88:	0044df00 	call	44df0 <alt_ic_irq_disable>
   44f8c:	e0bff715 	stw	r2,-36(fp)
   44f90:	e0bffa17 	ldw	r2,-24(fp)
   44f94:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   44f98:	e0bff917 	ldw	r2,-28(fp)
   44f9c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
   44fa0:	e0bff717 	ldw	r2,-36(fp)
}
   44fa4:	e037883a 	mov	sp,fp
   44fa8:	dfc00117 	ldw	ra,4(sp)
   44fac:	df000017 	ldw	fp,0(sp)
   44fb0:	dec00204 	addi	sp,sp,8
   44fb4:	f800283a 	ret

00044fb8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   44fb8:	defffc04 	addi	sp,sp,-16
   44fbc:	df000315 	stw	fp,12(sp)
   44fc0:	df000304 	addi	fp,sp,12
   44fc4:	e13ffd15 	stw	r4,-12(fp)
   44fc8:	e17ffe15 	stw	r5,-8(fp)
   44fcc:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   44fd0:	e0fffe17 	ldw	r3,-8(fp)
   44fd4:	e0bffd17 	ldw	r2,-12(fp)
   44fd8:	18800c26 	beq	r3,r2,4500c <alt_load_section+0x54>
  {
    while( to != end )
   44fdc:	00000806 	br	45000 <alt_load_section+0x48>
    {
      *to++ = *from++;
   44fe0:	e0bffe17 	ldw	r2,-8(fp)
   44fe4:	10c00104 	addi	r3,r2,4
   44fe8:	e0fffe15 	stw	r3,-8(fp)
   44fec:	e0fffd17 	ldw	r3,-12(fp)
   44ff0:	19000104 	addi	r4,r3,4
   44ff4:	e13ffd15 	stw	r4,-12(fp)
   44ff8:	18c00017 	ldw	r3,0(r3)
   44ffc:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   45000:	e0fffe17 	ldw	r3,-8(fp)
   45004:	e0bfff17 	ldw	r2,-4(fp)
   45008:	18bff51e 	bne	r3,r2,44fe0 <__alt_data_end+0xfffdcfe0>
    {
      *to++ = *from++;
    }
  }
}
   4500c:	0001883a 	nop
   45010:	e037883a 	mov	sp,fp
   45014:	df000017 	ldw	fp,0(sp)
   45018:	dec00104 	addi	sp,sp,4
   4501c:	f800283a 	ret

00045020 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   45020:	defffe04 	addi	sp,sp,-8
   45024:	dfc00115 	stw	ra,4(sp)
   45028:	df000015 	stw	fp,0(sp)
   4502c:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   45030:	01800174 	movhi	r6,5
   45034:	31a10d04 	addi	r6,r6,-31692
   45038:	01400174 	movhi	r5,5
   4503c:	29602504 	addi	r5,r5,-32620
   45040:	01000174 	movhi	r4,5
   45044:	21210d04 	addi	r4,r4,-31692
   45048:	0044fb80 	call	44fb8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   4504c:	01800134 	movhi	r6,4
   45050:	31809104 	addi	r6,r6,580
   45054:	01400134 	movhi	r5,4
   45058:	29400804 	addi	r5,r5,32
   4505c:	01000134 	movhi	r4,4
   45060:	21000804 	addi	r4,r4,32
   45064:	0044fb80 	call	44fb8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   45068:	01800174 	movhi	r6,5
   4506c:	31a02504 	addi	r6,r6,-32620
   45070:	01400134 	movhi	r5,4
   45074:	29584b04 	addi	r5,r5,24876
   45078:	01000134 	movhi	r4,4
   4507c:	21184b04 	addi	r4,r4,24876
   45080:	0044fb80 	call	44fb8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   45084:	00456340 	call	45634 <alt_dcache_flush_all>
  alt_icache_flush_all();
   45088:	00457600 	call	45760 <alt_icache_flush_all>
}
   4508c:	0001883a 	nop
   45090:	e037883a 	mov	sp,fp
   45094:	dfc00117 	ldw	ra,4(sp)
   45098:	df000017 	ldw	fp,0(sp)
   4509c:	dec00204 	addi	sp,sp,8
   450a0:	f800283a 	ret

000450a4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   450a4:	defffd04 	addi	sp,sp,-12
   450a8:	dfc00215 	stw	ra,8(sp)
   450ac:	df000115 	stw	fp,4(sp)
   450b0:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   450b4:	0009883a 	mov	r4,zero
   450b8:	00452780 	call	45278 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   450bc:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   450c0:	00452b00 	call	452b0 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   450c4:	01800174 	movhi	r6,5
   450c8:	31a01804 	addi	r6,r6,-32672
   450cc:	01400174 	movhi	r5,5
   450d0:	29601804 	addi	r5,r5,-32672
   450d4:	01000174 	movhi	r4,5
   450d8:	21201804 	addi	r4,r4,-32672
   450dc:	00458f40 	call	458f4 <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   450e0:	d0a10217 	ldw	r2,-31736(gp)
   450e4:	d0e10317 	ldw	r3,-31732(gp)
   450e8:	d1210417 	ldw	r4,-31728(gp)
   450ec:	200d883a 	mov	r6,r4
   450f0:	180b883a 	mov	r5,r3
   450f4:	1009883a 	mov	r4,r2
   450f8:	00409b40 	call	409b4 <main>
   450fc:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   45100:	01000044 	movi	r4,1
   45104:	00455640 	call	45564 <close>
  exit (result);
   45108:	e13fff17 	ldw	r4,-4(fp)
   4510c:	0045f180 	call	45f18 <exit>

00045110 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   45110:	defffe04 	addi	sp,sp,-8
   45114:	dfc00115 	stw	ra,4(sp)
   45118:	df000015 	stw	fp,0(sp)
   4511c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   45120:	d0a00f17 	ldw	r2,-32708(gp)
   45124:	10000326 	beq	r2,zero,45134 <alt_get_errno+0x24>
   45128:	d0a00f17 	ldw	r2,-32708(gp)
   4512c:	103ee83a 	callr	r2
   45130:	00000106 	br	45138 <alt_get_errno+0x28>
   45134:	d0a10004 	addi	r2,gp,-31744
}
   45138:	e037883a 	mov	sp,fp
   4513c:	dfc00117 	ldw	ra,4(sp)
   45140:	df000017 	ldw	fp,0(sp)
   45144:	dec00204 	addi	sp,sp,8
   45148:	f800283a 	ret

0004514c <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   4514c:	defff904 	addi	sp,sp,-28
   45150:	dfc00615 	stw	ra,24(sp)
   45154:	df000515 	stw	fp,20(sp)
   45158:	df000504 	addi	fp,sp,20
   4515c:	e13ffd15 	stw	r4,-12(fp)
   45160:	e17ffe15 	stw	r5,-8(fp)
   45164:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   45168:	e0bffd17 	ldw	r2,-12(fp)
   4516c:	10000616 	blt	r2,zero,45188 <write+0x3c>
   45170:	e0bffd17 	ldw	r2,-12(fp)
   45174:	10c00324 	muli	r3,r2,12
   45178:	00800174 	movhi	r2,5
   4517c:	10a09d04 	addi	r2,r2,-32140
   45180:	1885883a 	add	r2,r3,r2
   45184:	00000106 	br	4518c <write+0x40>
   45188:	0005883a 	mov	r2,zero
   4518c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   45190:	e0bffb17 	ldw	r2,-20(fp)
   45194:	10002126 	beq	r2,zero,4521c <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   45198:	e0bffb17 	ldw	r2,-20(fp)
   4519c:	10800217 	ldw	r2,8(r2)
   451a0:	108000cc 	andi	r2,r2,3
   451a4:	10001826 	beq	r2,zero,45208 <write+0xbc>
   451a8:	e0bffb17 	ldw	r2,-20(fp)
   451ac:	10800017 	ldw	r2,0(r2)
   451b0:	10800617 	ldw	r2,24(r2)
   451b4:	10001426 	beq	r2,zero,45208 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   451b8:	e0bffb17 	ldw	r2,-20(fp)
   451bc:	10800017 	ldw	r2,0(r2)
   451c0:	10800617 	ldw	r2,24(r2)
   451c4:	e0ffff17 	ldw	r3,-4(fp)
   451c8:	180d883a 	mov	r6,r3
   451cc:	e17ffe17 	ldw	r5,-8(fp)
   451d0:	e13ffb17 	ldw	r4,-20(fp)
   451d4:	103ee83a 	callr	r2
   451d8:	e0bffc15 	stw	r2,-16(fp)
   451dc:	e0bffc17 	ldw	r2,-16(fp)
   451e0:	1000070e 	bge	r2,zero,45200 <write+0xb4>
      {
        ALT_ERRNO = -rval;
   451e4:	00451100 	call	45110 <alt_get_errno>
   451e8:	1007883a 	mov	r3,r2
   451ec:	e0bffc17 	ldw	r2,-16(fp)
   451f0:	0085c83a 	sub	r2,zero,r2
   451f4:	18800015 	stw	r2,0(r3)
        return -1;
   451f8:	00bfffc4 	movi	r2,-1
   451fc:	00000c06 	br	45230 <write+0xe4>
      }
      return rval;
   45200:	e0bffc17 	ldw	r2,-16(fp)
   45204:	00000a06 	br	45230 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
   45208:	00451100 	call	45110 <alt_get_errno>
   4520c:	1007883a 	mov	r3,r2
   45210:	00800344 	movi	r2,13
   45214:	18800015 	stw	r2,0(r3)
   45218:	00000406 	br	4522c <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   4521c:	00451100 	call	45110 <alt_get_errno>
   45220:	1007883a 	mov	r3,r2
   45224:	00801444 	movi	r2,81
   45228:	18800015 	stw	r2,0(r3)
  }
  return -1;
   4522c:	00bfffc4 	movi	r2,-1
}
   45230:	e037883a 	mov	sp,fp
   45234:	dfc00117 	ldw	ra,4(sp)
   45238:	df000017 	ldw	fp,0(sp)
   4523c:	dec00204 	addi	sp,sp,8
   45240:	f800283a 	ret

00045244 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   45244:	defffd04 	addi	sp,sp,-12
   45248:	dfc00215 	stw	ra,8(sp)
   4524c:	df000115 	stw	fp,4(sp)
   45250:	df000104 	addi	fp,sp,4
   45254:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   45258:	d1600c04 	addi	r5,gp,-32720
   4525c:	e13fff17 	ldw	r4,-4(fp)
   45260:	00456bc0 	call	456bc <alt_dev_llist_insert>
}
   45264:	e037883a 	mov	sp,fp
   45268:	dfc00117 	ldw	ra,4(sp)
   4526c:	df000017 	ldw	fp,0(sp)
   45270:	dec00204 	addi	sp,sp,8
   45274:	f800283a 	ret

00045278 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   45278:	defffd04 	addi	sp,sp,-12
   4527c:	dfc00215 	stw	ra,8(sp)
   45280:	df000115 	stw	fp,4(sp)
   45284:	df000104 	addi	fp,sp,4
   45288:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOSII_CPU, NiosII_CPU);
   4528c:	0045c280 	call	45c28 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   45290:	00800044 	movi	r2,1
   45294:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   45298:	0001883a 	nop
   4529c:	e037883a 	mov	sp,fp
   452a0:	dfc00117 	ldw	ra,4(sp)
   452a4:	df000017 	ldw	fp,0(sp)
   452a8:	dec00204 	addi	sp,sp,8
   452ac:	f800283a 	ret

000452b0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   452b0:	defffe04 	addi	sp,sp,-8
   452b4:	dfc00115 	stw	ra,4(sp)
   452b8:	df000015 	stw	fp,0(sp)
   452bc:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_PWM, timer_pwm);
    ALTERA_AVALON_TIMER_INIT ( TIMER_SECOND, timer_second);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
   452c0:	01000174 	movhi	r4,5
   452c4:	21208804 	addi	r4,r4,-32224
   452c8:	00452440 	call	45244 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
   452cc:	0001883a 	nop
}
   452d0:	0001883a 	nop
   452d4:	e037883a 	mov	sp,fp
   452d8:	dfc00117 	ldw	ra,4(sp)
   452dc:	df000017 	ldw	fp,0(sp)
   452e0:	dec00204 	addi	sp,sp,8
   452e4:	f800283a 	ret

000452e8 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   452e8:	defffa04 	addi	sp,sp,-24
   452ec:	dfc00515 	stw	ra,20(sp)
   452f0:	df000415 	stw	fp,16(sp)
   452f4:	df000404 	addi	fp,sp,16
   452f8:	e13ffd15 	stw	r4,-12(fp)
   452fc:	e17ffe15 	stw	r5,-8(fp)
   45300:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   45304:	e0bffd17 	ldw	r2,-12(fp)
   45308:	10800017 	ldw	r2,0(r2)
   4530c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   45310:	e0bffc17 	ldw	r2,-16(fp)
   45314:	10c00a04 	addi	r3,r2,40
   45318:	e0bffd17 	ldw	r2,-12(fp)
   4531c:	10800217 	ldw	r2,8(r2)
   45320:	100f883a 	mov	r7,r2
   45324:	e1bfff17 	ldw	r6,-4(fp)
   45328:	e17ffe17 	ldw	r5,-8(fp)
   4532c:	1809883a 	mov	r4,r3
   45330:	00453a80 	call	453a8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   45334:	e037883a 	mov	sp,fp
   45338:	dfc00117 	ldw	ra,4(sp)
   4533c:	df000017 	ldw	fp,0(sp)
   45340:	dec00204 	addi	sp,sp,8
   45344:	f800283a 	ret

00045348 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   45348:	defffa04 	addi	sp,sp,-24
   4534c:	dfc00515 	stw	ra,20(sp)
   45350:	df000415 	stw	fp,16(sp)
   45354:	df000404 	addi	fp,sp,16
   45358:	e13ffd15 	stw	r4,-12(fp)
   4535c:	e17ffe15 	stw	r5,-8(fp)
   45360:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   45364:	e0bffd17 	ldw	r2,-12(fp)
   45368:	10800017 	ldw	r2,0(r2)
   4536c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   45370:	e0bffc17 	ldw	r2,-16(fp)
   45374:	10c00a04 	addi	r3,r2,40
   45378:	e0bffd17 	ldw	r2,-12(fp)
   4537c:	10800217 	ldw	r2,8(r2)
   45380:	100f883a 	mov	r7,r2
   45384:	e1bfff17 	ldw	r6,-4(fp)
   45388:	e17ffe17 	ldw	r5,-8(fp)
   4538c:	1809883a 	mov	r4,r3
   45390:	00454940 	call	45494 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   45394:	e037883a 	mov	sp,fp
   45398:	dfc00117 	ldw	ra,4(sp)
   4539c:	df000017 	ldw	fp,0(sp)
   453a0:	dec00204 	addi	sp,sp,8
   453a4:	f800283a 	ret

000453a8 <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
   453a8:	defff704 	addi	sp,sp,-36
   453ac:	df000815 	stw	fp,32(sp)
   453b0:	df000804 	addi	fp,sp,32
   453b4:	e13ffc15 	stw	r4,-16(fp)
   453b8:	e17ffd15 	stw	r5,-12(fp)
   453bc:	e1bffe15 	stw	r6,-8(fp)
   453c0:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   453c4:	e0bffc17 	ldw	r2,-16(fp)
   453c8:	10800017 	ldw	r2,0(r2)
   453cc:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
   453d0:	e0bffd17 	ldw	r2,-12(fp)
   453d4:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
   453d8:	e0bffe17 	ldw	r2,-8(fp)
   453dc:	e0fffd17 	ldw	r3,-12(fp)
   453e0:	1885883a 	add	r2,r3,r2
   453e4:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
   453e8:	00001206 	br	45434 <altera_avalon_jtag_uart_read+0x8c>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   453ec:	e0bff917 	ldw	r2,-28(fp)
   453f0:	10800037 	ldwio	r2,0(r2)
   453f4:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
   453f8:	e0bffb17 	ldw	r2,-20(fp)
   453fc:	10a0000c 	andi	r2,r2,32768
   45400:	10000626 	beq	r2,zero,4541c <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   45404:	e0bff817 	ldw	r2,-32(fp)
   45408:	10c00044 	addi	r3,r2,1
   4540c:	e0fff815 	stw	r3,-32(fp)
   45410:	e0fffb17 	ldw	r3,-20(fp)
   45414:	10c00005 	stb	r3,0(r2)
   45418:	00000606 	br	45434 <altera_avalon_jtag_uart_read+0x8c>
    else if (ptr != buffer)
   4541c:	e0fff817 	ldw	r3,-32(fp)
   45420:	e0bffd17 	ldw	r2,-12(fp)
   45424:	1880071e 	bne	r3,r2,45444 <altera_avalon_jtag_uart_read+0x9c>
      break;
    else if(flags & O_NONBLOCK)
   45428:	e0bfff17 	ldw	r2,-4(fp)
   4542c:	1090000c 	andi	r2,r2,16384
   45430:	1000061e 	bne	r2,zero,4544c <altera_avalon_jtag_uart_read+0xa4>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
   45434:	e0fff817 	ldw	r3,-32(fp)
   45438:	e0bffa17 	ldw	r2,-24(fp)
   4543c:	18bfeb36 	bltu	r3,r2,453ec <__alt_data_end+0xfffdd3ec>
   45440:	00000306 	br	45450 <altera_avalon_jtag_uart_read+0xa8>
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
   45444:	0001883a 	nop
   45448:	00000106 	br	45450 <altera_avalon_jtag_uart_read+0xa8>
    else if(flags & O_NONBLOCK)
      break;   
   4544c:	0001883a 	nop
    
  }

  if (ptr != buffer)
   45450:	e0fff817 	ldw	r3,-32(fp)
   45454:	e0bffd17 	ldw	r2,-12(fp)
   45458:	18800426 	beq	r3,r2,4546c <altera_avalon_jtag_uart_read+0xc4>
    return ptr - buffer;
   4545c:	e0fff817 	ldw	r3,-32(fp)
   45460:	e0bffd17 	ldw	r2,-12(fp)
   45464:	1885c83a 	sub	r2,r3,r2
   45468:	00000606 	br	45484 <altera_avalon_jtag_uart_read+0xdc>
  else if (flags & O_NONBLOCK)
   4546c:	e0bfff17 	ldw	r2,-4(fp)
   45470:	1090000c 	andi	r2,r2,16384
   45474:	10000226 	beq	r2,zero,45480 <altera_avalon_jtag_uart_read+0xd8>
    return -EWOULDBLOCK;
   45478:	00bffd44 	movi	r2,-11
   4547c:	00000106 	br	45484 <altera_avalon_jtag_uart_read+0xdc>
  else
    return -EIO;
   45480:	00bffec4 	movi	r2,-5
}
   45484:	e037883a 	mov	sp,fp
   45488:	df000017 	ldw	fp,0(sp)
   4548c:	dec00104 	addi	sp,sp,4
   45490:	f800283a 	ret

00045494 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   45494:	defff904 	addi	sp,sp,-28
   45498:	df000615 	stw	fp,24(sp)
   4549c:	df000604 	addi	fp,sp,24
   454a0:	e13ffc15 	stw	r4,-16(fp)
   454a4:	e17ffd15 	stw	r5,-12(fp)
   454a8:	e1bffe15 	stw	r6,-8(fp)
   454ac:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   454b0:	e0bffc17 	ldw	r2,-16(fp)
   454b4:	10800017 	ldw	r2,0(r2)
   454b8:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
   454bc:	e0bffe17 	ldw	r2,-8(fp)
   454c0:	e0fffd17 	ldw	r3,-12(fp)
   454c4:	1885883a 	add	r2,r3,r2
   454c8:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
   454cc:	00000e06 	br	45508 <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   454d0:	e0bffa17 	ldw	r2,-24(fp)
   454d4:	10800104 	addi	r2,r2,4
   454d8:	10800037 	ldwio	r2,0(r2)
   454dc:	10bfffec 	andhi	r2,r2,65535
   454e0:	10000926 	beq	r2,zero,45508 <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   454e4:	e0fffa17 	ldw	r3,-24(fp)
   454e8:	e0bffd17 	ldw	r2,-12(fp)
   454ec:	11000044 	addi	r4,r2,1
   454f0:	e13ffd15 	stw	r4,-12(fp)
   454f4:	10800003 	ldbu	r2,0(r2)
   454f8:	10803fcc 	andi	r2,r2,255
   454fc:	1080201c 	xori	r2,r2,128
   45500:	10bfe004 	addi	r2,r2,-128
   45504:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   45508:	e0fffd17 	ldw	r3,-12(fp)
   4550c:	e0bffb17 	ldw	r2,-20(fp)
   45510:	18bfef36 	bltu	r3,r2,454d0 <__alt_data_end+0xfffdd4d0>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
   45514:	e0bffe17 	ldw	r2,-8(fp)
}
   45518:	e037883a 	mov	sp,fp
   4551c:	df000017 	ldw	fp,0(sp)
   45520:	dec00104 	addi	sp,sp,4
   45524:	f800283a 	ret

00045528 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   45528:	defffe04 	addi	sp,sp,-8
   4552c:	dfc00115 	stw	ra,4(sp)
   45530:	df000015 	stw	fp,0(sp)
   45534:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   45538:	d0a00f17 	ldw	r2,-32708(gp)
   4553c:	10000326 	beq	r2,zero,4554c <alt_get_errno+0x24>
   45540:	d0a00f17 	ldw	r2,-32708(gp)
   45544:	103ee83a 	callr	r2
   45548:	00000106 	br	45550 <alt_get_errno+0x28>
   4554c:	d0a10004 	addi	r2,gp,-31744
}
   45550:	e037883a 	mov	sp,fp
   45554:	dfc00117 	ldw	ra,4(sp)
   45558:	df000017 	ldw	fp,0(sp)
   4555c:	dec00204 	addi	sp,sp,8
   45560:	f800283a 	ret

00045564 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   45564:	defffb04 	addi	sp,sp,-20
   45568:	dfc00415 	stw	ra,16(sp)
   4556c:	df000315 	stw	fp,12(sp)
   45570:	df000304 	addi	fp,sp,12
   45574:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   45578:	e0bfff17 	ldw	r2,-4(fp)
   4557c:	10000616 	blt	r2,zero,45598 <close+0x34>
   45580:	e0bfff17 	ldw	r2,-4(fp)
   45584:	10c00324 	muli	r3,r2,12
   45588:	00800174 	movhi	r2,5
   4558c:	10a09d04 	addi	r2,r2,-32140
   45590:	1885883a 	add	r2,r3,r2
   45594:	00000106 	br	4559c <close+0x38>
   45598:	0005883a 	mov	r2,zero
   4559c:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   455a0:	e0bffd17 	ldw	r2,-12(fp)
   455a4:	10001926 	beq	r2,zero,4560c <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   455a8:	e0bffd17 	ldw	r2,-12(fp)
   455ac:	10800017 	ldw	r2,0(r2)
   455b0:	10800417 	ldw	r2,16(r2)
   455b4:	10000626 	beq	r2,zero,455d0 <close+0x6c>
   455b8:	e0bffd17 	ldw	r2,-12(fp)
   455bc:	10800017 	ldw	r2,0(r2)
   455c0:	10800417 	ldw	r2,16(r2)
   455c4:	e13ffd17 	ldw	r4,-12(fp)
   455c8:	103ee83a 	callr	r2
   455cc:	00000106 	br	455d4 <close+0x70>
   455d0:	0005883a 	mov	r2,zero
   455d4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   455d8:	e13fff17 	ldw	r4,-4(fp)
   455dc:	0045bc40 	call	45bc4 <alt_release_fd>
    if (rval < 0)
   455e0:	e0bffe17 	ldw	r2,-8(fp)
   455e4:	1000070e 	bge	r2,zero,45604 <close+0xa0>
    {
      ALT_ERRNO = -rval;
   455e8:	00455280 	call	45528 <alt_get_errno>
   455ec:	1007883a 	mov	r3,r2
   455f0:	e0bffe17 	ldw	r2,-8(fp)
   455f4:	0085c83a 	sub	r2,zero,r2
   455f8:	18800015 	stw	r2,0(r3)
      return -1;
   455fc:	00bfffc4 	movi	r2,-1
   45600:	00000706 	br	45620 <close+0xbc>
    }
    return 0;
   45604:	0005883a 	mov	r2,zero
   45608:	00000506 	br	45620 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   4560c:	00455280 	call	45528 <alt_get_errno>
   45610:	1007883a 	mov	r3,r2
   45614:	00801444 	movi	r2,81
   45618:	18800015 	stw	r2,0(r3)
    return -1;
   4561c:	00bfffc4 	movi	r2,-1
  }
}
   45620:	e037883a 	mov	sp,fp
   45624:	dfc00117 	ldw	ra,4(sp)
   45628:	df000017 	ldw	fp,0(sp)
   4562c:	dec00204 	addi	sp,sp,8
   45630:	f800283a 	ret

00045634 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   45634:	deffff04 	addi	sp,sp,-4
   45638:	df000015 	stw	fp,0(sp)
   4563c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   45640:	0001883a 	nop
   45644:	e037883a 	mov	sp,fp
   45648:	df000017 	ldw	fp,0(sp)
   4564c:	dec00104 	addi	sp,sp,4
   45650:	f800283a 	ret

00045654 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   45654:	defffc04 	addi	sp,sp,-16
   45658:	df000315 	stw	fp,12(sp)
   4565c:	df000304 	addi	fp,sp,12
   45660:	e13ffd15 	stw	r4,-12(fp)
   45664:	e17ffe15 	stw	r5,-8(fp)
   45668:	e1bfff15 	stw	r6,-4(fp)
  return len;
   4566c:	e0bfff17 	ldw	r2,-4(fp)
}
   45670:	e037883a 	mov	sp,fp
   45674:	df000017 	ldw	fp,0(sp)
   45678:	dec00104 	addi	sp,sp,4
   4567c:	f800283a 	ret

00045680 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   45680:	defffe04 	addi	sp,sp,-8
   45684:	dfc00115 	stw	ra,4(sp)
   45688:	df000015 	stw	fp,0(sp)
   4568c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   45690:	d0a00f17 	ldw	r2,-32708(gp)
   45694:	10000326 	beq	r2,zero,456a4 <alt_get_errno+0x24>
   45698:	d0a00f17 	ldw	r2,-32708(gp)
   4569c:	103ee83a 	callr	r2
   456a0:	00000106 	br	456a8 <alt_get_errno+0x28>
   456a4:	d0a10004 	addi	r2,gp,-31744
}
   456a8:	e037883a 	mov	sp,fp
   456ac:	dfc00117 	ldw	ra,4(sp)
   456b0:	df000017 	ldw	fp,0(sp)
   456b4:	dec00204 	addi	sp,sp,8
   456b8:	f800283a 	ret

000456bc <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   456bc:	defffa04 	addi	sp,sp,-24
   456c0:	dfc00515 	stw	ra,20(sp)
   456c4:	df000415 	stw	fp,16(sp)
   456c8:	df000404 	addi	fp,sp,16
   456cc:	e13ffe15 	stw	r4,-8(fp)
   456d0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   456d4:	e0bffe17 	ldw	r2,-8(fp)
   456d8:	10000326 	beq	r2,zero,456e8 <alt_dev_llist_insert+0x2c>
   456dc:	e0bffe17 	ldw	r2,-8(fp)
   456e0:	10800217 	ldw	r2,8(r2)
   456e4:	1000061e 	bne	r2,zero,45700 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
   456e8:	00456800 	call	45680 <alt_get_errno>
   456ec:	1007883a 	mov	r3,r2
   456f0:	00800584 	movi	r2,22
   456f4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   456f8:	00bffa84 	movi	r2,-22
   456fc:	00001306 	br	4574c <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   45700:	e0bffe17 	ldw	r2,-8(fp)
   45704:	e0ffff17 	ldw	r3,-4(fp)
   45708:	e0fffc15 	stw	r3,-16(fp)
   4570c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   45710:	e0bffd17 	ldw	r2,-12(fp)
   45714:	e0fffc17 	ldw	r3,-16(fp)
   45718:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   4571c:	e0bffc17 	ldw	r2,-16(fp)
   45720:	10c00017 	ldw	r3,0(r2)
   45724:	e0bffd17 	ldw	r2,-12(fp)
   45728:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   4572c:	e0bffc17 	ldw	r2,-16(fp)
   45730:	10800017 	ldw	r2,0(r2)
   45734:	e0fffd17 	ldw	r3,-12(fp)
   45738:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   4573c:	e0bffc17 	ldw	r2,-16(fp)
   45740:	e0fffd17 	ldw	r3,-12(fp)
   45744:	10c00015 	stw	r3,0(r2)

  return 0;  
   45748:	0005883a 	mov	r2,zero
}
   4574c:	e037883a 	mov	sp,fp
   45750:	dfc00117 	ldw	ra,4(sp)
   45754:	df000017 	ldw	fp,0(sp)
   45758:	dec00204 	addi	sp,sp,8
   4575c:	f800283a 	ret

00045760 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   45760:	defffe04 	addi	sp,sp,-8
   45764:	dfc00115 	stw	ra,4(sp)
   45768:	df000015 	stw	fp,0(sp)
   4576c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   45770:	01420004 	movi	r5,2048
   45774:	0009883a 	mov	r4,zero
   45778:	0045e880 	call	45e88 <alt_icache_flush>
#endif
}
   4577c:	0001883a 	nop
   45780:	e037883a 	mov	sp,fp
   45784:	dfc00117 	ldw	ra,4(sp)
   45788:	df000017 	ldw	fp,0(sp)
   4578c:	dec00204 	addi	sp,sp,8
   45790:	f800283a 	ret

00045794 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
   45794:	defffe04 	addi	sp,sp,-8
   45798:	df000115 	stw	fp,4(sp)
   4579c:	df000104 	addi	fp,sp,4
   457a0:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
   457a4:	e0bfff17 	ldw	r2,-4(fp)
   457a8:	10bffe84 	addi	r2,r2,-6
   457ac:	10c00428 	cmpgeui	r3,r2,16
   457b0:	18001a1e 	bne	r3,zero,4581c <alt_exception_cause_generated_bad_addr+0x88>
   457b4:	100690ba 	slli	r3,r2,2
   457b8:	00800134 	movhi	r2,4
   457bc:	1095f304 	addi	r2,r2,22476
   457c0:	1885883a 	add	r2,r3,r2
   457c4:	10800017 	ldw	r2,0(r2)
   457c8:	1000683a 	jmp	r2
   457cc:	0004580c 	andi	zero,zero,4448
   457d0:	0004580c 	andi	zero,zero,4448
   457d4:	0004581c 	xori	zero,zero,4448
   457d8:	0004581c 	xori	zero,zero,4448
   457dc:	0004581c 	xori	zero,zero,4448
   457e0:	0004580c 	andi	zero,zero,4448
   457e4:	00045814 	movui	zero,4448
   457e8:	0004581c 	xori	zero,zero,4448
   457ec:	0004580c 	andi	zero,zero,4448
   457f0:	0004580c 	andi	zero,zero,4448
   457f4:	0004581c 	xori	zero,zero,4448
   457f8:	0004580c 	andi	zero,zero,4448
   457fc:	00045814 	movui	zero,4448
   45800:	0004581c 	xori	zero,zero,4448
   45804:	0004581c 	xori	zero,zero,4448
   45808:	0004580c 	andi	zero,zero,4448
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   4580c:	00800044 	movi	r2,1
   45810:	00000306 	br	45820 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   45814:	0005883a 	mov	r2,zero
   45818:	00000106 	br	45820 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
   4581c:	0005883a 	mov	r2,zero
  }
}
   45820:	e037883a 	mov	sp,fp
   45824:	df000017 	ldw	fp,0(sp)
   45828:	dec00104 	addi	sp,sp,4
   4582c:	f800283a 	ret

00045830 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   45830:	defff904 	addi	sp,sp,-28
   45834:	dfc00615 	stw	ra,24(sp)
   45838:	df000515 	stw	fp,20(sp)
   4583c:	df000504 	addi	fp,sp,20
   45840:	e13ffc15 	stw	r4,-16(fp)
   45844:	e17ffd15 	stw	r5,-12(fp)
   45848:	e1bffe15 	stw	r6,-8(fp)
   4584c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   45850:	e1bfff17 	ldw	r6,-4(fp)
   45854:	e17ffe17 	ldw	r5,-8(fp)
   45858:	e13ffd17 	ldw	r4,-12(fp)
   4585c:	0045a700 	call	45a70 <open>
   45860:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   45864:	e0bffb17 	ldw	r2,-20(fp)
   45868:	10001c16 	blt	r2,zero,458dc <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   4586c:	00800174 	movhi	r2,5
   45870:	10a09d04 	addi	r2,r2,-32140
   45874:	e0fffb17 	ldw	r3,-20(fp)
   45878:	18c00324 	muli	r3,r3,12
   4587c:	10c5883a 	add	r2,r2,r3
   45880:	10c00017 	ldw	r3,0(r2)
   45884:	e0bffc17 	ldw	r2,-16(fp)
   45888:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   4588c:	00800174 	movhi	r2,5
   45890:	10a09d04 	addi	r2,r2,-32140
   45894:	e0fffb17 	ldw	r3,-20(fp)
   45898:	18c00324 	muli	r3,r3,12
   4589c:	10c5883a 	add	r2,r2,r3
   458a0:	10800104 	addi	r2,r2,4
   458a4:	10c00017 	ldw	r3,0(r2)
   458a8:	e0bffc17 	ldw	r2,-16(fp)
   458ac:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   458b0:	00800174 	movhi	r2,5
   458b4:	10a09d04 	addi	r2,r2,-32140
   458b8:	e0fffb17 	ldw	r3,-20(fp)
   458bc:	18c00324 	muli	r3,r3,12
   458c0:	10c5883a 	add	r2,r2,r3
   458c4:	10800204 	addi	r2,r2,8
   458c8:	10c00017 	ldw	r3,0(r2)
   458cc:	e0bffc17 	ldw	r2,-16(fp)
   458d0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   458d4:	e13ffb17 	ldw	r4,-20(fp)
   458d8:	0045bc40 	call	45bc4 <alt_release_fd>
  }
} 
   458dc:	0001883a 	nop
   458e0:	e037883a 	mov	sp,fp
   458e4:	dfc00117 	ldw	ra,4(sp)
   458e8:	df000017 	ldw	fp,0(sp)
   458ec:	dec00204 	addi	sp,sp,8
   458f0:	f800283a 	ret

000458f4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   458f4:	defffb04 	addi	sp,sp,-20
   458f8:	dfc00415 	stw	ra,16(sp)
   458fc:	df000315 	stw	fp,12(sp)
   45900:	df000304 	addi	fp,sp,12
   45904:	e13ffd15 	stw	r4,-12(fp)
   45908:	e17ffe15 	stw	r5,-8(fp)
   4590c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   45910:	01c07fc4 	movi	r7,511
   45914:	01800044 	movi	r6,1
   45918:	e17ffd17 	ldw	r5,-12(fp)
   4591c:	01000174 	movhi	r4,5
   45920:	2120a004 	addi	r4,r4,-32128
   45924:	00458300 	call	45830 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   45928:	01c07fc4 	movi	r7,511
   4592c:	000d883a 	mov	r6,zero
   45930:	e17ffe17 	ldw	r5,-8(fp)
   45934:	01000174 	movhi	r4,5
   45938:	21209d04 	addi	r4,r4,-32140
   4593c:	00458300 	call	45830 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   45940:	01c07fc4 	movi	r7,511
   45944:	01800044 	movi	r6,1
   45948:	e17fff17 	ldw	r5,-4(fp)
   4594c:	01000174 	movhi	r4,5
   45950:	2120a304 	addi	r4,r4,-32116
   45954:	00458300 	call	45830 <alt_open_fd>
}  
   45958:	0001883a 	nop
   4595c:	e037883a 	mov	sp,fp
   45960:	dfc00117 	ldw	ra,4(sp)
   45964:	df000017 	ldw	fp,0(sp)
   45968:	dec00204 	addi	sp,sp,8
   4596c:	f800283a 	ret

00045970 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   45970:	defffe04 	addi	sp,sp,-8
   45974:	dfc00115 	stw	ra,4(sp)
   45978:	df000015 	stw	fp,0(sp)
   4597c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   45980:	d0a00f17 	ldw	r2,-32708(gp)
   45984:	10000326 	beq	r2,zero,45994 <alt_get_errno+0x24>
   45988:	d0a00f17 	ldw	r2,-32708(gp)
   4598c:	103ee83a 	callr	r2
   45990:	00000106 	br	45998 <alt_get_errno+0x28>
   45994:	d0a10004 	addi	r2,gp,-31744
}
   45998:	e037883a 	mov	sp,fp
   4599c:	dfc00117 	ldw	ra,4(sp)
   459a0:	df000017 	ldw	fp,0(sp)
   459a4:	dec00204 	addi	sp,sp,8
   459a8:	f800283a 	ret

000459ac <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   459ac:	defffd04 	addi	sp,sp,-12
   459b0:	df000215 	stw	fp,8(sp)
   459b4:	df000204 	addi	fp,sp,8
   459b8:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   459bc:	e0bfff17 	ldw	r2,-4(fp)
   459c0:	10800217 	ldw	r2,8(r2)
   459c4:	10d00034 	orhi	r3,r2,16384
   459c8:	e0bfff17 	ldw	r2,-4(fp)
   459cc:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   459d0:	e03ffe15 	stw	zero,-8(fp)
   459d4:	00001d06 	br	45a4c <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   459d8:	00800174 	movhi	r2,5
   459dc:	10a09d04 	addi	r2,r2,-32140
   459e0:	e0fffe17 	ldw	r3,-8(fp)
   459e4:	18c00324 	muli	r3,r3,12
   459e8:	10c5883a 	add	r2,r2,r3
   459ec:	10c00017 	ldw	r3,0(r2)
   459f0:	e0bfff17 	ldw	r2,-4(fp)
   459f4:	10800017 	ldw	r2,0(r2)
   459f8:	1880111e 	bne	r3,r2,45a40 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   459fc:	00800174 	movhi	r2,5
   45a00:	10a09d04 	addi	r2,r2,-32140
   45a04:	e0fffe17 	ldw	r3,-8(fp)
   45a08:	18c00324 	muli	r3,r3,12
   45a0c:	10c5883a 	add	r2,r2,r3
   45a10:	10800204 	addi	r2,r2,8
   45a14:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   45a18:	1000090e 	bge	r2,zero,45a40 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   45a1c:	e0bffe17 	ldw	r2,-8(fp)
   45a20:	10c00324 	muli	r3,r2,12
   45a24:	00800174 	movhi	r2,5
   45a28:	10a09d04 	addi	r2,r2,-32140
   45a2c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   45a30:	e0bfff17 	ldw	r2,-4(fp)
   45a34:	18800226 	beq	r3,r2,45a40 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   45a38:	00bffcc4 	movi	r2,-13
   45a3c:	00000806 	br	45a60 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   45a40:	e0bffe17 	ldw	r2,-8(fp)
   45a44:	10800044 	addi	r2,r2,1
   45a48:	e0bffe15 	stw	r2,-8(fp)
   45a4c:	d0a00e17 	ldw	r2,-32712(gp)
   45a50:	1007883a 	mov	r3,r2
   45a54:	e0bffe17 	ldw	r2,-8(fp)
   45a58:	18bfdf2e 	bgeu	r3,r2,459d8 <__alt_data_end+0xfffdd9d8>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   45a5c:	0005883a 	mov	r2,zero
}
   45a60:	e037883a 	mov	sp,fp
   45a64:	df000017 	ldw	fp,0(sp)
   45a68:	dec00104 	addi	sp,sp,4
   45a6c:	f800283a 	ret

00045a70 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   45a70:	defff604 	addi	sp,sp,-40
   45a74:	dfc00915 	stw	ra,36(sp)
   45a78:	df000815 	stw	fp,32(sp)
   45a7c:	df000804 	addi	fp,sp,32
   45a80:	e13ffd15 	stw	r4,-12(fp)
   45a84:	e17ffe15 	stw	r5,-8(fp)
   45a88:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   45a8c:	00bfffc4 	movi	r2,-1
   45a90:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   45a94:	00bffb44 	movi	r2,-19
   45a98:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   45a9c:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   45aa0:	d1600c04 	addi	r5,gp,-32720
   45aa4:	e13ffd17 	ldw	r4,-12(fp)
   45aa8:	0045c4c0 	call	45c4c <alt_find_dev>
   45aac:	e0bff815 	stw	r2,-32(fp)
   45ab0:	e0bff817 	ldw	r2,-32(fp)
   45ab4:	1000051e 	bne	r2,zero,45acc <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   45ab8:	e13ffd17 	ldw	r4,-12(fp)
   45abc:	0045cdc0 	call	45cdc <alt_find_file>
   45ac0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   45ac4:	00800044 	movi	r2,1
   45ac8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   45acc:	e0bff817 	ldw	r2,-32(fp)
   45ad0:	10002926 	beq	r2,zero,45b78 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
   45ad4:	e13ff817 	ldw	r4,-32(fp)
   45ad8:	0045de40 	call	45de4 <alt_get_fd>
   45adc:	e0bff915 	stw	r2,-28(fp)
   45ae0:	e0bff917 	ldw	r2,-28(fp)
   45ae4:	1000030e 	bge	r2,zero,45af4 <open+0x84>
    {
      status = index;
   45ae8:	e0bff917 	ldw	r2,-28(fp)
   45aec:	e0bffa15 	stw	r2,-24(fp)
   45af0:	00002306 	br	45b80 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
   45af4:	e0bff917 	ldw	r2,-28(fp)
   45af8:	10c00324 	muli	r3,r2,12
   45afc:	00800174 	movhi	r2,5
   45b00:	10a09d04 	addi	r2,r2,-32140
   45b04:	1885883a 	add	r2,r3,r2
   45b08:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   45b0c:	e0fffe17 	ldw	r3,-8(fp)
   45b10:	00900034 	movhi	r2,16384
   45b14:	10bfffc4 	addi	r2,r2,-1
   45b18:	1886703a 	and	r3,r3,r2
   45b1c:	e0bffc17 	ldw	r2,-16(fp)
   45b20:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   45b24:	e0bffb17 	ldw	r2,-20(fp)
   45b28:	1000051e 	bne	r2,zero,45b40 <open+0xd0>
   45b2c:	e13ffc17 	ldw	r4,-16(fp)
   45b30:	00459ac0 	call	459ac <alt_file_locked>
   45b34:	e0bffa15 	stw	r2,-24(fp)
   45b38:	e0bffa17 	ldw	r2,-24(fp)
   45b3c:	10001016 	blt	r2,zero,45b80 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   45b40:	e0bff817 	ldw	r2,-32(fp)
   45b44:	10800317 	ldw	r2,12(r2)
   45b48:	10000826 	beq	r2,zero,45b6c <open+0xfc>
   45b4c:	e0bff817 	ldw	r2,-32(fp)
   45b50:	10800317 	ldw	r2,12(r2)
   45b54:	e1ffff17 	ldw	r7,-4(fp)
   45b58:	e1bffe17 	ldw	r6,-8(fp)
   45b5c:	e17ffd17 	ldw	r5,-12(fp)
   45b60:	e13ffc17 	ldw	r4,-16(fp)
   45b64:	103ee83a 	callr	r2
   45b68:	00000106 	br	45b70 <open+0x100>
   45b6c:	0005883a 	mov	r2,zero
   45b70:	e0bffa15 	stw	r2,-24(fp)
   45b74:	00000206 	br	45b80 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
   45b78:	00bffb44 	movi	r2,-19
   45b7c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   45b80:	e0bffa17 	ldw	r2,-24(fp)
   45b84:	1000090e 	bge	r2,zero,45bac <open+0x13c>
  {
    alt_release_fd (index);  
   45b88:	e13ff917 	ldw	r4,-28(fp)
   45b8c:	0045bc40 	call	45bc4 <alt_release_fd>
    ALT_ERRNO = -status;
   45b90:	00459700 	call	45970 <alt_get_errno>
   45b94:	1007883a 	mov	r3,r2
   45b98:	e0bffa17 	ldw	r2,-24(fp)
   45b9c:	0085c83a 	sub	r2,zero,r2
   45ba0:	18800015 	stw	r2,0(r3)
    return -1;
   45ba4:	00bfffc4 	movi	r2,-1
   45ba8:	00000106 	br	45bb0 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   45bac:	e0bff917 	ldw	r2,-28(fp)
}
   45bb0:	e037883a 	mov	sp,fp
   45bb4:	dfc00117 	ldw	ra,4(sp)
   45bb8:	df000017 	ldw	fp,0(sp)
   45bbc:	dec00204 	addi	sp,sp,8
   45bc0:	f800283a 	ret

00045bc4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   45bc4:	defffe04 	addi	sp,sp,-8
   45bc8:	df000115 	stw	fp,4(sp)
   45bcc:	df000104 	addi	fp,sp,4
   45bd0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   45bd4:	e0bfff17 	ldw	r2,-4(fp)
   45bd8:	108000d0 	cmplti	r2,r2,3
   45bdc:	10000d1e 	bne	r2,zero,45c14 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   45be0:	00800174 	movhi	r2,5
   45be4:	10a09d04 	addi	r2,r2,-32140
   45be8:	e0ffff17 	ldw	r3,-4(fp)
   45bec:	18c00324 	muli	r3,r3,12
   45bf0:	10c5883a 	add	r2,r2,r3
   45bf4:	10800204 	addi	r2,r2,8
   45bf8:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   45bfc:	00800174 	movhi	r2,5
   45c00:	10a09d04 	addi	r2,r2,-32140
   45c04:	e0ffff17 	ldw	r3,-4(fp)
   45c08:	18c00324 	muli	r3,r3,12
   45c0c:	10c5883a 	add	r2,r2,r3
   45c10:	10000015 	stw	zero,0(r2)
  }
}
   45c14:	0001883a 	nop
   45c18:	e037883a 	mov	sp,fp
   45c1c:	df000017 	ldw	fp,0(sp)
   45c20:	dec00104 	addi	sp,sp,4
   45c24:	f800283a 	ret

00045c28 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
   45c28:	deffff04 	addi	sp,sp,-4
   45c2c:	df000015 	stw	fp,0(sp)
   45c30:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   45c34:	000170fa 	wrctl	ienable,zero
}
   45c38:	0001883a 	nop
   45c3c:	e037883a 	mov	sp,fp
   45c40:	df000017 	ldw	fp,0(sp)
   45c44:	dec00104 	addi	sp,sp,4
   45c48:	f800283a 	ret

00045c4c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   45c4c:	defffa04 	addi	sp,sp,-24
   45c50:	dfc00515 	stw	ra,20(sp)
   45c54:	df000415 	stw	fp,16(sp)
   45c58:	df000404 	addi	fp,sp,16
   45c5c:	e13ffe15 	stw	r4,-8(fp)
   45c60:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   45c64:	e0bfff17 	ldw	r2,-4(fp)
   45c68:	10800017 	ldw	r2,0(r2)
   45c6c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   45c70:	e13ffe17 	ldw	r4,-8(fp)
   45c74:	00446400 	call	44640 <strlen>
   45c78:	10800044 	addi	r2,r2,1
   45c7c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   45c80:	00000d06 	br	45cb8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   45c84:	e0bffc17 	ldw	r2,-16(fp)
   45c88:	10800217 	ldw	r2,8(r2)
   45c8c:	e0fffd17 	ldw	r3,-12(fp)
   45c90:	180d883a 	mov	r6,r3
   45c94:	e17ffe17 	ldw	r5,-8(fp)
   45c98:	1009883a 	mov	r4,r2
   45c9c:	0045f380 	call	45f38 <memcmp>
   45ca0:	1000021e 	bne	r2,zero,45cac <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   45ca4:	e0bffc17 	ldw	r2,-16(fp)
   45ca8:	00000706 	br	45cc8 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   45cac:	e0bffc17 	ldw	r2,-16(fp)
   45cb0:	10800017 	ldw	r2,0(r2)
   45cb4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   45cb8:	e0fffc17 	ldw	r3,-16(fp)
   45cbc:	e0bfff17 	ldw	r2,-4(fp)
   45cc0:	18bff01e 	bne	r3,r2,45c84 <__alt_data_end+0xfffddc84>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   45cc4:	0005883a 	mov	r2,zero
}
   45cc8:	e037883a 	mov	sp,fp
   45ccc:	dfc00117 	ldw	ra,4(sp)
   45cd0:	df000017 	ldw	fp,0(sp)
   45cd4:	dec00204 	addi	sp,sp,8
   45cd8:	f800283a 	ret

00045cdc <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   45cdc:	defffb04 	addi	sp,sp,-20
   45ce0:	dfc00415 	stw	ra,16(sp)
   45ce4:	df000315 	stw	fp,12(sp)
   45ce8:	df000304 	addi	fp,sp,12
   45cec:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   45cf0:	d0a00a17 	ldw	r2,-32728(gp)
   45cf4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   45cf8:	00003106 	br	45dc0 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
   45cfc:	e0bffd17 	ldw	r2,-12(fp)
   45d00:	10800217 	ldw	r2,8(r2)
   45d04:	1009883a 	mov	r4,r2
   45d08:	00446400 	call	44640 <strlen>
   45d0c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   45d10:	e0bffd17 	ldw	r2,-12(fp)
   45d14:	10c00217 	ldw	r3,8(r2)
   45d18:	e0bffe17 	ldw	r2,-8(fp)
   45d1c:	10bfffc4 	addi	r2,r2,-1
   45d20:	1885883a 	add	r2,r3,r2
   45d24:	10800003 	ldbu	r2,0(r2)
   45d28:	10803fcc 	andi	r2,r2,255
   45d2c:	1080201c 	xori	r2,r2,128
   45d30:	10bfe004 	addi	r2,r2,-128
   45d34:	10800bd8 	cmpnei	r2,r2,47
   45d38:	1000031e 	bne	r2,zero,45d48 <alt_find_file+0x6c>
    {
      len -= 1;
   45d3c:	e0bffe17 	ldw	r2,-8(fp)
   45d40:	10bfffc4 	addi	r2,r2,-1
   45d44:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   45d48:	e0bffe17 	ldw	r2,-8(fp)
   45d4c:	e0ffff17 	ldw	r3,-4(fp)
   45d50:	1885883a 	add	r2,r3,r2
   45d54:	10800003 	ldbu	r2,0(r2)
   45d58:	10803fcc 	andi	r2,r2,255
   45d5c:	1080201c 	xori	r2,r2,128
   45d60:	10bfe004 	addi	r2,r2,-128
   45d64:	10800be0 	cmpeqi	r2,r2,47
   45d68:	1000081e 	bne	r2,zero,45d8c <alt_find_file+0xb0>
   45d6c:	e0bffe17 	ldw	r2,-8(fp)
   45d70:	e0ffff17 	ldw	r3,-4(fp)
   45d74:	1885883a 	add	r2,r3,r2
   45d78:	10800003 	ldbu	r2,0(r2)
   45d7c:	10803fcc 	andi	r2,r2,255
   45d80:	1080201c 	xori	r2,r2,128
   45d84:	10bfe004 	addi	r2,r2,-128
   45d88:	10000a1e 	bne	r2,zero,45db4 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
   45d8c:	e0bffd17 	ldw	r2,-12(fp)
   45d90:	10800217 	ldw	r2,8(r2)
   45d94:	e0fffe17 	ldw	r3,-8(fp)
   45d98:	180d883a 	mov	r6,r3
   45d9c:	e17fff17 	ldw	r5,-4(fp)
   45da0:	1009883a 	mov	r4,r2
   45da4:	0045f380 	call	45f38 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   45da8:	1000021e 	bne	r2,zero,45db4 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   45dac:	e0bffd17 	ldw	r2,-12(fp)
   45db0:	00000706 	br	45dd0 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
   45db4:	e0bffd17 	ldw	r2,-12(fp)
   45db8:	10800017 	ldw	r2,0(r2)
   45dbc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   45dc0:	e0fffd17 	ldw	r3,-12(fp)
   45dc4:	d0a00a04 	addi	r2,gp,-32728
   45dc8:	18bfcc1e 	bne	r3,r2,45cfc <__alt_data_end+0xfffddcfc>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   45dcc:	0005883a 	mov	r2,zero
}
   45dd0:	e037883a 	mov	sp,fp
   45dd4:	dfc00117 	ldw	ra,4(sp)
   45dd8:	df000017 	ldw	fp,0(sp)
   45ddc:	dec00204 	addi	sp,sp,8
   45de0:	f800283a 	ret

00045de4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   45de4:	defffc04 	addi	sp,sp,-16
   45de8:	df000315 	stw	fp,12(sp)
   45dec:	df000304 	addi	fp,sp,12
   45df0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   45df4:	00bffa04 	movi	r2,-24
   45df8:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   45dfc:	e03ffd15 	stw	zero,-12(fp)
   45e00:	00001906 	br	45e68 <alt_get_fd+0x84>
  {
    if (!alt_fd_list[i].dev)
   45e04:	00800174 	movhi	r2,5
   45e08:	10a09d04 	addi	r2,r2,-32140
   45e0c:	e0fffd17 	ldw	r3,-12(fp)
   45e10:	18c00324 	muli	r3,r3,12
   45e14:	10c5883a 	add	r2,r2,r3
   45e18:	10800017 	ldw	r2,0(r2)
   45e1c:	10000f1e 	bne	r2,zero,45e5c <alt_get_fd+0x78>
    {
      alt_fd_list[i].dev = dev;
   45e20:	00800174 	movhi	r2,5
   45e24:	10a09d04 	addi	r2,r2,-32140
   45e28:	e0fffd17 	ldw	r3,-12(fp)
   45e2c:	18c00324 	muli	r3,r3,12
   45e30:	10c5883a 	add	r2,r2,r3
   45e34:	e0ffff17 	ldw	r3,-4(fp)
   45e38:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   45e3c:	d0e00e17 	ldw	r3,-32712(gp)
   45e40:	e0bffd17 	ldw	r2,-12(fp)
   45e44:	1880020e 	bge	r3,r2,45e50 <alt_get_fd+0x6c>
      {
        alt_max_fd = i;
   45e48:	e0bffd17 	ldw	r2,-12(fp)
   45e4c:	d0a00e15 	stw	r2,-32712(gp)
      }
      rc = i;
   45e50:	e0bffd17 	ldw	r2,-12(fp)
   45e54:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   45e58:	00000606 	br	45e74 <alt_get_fd+0x90>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   45e5c:	e0bffd17 	ldw	r2,-12(fp)
   45e60:	10800044 	addi	r2,r2,1
   45e64:	e0bffd15 	stw	r2,-12(fp)
   45e68:	e0bffd17 	ldw	r2,-12(fp)
   45e6c:	10800810 	cmplti	r2,r2,32
   45e70:	103fe41e 	bne	r2,zero,45e04 <__alt_data_end+0xfffdde04>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   45e74:	e0bffe17 	ldw	r2,-8(fp)
}
   45e78:	e037883a 	mov	sp,fp
   45e7c:	df000017 	ldw	fp,0(sp)
   45e80:	dec00104 	addi	sp,sp,4
   45e84:	f800283a 	ret

00045e88 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   45e88:	defffb04 	addi	sp,sp,-20
   45e8c:	df000415 	stw	fp,16(sp)
   45e90:	df000404 	addi	fp,sp,16
   45e94:	e13ffe15 	stw	r4,-8(fp)
   45e98:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   45e9c:	e0bfff17 	ldw	r2,-4(fp)
   45ea0:	10820070 	cmpltui	r2,r2,2049
   45ea4:	1000021e 	bne	r2,zero,45eb0 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   45ea8:	00820004 	movi	r2,2048
   45eac:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   45eb0:	e0fffe17 	ldw	r3,-8(fp)
   45eb4:	e0bfff17 	ldw	r2,-4(fp)
   45eb8:	1885883a 	add	r2,r3,r2
   45ebc:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   45ec0:	e0bffe17 	ldw	r2,-8(fp)
   45ec4:	e0bffc15 	stw	r2,-16(fp)
   45ec8:	00000506 	br	45ee0 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   45ecc:	e0bffc17 	ldw	r2,-16(fp)
   45ed0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   45ed4:	e0bffc17 	ldw	r2,-16(fp)
   45ed8:	10800804 	addi	r2,r2,32
   45edc:	e0bffc15 	stw	r2,-16(fp)
   45ee0:	e0fffc17 	ldw	r3,-16(fp)
   45ee4:	e0bffd17 	ldw	r2,-12(fp)
   45ee8:	18bff836 	bltu	r3,r2,45ecc <__alt_data_end+0xfffddecc>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   45eec:	e0bffe17 	ldw	r2,-8(fp)
   45ef0:	108007cc 	andi	r2,r2,31
   45ef4:	10000226 	beq	r2,zero,45f00 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   45ef8:	e0bffc17 	ldw	r2,-16(fp)
   45efc:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   45f00:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   45f04:	0001883a 	nop
   45f08:	e037883a 	mov	sp,fp
   45f0c:	df000017 	ldw	fp,0(sp)
   45f10:	dec00104 	addi	sp,sp,4
   45f14:	f800283a 	ret

00045f18 <exit>:
   45f18:	defffe04 	addi	sp,sp,-8
   45f1c:	000b883a 	mov	r5,zero
   45f20:	dc000015 	stw	r16,0(sp)
   45f24:	dfc00115 	stw	ra,4(sp)
   45f28:	2021883a 	mov	r16,r4
   45f2c:	0045f680 	call	45f68 <__call_exitprocs>
   45f30:	8009883a 	mov	r4,r16
   45f34:	00460f80 	call	460f8 <_exit>

00045f38 <memcmp>:
   45f38:	218d883a 	add	r6,r4,r6
   45f3c:	21800826 	beq	r4,r6,45f60 <memcmp+0x28>
   45f40:	20800003 	ldbu	r2,0(r4)
   45f44:	28c00003 	ldbu	r3,0(r5)
   45f48:	10c00226 	beq	r2,r3,45f54 <memcmp+0x1c>
   45f4c:	10c5c83a 	sub	r2,r2,r3
   45f50:	f800283a 	ret
   45f54:	21000044 	addi	r4,r4,1
   45f58:	29400044 	addi	r5,r5,1
   45f5c:	003ff706 	br	45f3c <__alt_data_end+0xfffddf3c>
   45f60:	0005883a 	mov	r2,zero
   45f64:	f800283a 	ret

00045f68 <__call_exitprocs>:
   45f68:	defff504 	addi	sp,sp,-44
   45f6c:	dd000515 	stw	r20,20(sp)
   45f70:	05000174 	movhi	r20,5
   45f74:	dc800315 	stw	r18,12(sp)
   45f78:	dfc00a15 	stw	ra,40(sp)
   45f7c:	df000915 	stw	fp,36(sp)
   45f80:	ddc00815 	stw	r23,32(sp)
   45f84:	dd800715 	stw	r22,28(sp)
   45f88:	dd400615 	stw	r21,24(sp)
   45f8c:	dcc00415 	stw	r19,16(sp)
   45f90:	dc400215 	stw	r17,8(sp)
   45f94:	dc000115 	stw	r16,4(sp)
   45f98:	d9000015 	stw	r4,0(sp)
   45f9c:	2825883a 	mov	r18,r5
   45fa0:	a5210404 	addi	r20,r20,-31728
   45fa4:	a4400017 	ldw	r17,0(r20)
   45fa8:	8cc00c17 	ldw	r19,48(r17)
   45fac:	8c400c04 	addi	r17,r17,48
   45fb0:	98004526 	beq	r19,zero,460c8 <__call_exitprocs+0x160>
   45fb4:	9c000117 	ldw	r16,4(r19)
   45fb8:	00900034 	movhi	r2,16384
   45fbc:	10bfffc4 	addi	r2,r2,-1
   45fc0:	9d402217 	ldw	r21,136(r19)
   45fc4:	85bfffc4 	addi	r22,r16,-1
   45fc8:	80a1883a 	add	r16,r16,r2
   45fcc:	8421883a 	add	r16,r16,r16
   45fd0:	8421883a 	add	r16,r16,r16
   45fd4:	ac2f883a 	add	r23,r21,r16
   45fd8:	84000204 	addi	r16,r16,8
   45fdc:	9c21883a 	add	r16,r19,r16
   45fe0:	b0002716 	blt	r22,zero,46080 <__call_exitprocs+0x118>
   45fe4:	90000726 	beq	r18,zero,46004 <__call_exitprocs+0x9c>
   45fe8:	a800041e 	bne	r21,zero,45ffc <__call_exitprocs+0x94>
   45fec:	b5bfffc4 	addi	r22,r22,-1
   45ff0:	bdffff04 	addi	r23,r23,-4
   45ff4:	843fff04 	addi	r16,r16,-4
   45ff8:	003ff906 	br	45fe0 <__alt_data_end+0xfffddfe0>
   45ffc:	b9002017 	ldw	r4,128(r23)
   46000:	913ffa1e 	bne	r18,r4,45fec <__alt_data_end+0xfffddfec>
   46004:	99000117 	ldw	r4,4(r19)
   46008:	82000017 	ldw	r8,0(r16)
   4600c:	213fffc4 	addi	r4,r4,-1
   46010:	b100021e 	bne	r22,r4,4601c <__call_exitprocs+0xb4>
   46014:	9d800115 	stw	r22,4(r19)
   46018:	00000106 	br	46020 <__call_exitprocs+0xb8>
   4601c:	80000015 	stw	zero,0(r16)
   46020:	403ff226 	beq	r8,zero,45fec <__alt_data_end+0xfffddfec>
   46024:	9f000117 	ldw	fp,4(r19)
   46028:	a8000526 	beq	r21,zero,46040 <__call_exitprocs+0xd8>
   4602c:	00800044 	movi	r2,1
   46030:	1592983a 	sll	r9,r2,r22
   46034:	a9404017 	ldw	r5,256(r21)
   46038:	494a703a 	and	r5,r9,r5
   4603c:	2800021e 	bne	r5,zero,46048 <__call_exitprocs+0xe0>
   46040:	403ee83a 	callr	r8
   46044:	00000906 	br	4606c <__call_exitprocs+0x104>
   46048:	a9004117 	ldw	r4,260(r21)
   4604c:	4908703a 	and	r4,r9,r4
   46050:	2000041e 	bne	r4,zero,46064 <__call_exitprocs+0xfc>
   46054:	b9400017 	ldw	r5,0(r23)
   46058:	d9000017 	ldw	r4,0(sp)
   4605c:	403ee83a 	callr	r8
   46060:	00000206 	br	4606c <__call_exitprocs+0x104>
   46064:	b9000017 	ldw	r4,0(r23)
   46068:	403ee83a 	callr	r8
   4606c:	99000117 	ldw	r4,4(r19)
   46070:	e13fcc1e 	bne	fp,r4,45fa4 <__alt_data_end+0xfffddfa4>
   46074:	89000017 	ldw	r4,0(r17)
   46078:	993fdc26 	beq	r19,r4,45fec <__alt_data_end+0xfffddfec>
   4607c:	003fc906 	br	45fa4 <__alt_data_end+0xfffddfa4>
   46080:	00800034 	movhi	r2,0
   46084:	10800004 	addi	r2,r2,0
   46088:	10000f26 	beq	r2,zero,460c8 <__call_exitprocs+0x160>
   4608c:	99400117 	ldw	r5,4(r19)
   46090:	99000017 	ldw	r4,0(r19)
   46094:	2800091e 	bne	r5,zero,460bc <__call_exitprocs+0x154>
   46098:	20000826 	beq	r4,zero,460bc <__call_exitprocs+0x154>
   4609c:	89000015 	stw	r4,0(r17)
   460a0:	a8000226 	beq	r21,zero,460ac <__call_exitprocs+0x144>
   460a4:	a809883a 	mov	r4,r21
   460a8:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   460ac:	9809883a 	mov	r4,r19
   460b0:	00000000 	call	0 <__alt_mem_onchip_memory-0x40000>
   460b4:	8cc00017 	ldw	r19,0(r17)
   460b8:	003fbd06 	br	45fb0 <__alt_data_end+0xfffddfb0>
   460bc:	9823883a 	mov	r17,r19
   460c0:	2027883a 	mov	r19,r4
   460c4:	003fba06 	br	45fb0 <__alt_data_end+0xfffddfb0>
   460c8:	dfc00a17 	ldw	ra,40(sp)
   460cc:	df000917 	ldw	fp,36(sp)
   460d0:	ddc00817 	ldw	r23,32(sp)
   460d4:	dd800717 	ldw	r22,28(sp)
   460d8:	dd400617 	ldw	r21,24(sp)
   460dc:	dd000517 	ldw	r20,20(sp)
   460e0:	dcc00417 	ldw	r19,16(sp)
   460e4:	dc800317 	ldw	r18,12(sp)
   460e8:	dc400217 	ldw	r17,8(sp)
   460ec:	dc000117 	ldw	r16,4(sp)
   460f0:	dec00b04 	addi	sp,sp,44
   460f4:	f800283a 	ret

000460f8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   460f8:	defffd04 	addi	sp,sp,-12
   460fc:	df000215 	stw	fp,8(sp)
   46100:	df000204 	addi	fp,sp,8
   46104:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   46108:	0001883a 	nop
   4610c:	e0bfff17 	ldw	r2,-4(fp)
   46110:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
   46114:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   46118:	10000226 	beq	r2,zero,46124 <_exit+0x2c>
    ALT_SIM_FAIL();
   4611c:	002af070 	cmpltui	zero,zero,43969
   46120:	00000106 	br	46128 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
   46124:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   46128:	003fff06 	br	46128 <__alt_data_end+0xfffde128>
